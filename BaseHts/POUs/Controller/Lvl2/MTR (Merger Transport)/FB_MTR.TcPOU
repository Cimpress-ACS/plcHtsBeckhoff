<TcPlcObject Version="1.1.0.1" ProductVersion="3.1.0.23">
  <POU Name="FB_MTR" Id="{78a971ef-395c-47a6-99a8-13a1a416d9af}">
    <Declaration><![CDATA[FUNCTION_BLOCK FB_MTR EXTENDS FB_CtrlBase IMPLEMENTS IBuffer
VAR_INPUT
	/// Sensor hanger detected
	In_bolHangerDetected: BOOL;
	/// Sensor pin detected
	In_bolPinDetected: BOOL;
END_VAR
VAR
	/// Specific interface struct for public access
	SIf: T_Ctrl_SIf_MTR;
	/// Section buffer
	a_stSectionBuffer: ARRAY[0..Const_MTR.cusiSectionBuffer_SIZE] OF T_MTR_Buffer_Sections;
	/// List of pointers to Childs
	a_pLineChildCtrl: ARRAY[0..Base_Const.cMaxNrOfChilds] OF POINTER TO FB_STB;
	/// List of childs common interface
	a_pLineChildCIF: ARRAY[0..Base_Const.cMaxNrOfChilds] OF POINTER TO T_Ctrl_CIf;
	/// List of childs specific interface for additional parameters or cur
	a_pLineChildSIF: ARRAY[0..Base_Const.cMaxNrOfChilds] OF POINTER TO T_Ctrl_SIf_STB;
	usiNumOfLines: USINT;
	usiNumOfValidPointerToLine: USINT;
	/// Last new position value from parent
	dinTransportPositionOld_um: DINT;
	/// Driven Way in the task
	dinDrivenWay_um: DINT;
	/// Position correction in faster Task cycletime
	dinPositionCorrection_um: DINT;
	/// Edge detection of the inputs
	bolRE_HangerDetected: BOOL;
	bolRE_PinDetected: BOOL;
	/// Position of the last line. Used to detect if a section is driven out
	dinPositionOfLastLine_um: DINT;
	/// Loop variable
	intLine: INT;
	bolExit: BOOL;
	/// Simulated section length
	dinSimSectionLength_um: DINT := 510000;
	/// Simulated way to trigger section start/end
	dinSimWayTrigSection_um: DINT;
END_VAR
]]></Declaration>
    <Implementation>
      <ST><![CDATA[(*__________________________________________________________________________________________________
¦	
¦	Vistaprint Schweiz GmbH
¦	CH - 8401 Winterthur
¦
¦	www.vistaprint.ch - info@vistaprint.ch
¦___________________________________________________________________________________________________

Function desription:
This controller will be used in combination with childs of type STB to merge hangers
from different slides into a transport system of type TLK.

History:
Version		Date			Author		Comment
---------------------------------------------------------------------------------------------------
0.00.1		25.04.2014		AVME/DSC	Start history.				  
								
__________________________________________________________________________________________________*)


IF ((me.bolActivate) AND (THIS^.checkChildValid())) THEN // cyclic call enabled
	IF (CIf.Info.bolInitDone=FALSE) THEN // first cycle -> init
		CtrlInit();
		CIf.Info.bolInitDone := TRUE;
	ELSE
		CycleStartDuty();
	
		Always();
		
		StateMachine();
		
		CycleEndDuty();
	END_IF
END_IF;

]]></ST>
    </Implementation>
    <Method Name="CalcSumOfItems" Id="{040f66b4-3a90-4549-902a-0a74ac21d8c4}">
      <Declaration><![CDATA[METHOD PROTECTED CalcSumOfItems : DINT
VAR
	ii: INT;
	dinSumOfItems: DINT;
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[// Method calculate the sum of hangers from all lines and return the result.

//Init
CalcSumOfItems:= 0;
dinSumOfItems:= 0;

// Loop over all childs
FOR ii:=0 TO usiNumOfLines-1 BY 1 DO
	// Build sum of all zones		
	dinSumOfItems:= dinSumOfItems + a_pLineChildSIF[ii]^.Cur.dinNumOfHangersInBuffer; 	
END_FOR

// Return result
CalcSumOfItems:= dinSumOfItems;]]></ST>
      </Implementation>
      <ObjectProperties />
    </Method>
    <Method Name="checkChildAlmClass" Id="{07cb5ec1-77ec-46db-8f5d-c6032f195522}">
      <Declaration><![CDATA[METHOD checkChildAlmClass : BOOL
]]></Declaration>
      <Implementation>
        <ST><![CDATA[//------------------------------------------------------------------------------------------------------
// check child alarm classes
// set me alarm class active if at least one child has an EOFF
IF CheckAllChildAlmClass(E_AlmClass.EOFF) THEN
	CIf.Job.eMe_ActivAlmClass := E_AlmClass.EOFF;
	me.Alarm.bolfp := TRUE;
ELSIF CheckAllChildAlmClass(E_AlmClass.OFF) THEN
	CIf.Job.eMe_ActivAlmClass := E_AlmClass.OFF;
	me.Alarm.bolfp := TRUE;
ELSIF CheckAllChildAlmClass(E_AlmClass.STOP) THEN  // FB_MER needs alarm class STOP
	CIf.Job.eMe_ActivAlmClass := E_AlmClass.STOP;
	me.Alarm.bolfp := TRUE;
ELSE
	IF (me.Alarm.bolfp) THEN
		CIf.Job.eMe_ActivAlmClass := E_AlmClass.NONE; // no reset necessary
		me.Alarm.bolfp := FALSE;
	END_IF
END_IF

//------------------------------------------------------------------------------------------------------
// set alarm class parent of childs
//------------------------------------------------------------------------------------------------------
// set alarm class parent of childs in the case of a parent EOFF or me=OFF or EOFF
IF (CIf.Job.eParent_ActivAlmClass=E_AlmClass.EOFF) THEN
	SetAllChildAlmClass(CIf.Job.eParent_ActivAlmClass);
ELSIF(CIf.Job.eMe_ActivAlmClass=E_AlmClass.EOFF) OR (CIf.Job.eMe_ActivAlmClass=E_AlmClass.OFF) THEN
	SetAllChildAlmClass(CIf.Job.eMe_ActivAlmClass);
ELSE
	// no important alarm for child active
	SetAllChildAlmClass(E_AlmClass.NONE);
END_IF]]></ST>
      </Implementation>
      <ObjectProperties />
    </Method>
    <Method Name="AddLine" Id="{23a62a43-dace-4f3a-920c-523379ed9455}">
      <Declaration><![CDATA[METHOD AddLine
VAR_INPUT
	p_Line: POINTER TO FB_STB;
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[
// Method add the pointer address of the line child controller to the array list.
IF (usiNumOfLines <= (Base_Const.cMaxNrOfChilds-1)) THEN
	// Add line child controller to list
	a_pLineChildCtrl[usiNumOfLines] := p_Line;
	// Inc. number of lines
	usiNumOfLines:= usiNumOfLines+1;
	// Check if the pointer is valid
	IF (p_Line<>0) THEN
		usiNumOfValidPointerToLine:= usiNumOfValidPointerToLine+1;
	END_IF
END_IF]]></ST>
      </Implementation>
      <ObjectProperties />
    </Method>
    <Method Name="getCtrlSIf" Id="{3ae5f8c4-d626-4e3d-abb5-7533affcaa88}">
      <Declaration><![CDATA[METHOD getCtrlSIf : POINTER TO T_Ctrl_SIf_MTR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[getCtrlSIf := ADR(SIf);]]></ST>
      </Implementation>
      <ObjectProperties />
    </Method>
    <Property Name="NumOfHangers" Id="{70a9e0ab-674f-415e-8b74-54adf7785f2d}">
      <Declaration><![CDATA[PROPERTY NumOfHangers : DINT
]]></Declaration>
      <Get Name="Get" Id="{81a61f84-baf4-4e04-b2a8-c612637d44e5}">
        <Declaration><![CDATA[]]></Declaration>
        <Implementation>
          <ST><![CDATA[NumOfHangers:= SIf.Cur.dinCurrentItemCount;]]></ST>
        </Implementation>
        <ObjectProperties />
      </Get>
      <ObjectProperties />
    </Property>
    <Property Name="BufferFull" Id="{70d5827c-14fd-401d-8402-58e3a10e4390}">
      <Declaration><![CDATA[PROPERTY BufferFull : BOOL
]]></Declaration>
      <Get Name="Get" Id="{d6001e58-fec1-45df-8b2f-1b04825194c1}">
        <Declaration><![CDATA[]]></Declaration>
        <Implementation>
          <ST><![CDATA[BufferFull:= False;]]></ST>
        </Implementation>
        <ObjectProperties />
      </Get>
      <ObjectProperties />
    </Property>
    <Method Name="IoInBridge" Id="{7b78afea-695f-4b56-a746-a2287d97f91a}">
      <Declaration><![CDATA[METHOD PROTECTED IoInBridge : BOOL
]]></Declaration>
      <Implementation>
        <ST><![CDATA[// digitale and analoge inputs read from hardware or forcing
SIf.In.bolHangerDetected.map := THIS^.In_bolHangerDetected;
SIf.In.bolPinDetected.map := THIS^.In_bolPinDetected;

IF (CIf.SwCfg.bolSimulation = FALSE) THEN
	getInBol(CIf.Job.bolIoForce,ADR(SIf.In.bolHangerDetected));
	getInBol(CIf.Job.bolIoForce,ADR(SIf.In.bolPinDetected));
ELSE
	//simulation of global IO
END_IF]]></ST>
      </Implementation>
      <ObjectProperties />
    </Method>
    <Method Name="CmdToAllLines" Id="{7e1861f9-af1f-4682-93b6-5131a63606ca}">
      <Declaration><![CDATA[METHOD PROTECTED CmdToAllLines
VAR_INPUT
	cCMD: INT;
END_VAR
VAR
	ii: INT;
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[// Method send input command to all existing line child controller.
FOR ii:=0 TO usiNumOfLines-1 BY 1 DO	
	a_pLineChildCIF[ii]^.Job.intACmd:= cCMD;
END_FOR


]]></ST>
      </Implementation>
      <ObjectProperties />
    </Method>
    <Method Name="sta_RUN" Id="{82318327-a84d-43e3-af5c-1351d9eb4e4e}">
      <Declaration><![CDATA[METHOD PROTECTED sta_RUN : BOOL
VAR
	/// Looping variable
	intSec: INT;
	intDeleteRes: INT;
	intReservationCount: INT;
	intLineNum: INT;
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[// state implemetation
//--------------------------------------------------------------------------------------
// Entry action
	IF (me.StateMachine.intState<>me.StateMachine.intStateLastCycle) THEN
		me.StateMachine.intStateLastCycle := me.StateMachine.intState;	
		// Init	
		intLine:= 0;
	END_IF

//--------------------------------------------------------------------------------------
// Cyclic action
	IF (me.StateMachine.intState=me.StateMachine.intStateLastCycle) THEN
						
		//----------------------------------------------------------------------
		// Set the section start and end positions (triggered by pin sensor)
		//----------------------------------------------------------------------
		
		// Simulation of section start and end
		IF (CIf.SwCfg.bolSimulation = TRUE) THEN		
			SIf.In.bolPinDetected.intern:= FALSE;
			
			IF (dinSimWayTrigSection_um >= dinSimSectionLength_um) THEN
				dinSimWayTrigSection_um:= 0;
				// Set true for one cycle
				SIf.In.bolPinDetected.intern:= TRUE;
			END_IF
			// Increase position		
			dinSimWayTrigSection_um:= dinSimWayTrigSection_um + dinDrivenWay_um;				
		END_IF
				
		// Wait for positive edge of the pin sensor (pin detected)
		IF (SIf.In.bolPinDetected.intern = TRUE) AND (bolRE_PinDetected = FALSE) THEN
			bolRE_PinDetected := TRUE;
				
			// Loop over section buffer
			FOR intSec := 0 TO Const_MTR.cusiSectionBuffer_SIZE DO
				
				// If start position already set
				IF (a_stSectionBuffer[intSec].enmState = E_Typ_MTR_SECTION_STATE.StartPositionSet) THEN						
					// Set end position of the section
					a_stSectionBuffer[intSec].dinSecEndPos:= 0 - SIf.Par.dinPinLenght_um;
					a_stSectionBuffer[intSec].usiReservedForLine:= 0;
					a_stSectionBuffer[intSec].enmState:= E_Typ_MTR_SECTION_STATE.EndPositionSet;
				END_IF
				
				// Free buffer element  
				IF ((a_stSectionBuffer[intSec].enmState = E_Typ_MTR_SECTION_STATE.Undefined) OR (a_stSectionBuffer[intSec].enmState = E_Typ_MTR_SECTION_STATE.HangerReleased)) THEN			
					// Set start position of the section
					a_stSectionBuffer[intSec].dinSecStartPos:= 0 - SIf.Par.dinPinLenght_um;
					a_stSectionBuffer[intSec].enmState:= E_Typ_MTR_SECTION_STATE.StartPositionSet;
					EXIT;									  
				END_IF
												
			END_FOR
				
		ELSIF (SIf.In.bolPinDetected.intern = FALSE) AND (bolRE_PinDetected = TRUE) THEN
			bolRE_PinDetected := FALSE;
		END_IF

		//----------------------------------------------------------------------
		// Set section engaged (hanger in section)
		//----------------------------------------------------------------------
		
		// Wait for positive edge of the hanger sensor
		IF (SIf.In.bolHangerDetected.intern = TRUE) AND (bolRE_HangerDetected = FALSE) THEN
			bolRE_HangerDetected := TRUE;
				
			// Loop over section buffer to mark buffer element with 3 = section engaged (hanger in section detected by hanger sensor)
			FOR intSec := 0 TO Const_MTR.cusiSectionBuffer_SIZE-1 DO		
				
				// Prio 1: Normal sequence.
				IF (SIf.Par.dinHangerSensorPosition_um < a_stSectionBuffer[intSec].dinSecStartPos) AND  
					(SIf.Par.dinHangerSensorPosition_um > (a_stSectionBuffer[intSec].dinSecEndPos - SIf.Par.dinPinLenght_um)) THEN	
						// Mark the buffer element as engaged (hanger in section detected by hanger sensor)
						a_stSectionBuffer[intSec].enmState:= E_Typ_MTR_SECTION_STATE.EngagedByDetecSensor;
					EXIT;
				
				// Prio 2: If range is not accurately recognized mark buffer element X and X +1.
				ELSIF (SIf.Par.dinHangerSensorPosition_um < a_stSectionBuffer[intSec].dinSecEndPos) AND  
					(SIf.Par.dinHangerSensorPosition_um > a_stSectionBuffer[intSec+1].dinSecStartPos) THEN	
						// Mark the buffer element as engaged (hanger in section detected by hanger sensor)
						a_stSectionBuffer[intSec].enmState:= E_Typ_MTR_SECTION_STATE.EngagedByDetecSensor;
						a_stSectionBuffer[intSec+1].enmState:= E_Typ_MTR_SECTION_STATE.EngagedByDetecSensor;
					EXIT;
				END_IF		
					
			END_FOR	
				
		ELSIF (SIf.In.bolHangerDetected.intern = FALSE) AND (bolRE_HangerDetected = TRUE) THEN
			bolRE_HangerDetected := FALSE;
		END_IF	
		
		//----------------------------------------------------------------------
		// Buffer tracking 
		//----------------------------------------------------------------------
		
		// Move all buffer elements 1 down if section is driven out at the last line!		
		IF  (a_stSectionBuffer[0].enmState = E_Typ_MTR_SECTION_STATE.HangerReleased) OR (a_stSectionBuffer[0].dinSecEndPos > (dinPositionOfLastLine_um + SIf.Par.dinSectionLenght_um))THEN
			// Loop every buffer element 1 Down
			FOR intSec := 0 TO Const_MTR.cusiSectionBuffer_SIZE-1 DO			
				a_stSectionBuffer[intSec].dinSecStartPos := a_stSectionBuffer[intSec+1].dinSecStartPos;
				a_stSectionBuffer[intSec].dinSecEndPos := a_stSectionBuffer[intSec+1].dinSecEndPos;
				a_stSectionBuffer[intSec].dinTrigStartPos := a_stSectionBuffer[intSec+1].dinTrigStartPos;
				a_stSectionBuffer[intSec].dinTrigEndPos := a_stSectionBuffer[intSec+1].dinTrigEndPos;		
				a_stSectionBuffer[intSec].usiReservedForLine:= a_stSectionBuffer[intSec+1].usiReservedForLine;			
				a_stSectionBuffer[intSec].enmState := a_stSectionBuffer[intSec+1].enmState;
			END_FOR		
			a_stSectionBuffer[intSec].dinSecStartPos := 0;
			a_stSectionBuffer[intSec].dinSecEndPos := 0;
			a_stSectionBuffer[intSec].dinTrigStartPos := 0;
			a_stSectionBuffer[intSec].dinTrigEndPos := 0;
			a_stSectionBuffer[intSec].usiReservedForLine := 0;
			a_stSectionBuffer[intSec].enmState := E_Typ_MTR_SECTION_STATE.Undefined;
		END_IF
	
		//----------------------------------------------------------------------
		// Increase section positions
		//----------------------------------------------------------------------
		
		// Increase section positions and reserve sections
		FOR intSec := 0 TO Const_MTR.cusiSectionBuffer_SIZE DO
			IF (a_stSectionBuffer[intSec].enmState = E_Typ_MTR_SECTION_STATE.StartPositionSet) THEN
				// Section start/end
				a_stSectionBuffer[intSec].dinSecStartPos:= a_stSectionBuffer[intSec].dinSecStartPos + dinDrivenWay_um;
				// Trigger start/end
				a_stSectionBuffer[intSec].dinTrigStartPos:= a_stSectionBuffer[intSec].dinSecStartPos - SIf.Par.dinTrigStartOffset_um;
				a_stSectionBuffer[intSec].dinTrigEndPos:= a_stSectionBuffer[intSec].dinSecStartPos - SIf.Par.dinTrigEndOffset_um;	
				
			ELSIF (a_stSectionBuffer[intSec].enmState >= E_Typ_MTR_SECTION_STATE.EndPositionSet) THEN
				// Section start/end
				a_stSectionBuffer[intSec].dinSecStartPos:= a_stSectionBuffer[intSec].dinSecStartPos + dinDrivenWay_um;
				a_stSectionBuffer[intSec].dinSecEndPos:= a_stSectionBuffer[intSec].dinSecEndPos + dinDrivenWay_um;
				// Trigger start/end
				a_stSectionBuffer[intSec].dinTrigStartPos:= a_stSectionBuffer[intSec].dinSecStartPos - SIf.Par.dinTrigStartOffset_um;
				a_stSectionBuffer[intSec].dinTrigEndPos:= a_stSectionBuffer[intSec].dinSecStartPos - SIf.Par.dinTrigEndOffset_um;
			END_IF
		END_FOR

		//-------------------------------------------------------------------------------------
		// Handle reservation for a section, also clear reservations if no hanger exist 
		//-------------------------------------------------------------------------------------
		
		FOR intSec := 0 TO Const_MTR.cusiSectionBuffer_SIZE DO

			// Note: If the section end passed the position of the hanger detection sensor, the section is not engaged and the section start pos. is before position of the first line, 
			// then the section can reserved for a line.
			IF (a_stSectionBuffer[intSec].enmState = E_Typ_MTR_SECTION_STATE.EndPositionSet) AND 
			   (a_stSectionBuffer[intSec].dinSecEndPos > SIf.Par.dinHangerSensorPosition_um) THEN 
			  // (a_stSectionBuffer[intSec].dinSecStartPos < a_pLineChildSIF[0]^.Par.dinPositionOfSlide_um) THEN   	// ToDO: DSC, test
			
	
				bolExit:= FALSE;	
				WHILE (NOT bolExit) DO						
					IF (intLine <= (usiNumOfLines-1)) THEN			
			
						// Check if hanger exist on line
						// .............................
						IF (a_pLineChildSIF[intLine]^.Cur.bolHangerDetected) THEN
										
							IF (a_stSectionBuffer[intSec].dinSecStartPos < a_pLineChildSIF[intLine]^.Par.dinPositionOfSlide_um) THEN	// ToDO: DSC, test
								// Reserve a section for this line
								intLineNum:= intLine + 1;
								a_stSectionBuffer[intSec].usiReservedForLine:= INT_TO_USINT(intLineNum);
								a_stSectionBuffer[intSec].enmState:= E_Typ_MTR_SECTION_STATE.Reserved;
							END_IF
							
							// Set start index for next cycle
							IF (intLine < (usiNumOfLines-1)) THEN
								intLine:= intLine + 1;	
							ELSE
								intLine:= 0;
							END_IF
							// -> Exit
							bolExit:= TRUE;
							
						// No hanger exist (no further hanger)
						// ............................
						ELSE
							// Delete existing reservations for this line. Make new space for other lines. 
							FOR intDeleteRes := 0 TO Const_MTR.cusiSectionBuffer_SIZE DO
								// Check if a section is already reserved for this line
								IF ((a_stSectionBuffer[intDeleteRes].enmState = E_Typ_MTR_SECTION_STATE.Reserved) AND (a_stSectionBuffer[intDeleteRes].usiReservedForLine = INT_TO_USINT(intLine+1))) THEN
									// Delete reservation
									a_stSectionBuffer[intDeleteRes].usiReservedForLine:= 0;
									a_stSectionBuffer[intDeleteRes].enmState:= E_Typ_MTR_SECTION_STATE.EndPositionSet;			
								END_IF						
							END_FOR
						END_IF	
						// Inc. index to next line
						intLine:= intLine + 1;				
					ELSE
						// Start again at first line	
						intLine:= 0;
						bolExit:= TRUE;
					END_IF				
				END_WHILE		
								
			END_IF

		END_FOR

		// Check States for parent information
		THIS^.checkStateAllLines(cSTA_RUN);
		
		// State Change Condition
		IF (me.intCmd=cCMD_STOP) THEN
			me.StateMachine.intStateNext := cSTA_STOPBusy;
		END_IF
		
	END_IF

//--------------------------------------------------------------------------------------
// Exit action
	IF (me.StateMachine.intState<>me.StateMachine.intStateNext) THEN
		;
	END_IF]]></ST>
      </Implementation>
      <ObjectProperties />
    </Method>
    <Method Name="sta_OFF" Id="{8483a59b-34a0-46dd-a5fe-c33c2e845b35}">
      <Declaration><![CDATA[METHOD PROTECTED sta_OFF : BOOL
]]></Declaration>
      <Implementation>
        <ST><![CDATA[// state implemetation
//--------------------------------------------------------------------------------------
// Entry action
	IF (me.StateMachine.intState<>me.StateMachine.intStateLastCycle) THEN
		me.StateMachine.intStateLastCycle := me.StateMachine.intState;
		;		
	END_IF

//--------------------------------------------------------------------------------------
// Cyclic action
	IF (me.StateMachine.intState=me.StateMachine.intStateLastCycle) THEN
		
		// Reset total counter
		SIf.Cur.dinNumOfMergedHangersTotal:= 0;
		
		// State Change Condition
		IF (me.Alarm.eActivAlmClass<>E_AlmClass.EOFF) AND (me.Alarm.eActivAlmClass<>E_AlmClass.OFF) THEN
			IF (me.intCmd=cCMD_STOP) THEN
				me.StateMachine.intStateNext := cSTA_STOPBusy;
			ELSIF (me.intCmd=cCMD_RUN) THEN 
				me.StateMachine.intStateNext := cSTA_RUNBusy;
			END_IF
		END_IF
	END_IF

//--------------------------------------------------------------------------------------
// Exit action
	IF (me.StateMachine.intState<>me.StateMachine.intStateNext) THEN
		;
	END_IF]]></ST>
      </Implementation>
      <ObjectProperties />
    </Method>
    <Method Name="StateMachine" Id="{84a8cf9e-c51f-4b06-9709-31b644d98fb9}">
      <Declaration><![CDATA[METHOD PROTECTED StateMachine : BOOL
]]></Declaration>
      <Implementation>
        <ST><![CDATA[SUPER^.StateMachine();

// main statemachine of base controller
CASE me.StateMachine.intState OF
    cSTA_STOPBusy: 
        THIS^.sta_STOPBusy();
    cSTA_STOP: 
        THIS^.sta_STOP();
	cSTA_RUNBusy: 
        THIS^.sta_RUNBusy();
    cSTA_RUN: 
        THIS^.sta_RUN();				
END_CASE;]]></ST>
      </Implementation>
      <ObjectProperties />
    </Method>
    <Method Name="FB_init" Id="{8db7aa5b-4b0c-422c-88b1-2d7dd41685b3}">
      <Declaration><![CDATA[METHOD FB_init : BOOL
VAR_INPUT
	///if TRUE, the retain variables are initialized (warm start / cold start)
	bInitRetains: BOOL;
	///if TRUE, the instance afterwards gets moved into the copy code (online change)
	bInCopyCode: BOOL;
END_VAR
VAR
	ii: UINT;
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[//------------------------------------------------------------------------------------------------------------------------
// to manually change in new FUB implementation!!!
// define valid commands for this controller
FOR ii:= 0 TO (SIZEOF(CIf.Job.aCmdList)/SIZEOF(CIf.Job.aCmdList[0])-1) BY 1 DO
	IF (CIf.Job.aCmdList[ii].intCmd=cCMD_INITIALIZED) THEN
		// found first empty array element
		EXIT;
	END_IF
END_FOR

CIf.Job.aCmdList[ii].intCmd := cCMD_STOP;
CIf.Job.aCmdList[ii].strName := 'Stop'; 
CIf.Job.aCmdList[ii].bolAvailable := TRUE;
ii := ii +1;
CIf.Job.aCmdList[ii].intCmd := cCMD_RUN;
CIf.Job.aCmdList[ii].strName := 'Run';
CIf.Job.aCmdList[ii].bolAvailable := TRUE;

// set name of class/typ
CIf.Info.strType := 'FB_MTR'; 

// set alarm class
SIf.Alm[1].eAlmClass := E_AlmClass.STOP;
SIf.Alm[1].strText := 'Invalid child pointer';


//*******************************************************************************
// initial values
//*******************************************************************************

// software configuration
CIf.SwCfg.bolExist := TRUE;
CIf.SwCfg.bolSimulation := FALSE;

// configuration

// parameter
]]></ST>
      </Implementation>
      <ObjectProperties />
    </Method>
    <Method Name="checkChildValid" Id="{94ba4448-1305-4140-ab7a-a344e77340b4}">
      <Declaration><![CDATA[METHOD PROTECTED checkChildValid : BOOL
]]></Declaration>
      <Implementation>
        <ST><![CDATA[IF (usiNumOfLines = usiNumOfValidPointerToLine) THEN
	checkChildValid:= TRUE;
ELSE
	checkChildValid:= FALSE;
	// Invalid child pointer
	IF (usiNumOfLines <> usiNumOfValidPointerToLine) THEN
		// SIf.Alm[1].strText := 'Invalid child pointer'; 
		pfbAlarmCtrl^.setAlarm(CIf.Info.intCtrlId,1,0,ADR(SIf.Alm),E_AlmState.RST,CIf.Job.eMe_ActivAlmClass);	
	END_IF
END_IF]]></ST>
      </Implementation>
      <ObjectProperties />
    </Method>
    <Method Name="checkStateAllLines" Id="{a6a33c36-f0b2-4008-8b80-e2d50b3342da}">
      <Declaration><![CDATA[METHOD PROTECTED checkStateAllLines : BOOL
VAR_INPUT
	cSTA: INT;
END_VAR
VAR
	ii: INT;
	usiNumOfCheckedChilds: USINT;
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[// Method check input state of all lines

//Init
checkStateAllLines:= FALSE;
usiNumOfCheckedChilds:= 0;

// Loop over all childs
FOR ii:=0 TO usiNumOfLines-1 BY 1 DO
	// Check state	
	// Special condition: In case if the child is in state ERROR and STOP is requested. Set child as checked.
	// Parent controller need state STOP that automatic stop sequence can work for all other childs.
	IF (a_pLineChildCIF[ii]^.Job.intState = cSTA) OR ((a_pLineChildCIF[ii]^.Job.intState = cSTA_ERROR) AND (cSTA = cSTA_STOP)) THEN
		usiNumOfCheckedChilds:= usiNumOfCheckedChilds+1;
		SIf.Cur.a_bolChildReady[ii] := TRUE;
	ELSE
		SIf.Cur.a_bolChildReady[ii] := FALSE;		
	END_IF

END_FOR

// All states equal the input state
IF (usiNumOfCheckedChilds = usiNumOfLines) THEN
	checkStateAllLines:= TRUE;
END_IF]]></ST>
      </Implementation>
      <ObjectProperties />
    </Method>
    <Property Name="MaxCapacity" Id="{b8e4f081-f964-4257-93db-b03336b6a073}">
      <Declaration><![CDATA[PROPERTY MaxCapacity : DINT
]]></Declaration>
      <Get Name="Get" Id="{e9b12fca-38bf-4ca1-82f5-077ec4ab95f8}">
        <Declaration><![CDATA[]]></Declaration>
        <Implementation>
          <ST><![CDATA[MaxCapacity:= SIf.Cur.dinMaxCapacity;]]></ST>
        </Implementation>
        <ObjectProperties />
      </Get>
      <ObjectProperties />
    </Property>
    <Method Name="sta_STOPBusy" Id="{c34ce03e-c1bc-4906-8ce7-8d367c30ecd2}">
      <Declaration><![CDATA[METHOD PROTECTED sta_STOPBusy : BOOL
]]></Declaration>
      <Implementation>
        <ST><![CDATA[// state implemetation
//--------------------------------------------------------------------------------------
// Entry action
	IF (me.StateMachine.intState<>me.StateMachine.intStateLastCycle) THEN
		me.StateMachine.intStateLastCycle := me.StateMachine.intState;
		
		// send command STOP to all existing line child controller.
		THIS^.CmdToAllLines(cCMD_STOP);

	END_IF

//--------------------------------------------------------------------------------------
// Cyclic action
	IF (me.StateMachine.intState=me.StateMachine.intStateLastCycle) THEN
			
		// State Change Condition
		// Check if all STOPPED
		IF (THIS^.checkStateAllLines(cSTA_STOP)) THEN
			me.StateMachine.intStateNext := cSTA_STOP;
		END_IF
	END_IF

//--------------------------------------------------------------------------------------
// Exit action
	IF (me.StateMachine.intState<>me.StateMachine.intStateNext) THEN
		;
	END_IF]]></ST>
      </Implementation>
      <ObjectProperties />
    </Method>
    <Method Name="CalcMaxCapacity" Id="{c35dc5a9-65e1-4d3b-9337-d8102cf5aaf7}">
      <Declaration><![CDATA[METHOD PROTECTED CalcMaxCapacity : DINT
VAR
	ii: INT;
	dinSumMaxCapacity: DINT;
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[// Method calculate the sum of max. capacities from all lines and return the result.

//Init
CalcMaxCapacity:= 0;
dinSumMaxCapacity:= 0;

// Loop over all childs
FOR ii:=0 TO usiNumOfLines-1 BY 1 DO
	// Build sum of all lines		
	dinSumMaxCapacity:= dinSumMaxCapacity + a_pLineChildSIF[ii]^.Cfg.dinMaxCapacity; 	
END_FOR

// Return result
CalcMaxCapacity:= dinSumMaxCapacity;]]></ST>
      </Implementation>
      <ObjectProperties />
    </Method>
    <Method Name="sta_STOP" Id="{c6a95020-750c-4ad0-b257-ce472ce193c3}">
      <Declaration><![CDATA[METHOD PROTECTED sta_STOP : BOOL
]]></Declaration>
      <Implementation>
        <ST><![CDATA[// state implemetation
//--------------------------------------------------------------------------------------
// Entry action
	IF (me.StateMachine.intState<>me.StateMachine.intStateLastCycle) THEN
		me.StateMachine.intStateLastCycle := me.StateMachine.intState;
		;
	END_IF

//--------------------------------------------------------------------------------------
// Cyclic action
	IF (me.StateMachine.intState=me.StateMachine.intStateLastCycle) THEN

		// State Change Condition	
		IF (me.intCmd = cCMD_RUN) THEN 
			me.StateMachine.intStateNext := cSTA_RUNBusy;
		END_IF
	END_IF

//-------------------------------------------------------------------------------------
// Exit action
	IF (me.StateMachine.intState<>me.StateMachine.intStateNext) THEN
		;
	END_IF]]></ST>
      </Implementation>
      <ObjectProperties />
    </Method>
    <Method Name="sta_RUNBusy" Id="{e8d4aee0-c1ef-4194-b036-6c56c29362bf}">
      <Declaration><![CDATA[METHOD PROTECTED sta_RUNBusy : BOOL
VAR
	ii: INT;
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[// state implemetation
//--------------------------------------------------------------------------------------
// Entry action
	IF (me.StateMachine.intState<>me.StateMachine.intStateLastCycle) THEN
		me.StateMachine.intStateLastCycle := me.StateMachine.intState;
		;
	END_IF

//--------------------------------------------------------------------------------------
// Cyclic action
	IF (me.StateMachine.intState=me.StateMachine.intStateLastCycle) THEN
			
		// Clear section buffer
		FOR ii := 0 TO Const_MTR.cusiSectionBuffer_SIZE DO
			a_stSectionBuffer[ii].dinSecStartPos := 0;
			a_stSectionBuffer[ii].dinSecEndPos := 0;
			a_stSectionBuffer[ii].dinTrigStartPos := 0;
			a_stSectionBuffer[ii].dinTrigEndPos := 0;
			a_stSectionBuffer[ii].enmState := E_Typ_MTR_SECTION_STATE.Undefined;
			a_stSectionBuffer[ii].usiReservedForLine:= 0;
		END_FOR
			
		// send command RUN to all existing line child controller.
		THIS^.CmdToAllLines(cCMD_RUN);
			
		// State Change Condition	
		IF (THIS^.checkStateAllLines(cSTA_RUN)) THEN
			me.StateMachine.intStateNext := cSTA_RUN;		
		END_IF

	END_IF

//--------------------------------------------------------------------------------------
// Exit action
	IF (me.StateMachine.intState<>me.StateMachine.intStateNext) THEN
		;
	END_IF]]></ST>
      </Implementation>
      <ObjectProperties />
    </Method>
    <Method Name="Always" Id="{e911ff6e-bb85-48fa-8010-1d284dac476c}">
      <Declaration><![CDATA[METHOD PROTECTED Always : BOOL
VAR
	ii: INT;
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[IF (me.bolChangeBackToAUTO=TRUE) THEN // switch mode to automatic switch off controller
	//me.StateMachine.intStateNext := cSTA_OFFBusy;
	//me.bolChangeBackToAUTO := FALSE; // for cylinder no change to off when switch to automatic!!
END_IF

SUPER^.Always();

// ----------------------------------------------------------------------------------
// cyclic actions outside of statemachine
IF (me.StateMachine.intState<>cSTA_SINGLE_ANSWER) THEN
	
	//-------------------------------------------------
	// Provide current values for the parent
	//-------------------------------------------------	
	
	// Number of lines to merge, depends on how many times the method "AddLine" was called at init
	SIf.Cur.usiNumOfLinesToMerge:= usiNumOfLines;
	// Actual Item Count of this controller -> based on all lines
	SIf.Cur.dinCurrentItemCount:= THIS^.CalcSumOfItems();
	// Max. buffer capacity -> based on all lines
	SIf.Cur.dinMaxCapacity:= THIS^.CalcMaxCapacity();	

	//----------------------------------------------------------------------
	// Calculate position for transport 
	//----------------------------------------------------------------------
		
	// If this task is used in a faster cycle as the parent, the driven way will be indirectly calculated (synchronized) over the transport speed.
	// If transport position changed from the parent (new value), synchronize the driven way 
	
	IF (dinTransportPositionOld_um <> SIf.Cur.dinTransportPosition_um) THEN
		dinDrivenWay_um := SIf.Cur.dinTransportPosition_um - SIf.Cur.dinTransportPositionCalc_um;
		SIf.Cur.dinTransportPositionCalc_um := SIf.Cur.dinTransportPosition_um;
		dinTransportPositionOld_um := SIf.Cur.dinTransportPosition_um;
		dinPositionCorrection_um := 0;
	ELSE
		// During the time, if there is no position change from the parent, calculate the driven way dependent the speed of transport.		
		// s = v * t
		dinDrivenWay_um := LREAL_TO_DINT(DINT_TO_LREAL(SIf.Cur.dinTransportspeed_um_s) * UDINT_TO_LREAL(me.FUBInfo.udiSample_ms) / 1000.0 );
		dinPositionCorrection_um := dinPositionCorrection_um + dinDrivenWay_um;
		SIf.Cur.dinTransportPositionCalc_um := dinTransportPositionOld_um + dinPositionCorrection_um;
	END_IF
	
	//----------------------------------------------------------------------
	// Update transport position and speed to childs 
	//----------------------------------------------------------------------
	FOR ii:=0 TO usiNumOfLines-1 BY 1 DO	
		a_pLineChildSIF[ii]^.Cur.dinTransportPosition_um := SIf.Cur.dinTransportPosition_um;
		a_pLineChildSIF[ii]^.Cur.dinTransportspeed_um_s := SIf.Cur.dinTransportspeed_um_s;
	END_FOR

END_IF

// ----------------------------------------------------------------------------------
// Always change actions in Base Library
// ----------------------------------------------------------------------------------
// overrule error always from base -> no EOFF State!! in EOFF go to OFF
IF (me.StateMachine.intStateNext = cSTA_EOFFBusy) THEN
	IF (me.StateMachine.intState=cSTA_OFF) THEN
		me.StateMachine.intStateNext := cSTA_OFF;
	ELSE // stay in OFF
		me.StateMachine.intStateNext := cSTA_OFFBusy;
	END_IF
END_IF

// Conditions Always
IF (((me.Alarm.eActivAlmClass=E_AlmClass.EOFF) OR (me.Alarm.eActivAlmClass=E_AlmClass.OFF) OR (me.intCmd=cCMD_OFF))
		 AND (me.StateMachine.intState<>cSTA_ERROR) AND (me.StateMachine.intState<>cSTA_ERRORQuit) AND
		(me.StateMachine.intState<>cSTA_OFF) AND (me.StateMachine.intState<>cSTA_OFFBusy)) THEN
	// alarm evt EOFF, OFF or cmd off
	me.StateMachine.intStateNext := cSTA_OFFBusy;
END_IF]]></ST>
      </Implementation>
      <ObjectProperties />
    </Method>
    <Method Name="CtrlInit" Id="{f48e1c2e-66ed-41a5-90a1-a4e9e6aadfe2}">
      <Declaration><![CDATA[METHOD PROTECTED CtrlInit : BOOL
VAR
	ii: INT;
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[SUPER^.CtrlInit();

//----------------------------------------------------------------------
// Initialize all lines
//----------------------------------------------------------------------

// Method initialize all line child controller.
FOR ii:=0 TO usiNumOfLines-1 BY 1 DO	
	a_pLineChildCIF[ii] := THIS^.AddChild(a_pLineChildCtrl[ii]^);
	a_pLineChildSIF[ii] := a_pLineChildCtrl[ii]^.getCtrlSIf();
	// Initialize access from STB to section buffer
	a_pLineChildSIF[ii]^.Cur.pSectionBuffer := ADR(a_stSectionBuffer[0]);
END_FOR

//----------------------------------------------------------------------
// Determine position of the last line (slide)
//----------------------------------------------------------------------
dinPositionOfLastLine_um:= a_pLineChildSIF[usiNumOfLines-1]^.Par.dinPositionOfSlide_um;]]></ST>
      </Implementation>
      <ObjectProperties />
    </Method>
    <ObjectProperties />
  </POU>
</TcPlcObject>