<TcPlcObject Version="1.1.0.1" ProductVersion="3.1.0.23">
  <POU Name="FB_HFE" Id="{86893e81-719c-4738-b9ce-9fed71641f32}">
    <Declaration><![CDATA[FUNCTION_BLOCK FB_HFE EXTENDS FB_CtrlBase
VAR_INPUT
	a_bolLDSNeedsHanger: ARRAY[0..cuintMaxStation] OF BOOL;
	a_intHFE_BufferZone: ARRAY[0..cuintMaxStation] OF INT;
	p_fbTlpDrive: POINTER TO FB_DRV;
	///p_fbJunction : POINTER TO FB_JUN;
	p_fbSLB: POINTER TO FB_SLB;
END_VAR
VAR
	/// List of pointers to Childs of VLV
	a_pMultiChildCtrl: ARRAY[0..Base_Const.cMaxNrOfChilds] OF POINTER TO FB_VLV;
	/// List of childs common interface
	a_pMultiChildCIF: ARRAY[0..Base_Const.cMaxNrOfChilds] OF POINTER TO T_Ctrl_CIf;
	/// List of childs specific interface for additional parameters or cur
	a_pMultiChildSIF: ARRAY[0..Base_Const.cMaxNrOfChilds] OF POINTER TO Base_Elements.T_Ctrl_SIf_VLV;
	usiNumOfMultiChild: USINT;
	usiNumOfValidPointerMultiChild: USINT;
	/// Specific interface struct for public access
	SIf: T_Ctrl_SIf_HFE;
	/// Child controller
	pTlpDrive_CIf: POINTER TO T_Ctrl_CIf;
	///pJunction_CIf : POINTER TO T_Ctrl_CIf;
	pSLB_CIf: POINTER TO T_Ctrl_CIf;
	pSLB_SIf: POINTER TO T_Ctrl_SIf_SLB;
	intSubState: ARRAY[0..cuintMaxStation] OF INT;
	udiTimeInStateRefill_ms: ARRAY[0..cuintMaxStation] OF UDINT;
END_VAR
VAR CONSTANT
	/// sub States
	cSTA_SUB_WaitForJob: INT := 500;
	cSTA_SUB_WaitOpen: INT := 502;
	cSTA_SUB_Open: INT := 504;
	cSTA_SUB_WaitClose: INT := 506;
	cSTA_SUB_Close: INT := 508;
END_VAR
]]></Declaration>
    <Implementation>
      <ST><![CDATA[(*__________________________________________________________________________________________________
¦	
¦	Vistaprint Schweiz GmbH
¦	CH - 8401 Winterthur
¦
¦	www.vistaprint.ch - info@vistaprint.ch
¦___________________________________________________________________________________________________

Function desription:
Cylinder implementation. 


History:
Version		Date			Author		Comment
---------------------------------------------------------------------------------------------------
0.00.1		02.07.2013		VP/RE		Start history
0.00.2		16.12.2013		AVME/MRU	In Always: No EOFF State!! in EOFF go to OFF

___________________________________________________________________________________________________*)



// check if child pointer valid
IF (me.bolActivate) AND (p_fbTlpDrive<>0)  AND (THIS^.checkChildPointer()) AND (p_fbSLB<>0) THEN // cyclic call enabled
	
	IF (CIf.Info.bolInitDone=FALSE) THEN // first cycle -> init
		CtrlInit();
		CIf.Info.bolInitDone := TRUE;
	ELSE
		CycleStartDuty();
	
		Always();
		
		StateMachine();
		
		CycleEndDuty();
	END_IF
	
END_IF;

]]></ST>
    </Implementation>
    <Method Name="checkChildPointer" Id="{2628831c-e252-490c-9419-ae88f6f74ad5}">
      <Declaration><![CDATA[METHOD PROTECTED checkChildPointer : BOOL
]]></Declaration>
      <Implementation>
        <ST><![CDATA[IF (usiNumOfMultiChild = usiNumOfValidPointerMultiChild) THEN
	checkChildPointer:= TRUE;
ELSE
	checkChildPointer:= FALSE;
END_IF

]]></ST>
      </Implementation>
    </Method>
    <Method Name="StateMachine" Id="{2785aa7e-8b1e-4b90-ab2a-ef8c705cc460}">
      <Declaration><![CDATA[METHOD PROTECTED StateMachine : BOOL
]]></Declaration>
      <Implementation>
        <ST><![CDATA[SUPER^.StateMachine();

// main statemachine of base controller
CASE me.StateMachine.intState OF
	 cSTA_RUN: 
        THIS^.sta_RUN();
	cSTA_RUNBusy:
        THIS^.sta_RUNBusy();
END_CASE;]]></ST>
      </Implementation>
    </Method>
    <Method Name="Always" Id="{38a63fb6-18ba-49bf-b019-0f3d98495c64}">
      <Declaration><![CDATA[METHOD PROTECTED Always : BOOL
]]></Declaration>
      <Implementation>
        <ST><![CDATA[SUPER^.Always();

IF (me.StateMachine.intState<>cSTA_SINGLE_ANSWER) THEN
	
	;
	
END_IF

// ----------------------------------------------------------------------------------
// Conditions Always
// overrule error always from base -> no EOFF State!! in EOFF go to OFF
IF (me.StateMachine.intStateNext = cSTA_EOFFBusy) THEN
	IF (me.StateMachine.intState=cSTA_OFF) THEN
		me.StateMachine.intStateNext := cSTA_OFF;
	ELSE // stay in OFF
		me.StateMachine.intStateNext := cSTA_OFFBusy;
	END_IF
END_IF
]]></ST>
      </Implementation>
    </Method>
    <Method Name="AddJunction" Id="{5540d54a-f506-4b0d-99c2-3c260241ccce}">
      <Declaration><![CDATA[METHOD AddJunction
VAR_INPUT
	p_MultiChild: POINTER TO FB_JUN;
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[
// Method add the pointer address of the buffer zone child controller to the array list.
IF (usiNumOfMultiChild <= (Base_Const.cMaxNrOfChilds-1)) THEN
	// Add buffer zone child controller to list
	a_pMultiChildCtrl[usiNumOfMultiChild] := p_MultiChild;
	// Inc. number of buffer zones
	usiNumOfMultiChild:= usiNumOfMultiChild+1;
	// Check if the pointer is valid
	IF (p_MultiChild<>0) THEN
		usiNumOfValidPointerMultiChild:= usiNumOfValidPointerMultiChild+1;
	END_IF
END_IF]]></ST>
      </Implementation>
    </Method>
    <Method Name="getCtrlSIf" Id="{5fc078fa-9c7e-42fa-bafa-cab6d54b3c09}">
      <Declaration><![CDATA[METHOD getCtrlSIf : POINTER TO T_Ctrl_SIf_HFE
]]></Declaration>
      <Implementation>
        <ST><![CDATA[getCtrlSIf := ADR(SIf);]]></ST>
      </Implementation>
    </Method>
    <Method Name="sta_OFF" Id="{6210d5a1-7a82-4e48-85c7-024e0dd57ae0}">
      <Declaration><![CDATA[METHOD PROTECTED sta_OFF : BOOL
]]></Declaration>
      <Implementation>
        <ST><![CDATA[// state implemetation
//--------------------------------------------------------------------------------------
// Entry action
	IF (me.StateMachine.intState<>me.StateMachine.intStateLastCycle) THEN
		me.StateMachine.intStateLastCycle := me.StateMachine.intState;
		
	END_IF


//--------------------------------------------------------------------------------------
// Cyclic action
	IF (me.StateMachine.intState=me.StateMachine.intStateLastCycle) THEN
		
		;
		
		// State Change Condition
		IF me.intCmd=cCMD_RUN THEN
			me.StateMachine.intStateNext :=  cSTA_RUNBusy;
		END_IF
	END_IF




//--------------------------------------------------------------------------------------
// Exit action
	IF (me.StateMachine.intState<>me.StateMachine.intStateNext) THEN
		;
	END_IF]]></ST>
      </Implementation>
    </Method>
    <Method Name="IoOutBridge" Id="{78be845b-6cb3-4729-99d3-ceb4ab98388e}">
      <Declaration><![CDATA[METHOD PROTECTED IoOutBridge : BOOL
VAR
	bolSwitchValvesOff: BOOL;
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[// digitale and analoge inputs read from hardware or forcing
IF (CIf.SwCfg.bolSimulation = FALSE) THEN
	//setOutBol(CIf.Job.bolIoForce ,ADR(SIf.Out.bolClamping));

	//THIS^.Out_Clamping := SIf.Out.bolClamping.map;
END_IF]]></ST>
      </Implementation>
    </Method>
    <Method Name="IoInBridge" Id="{87c349ad-3c09-4d5e-b5f7-9476c0ddfb4c}">
      <Declaration><![CDATA[METHOD PROTECTED IoInBridge : BOOL
]]></Declaration>
      <Implementation>
        <ST><![CDATA[// digitale and analoge inputs read from hardware or forcing
//SIf.In.bolGiveNextHangerSensor.map := THIS^.In_GiveNextHangerSensor;

IF (CIf.SwCfg.bolSimulation = FALSE) THEN
	//getInBol(CIf.Job.bolIoForce,ADR(SIf.In.bolGiveNextHangerSensor));
ELSE
	//simulation of global IO
END_IF
]]></ST>
      </Implementation>
    </Method>
    <Method Name="sta_RUNBusy" Id="{894533f3-8f3a-47da-891a-a7947aa13be9}">
      <Declaration><![CDATA[METHOD PROTECTED sta_RUNBusy : BOOL
]]></Declaration>
      <Implementation>
        <ST><![CDATA[// state implemetation
//--------------------------------------------------------------------------------------
// Entry action
	IF (me.StateMachine.intState<>me.StateMachine.intStateLastCycle) THEN
		me.StateMachine.intStateLastCycle := me.StateMachine.intState;
		
		pTlpDrive_CIf^.Job.intACmd := cCMD_RUN;
		pSLB_CIf^.Job.intACmd := Base_PLC.cCMD_RUN;
		
	END_IF


//--------------------------------------------------------------------------------------
// Cyclic action
	IF (me.StateMachine.intState=me.StateMachine.intStateLastCycle) THEN
		
		// State Change Condition
		IF (pTlpDrive_CIf^.Job.intState = cSTA_RUN) THEN
			me.StateMachine.intStateNext := cSTA_RUN;
		END_IF
	END_IF



//--------------------------------------------------------------------------------------
// Exit action
	IF (me.StateMachine.intState<>me.StateMachine.intStateNext) THEN
		;
	END_IF]]></ST>
      </Implementation>
    </Method>
    <Method Name="Refill" Id="{a70ee1c9-ddec-4fbe-9641-717811c70682}">
      <Declaration><![CDATA[METHOD Refill
VAR_INPUT
	intNbOfLDS: INT;
END_VAR
VAR
	/// Loop variable
	ii: INT;
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[// Simulation
fbSimulationTimer.PT := UDINT_TO_TIME(1000);
IF (CIf.SwCfg.bolSimulation) THEN
	// Cyclicle input into the top stopperbuffer
	fbSimulationTimer(); // set time/reset timer
	IF fbSimulationTimer.Q = TRUE THEN
		fbSimulationTimer.IN := FALSE;
	ELSE
		fbSimulationTimer.IN := TRUE;
	END_IF
			
END_IF

// Method refill 
CASE intSubState[intNbOfLDS] OF
	cSTA_SUB_WaitForJob: // LDS needs hanger
		IF (a_bolLDSNeedsHanger[intNbOfLDS]) THEN
//			IF (p_fbSLB^.CtrlCIf^.Info.p_aCIf[intNbOfLDS + 2]^.job.intState = 6) OR (p_fbSLB^.CtrlCIf^.Info.p_aCIf[intNbOfLDS + 2]^.job.intState = 12) THEN //	Just open if PreStopper is closed
			IF (p_fbSLB^.CtrlCIf^.Info.p_aCIf[a_intHFE_BufferZone[intNbOfLDS]]^.job.intState = 6) 
			OR (p_fbSLB^.CtrlCIf^.Info.p_aCIf[a_intHFE_BufferZone[intNbOfLDS]]^.job.intState = 12) THEN //	Just open if PreStopper is closed
				a_pMultiChildCIF[intNbOfLDS]^.Job.intACmd:= Base_Elements.VLV_CmdState.cCMD_OPEN;
				udiTimeInStateRefill_ms[intNbOfLDS] := 0;
				intSubState[intNbOfLDS] := cSTA_SUB_WaitOpen;
			END_IF
		END_IF
	
	cSTA_SUB_WaitOpen:	// Waiting time between STB closing and junction opening
		udiTimeInStateRefill_ms[intNbOfLDS]:= udiTimeInStateRefill_ms[intNbOfLDS] + me.FUBInfo.udiSample_ms;
		IF (udiTimeInStateRefill_ms[intNbOfLDS] > SIf.Par.udiWaitingTime_ms) THEN
			intSubState[intNbOfLDS] := cSTA_SUB_Open;
			udiTimeInStateRefill_ms[intNbOfLDS] := 0;			
		END_IF
		
	cSTA_SUB_Open:	
		udiTimeInStateRefill_ms[intNbOfLDS]:= udiTimeInStateRefill_ms[intNbOfLDS] + me.FUBInfo.udiSample_ms;
		IF ((Sif.Par.a_udiTimeOpen_ms[intNbOfLDS] <> 0) AND (Sif.Par.a_udiTimeOpen_ms[intNbOfLDS] < udiTimeInStateRefill_ms[intNbOfLDS])) OR 
		(a_bolLDSNeedsHanger[intNbOfLDS] = 0) THEN
			intSubState[intNbOfLDS] := cSTA_SUB_WaitClose;
		END_IF
		
	cSTA_SUB_WaitClose:	// Waiting time between STB closing and junction closing
//		IF (p_fbSLB^.CtrlCIf^.Info.p_aCIf[intNbOfLDS + 2]^.job.intState = 6) or (p_fbSLB^.CtrlCIf^.Info.p_aCIf[intNbOfLDS + 2]^.job.intState = 12) THEN //	Just close if PreStopper is closed
		IF (p_fbSLB^.CtrlCIf^.Info.p_aCIf[a_intHFE_BufferZone[intNbOfLDS]]^.job.intState = 6) 
		OR (p_fbSLB^.CtrlCIf^.Info.p_aCIf[a_intHFE_BufferZone[intNbOfLDS]]^.job.intState = 12) THEN //	Just close if PreStopper is closed

			udiTimeInStateRefill_ms[intNbOfLDS] := 0;
			intSubState[intNbOfLDS] := cSTA_SUB_Close;
		END_IF
		
	cSTA_SUB_Close:
		udiTimeInStateRefill_ms[intNbOfLDS]:= udiTimeInStateRefill_ms[intNbOfLDS] + me.FUBInfo.udiSample_ms;
		IF (udiTimeInStateRefill_ms[intNbOfLDS] > SIf.Par.udiWaitingTime_ms) THEN
			a_pMultiChildCIF[intNbOfLDS]^.Job.intACmd:= Base_Elements.VLV_CmdState.cCMD_Close;
			IF ((Sif.Par.a_udiTimeClose_ms[intNbOfLDS] < udiTimeInStateRefill_ms[intNbOfLDS])) THEN
				intSubState[intNbOfLDS] := cSTA_SUB_WaitForJob;
			END_IF
		END_IF
END_CASE
]]></ST>
      </Implementation>
    </Method>
    <Method Name="sta_RUN" Id="{c71e8941-26c5-4fe3-ba0e-2d2f1350a90d}">
      <Declaration><![CDATA[METHOD PROTECTED sta_RUN : BOOL
VAR
	intNbOfLDS: INT;
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[// state implemetation
//--------------------------------------------------------------------------------------
// Entry action
	IF (me.StateMachine.intState<>me.StateMachine.intStateLastCycle) THEN
		me.StateMachine.intStateLastCycle := me.StateMachine.intState;
		
		//fbSimulationTimer.IN := FALSE;
		//fbSimulationTimer.PT := UDINT_TO_TIME(SIf.Par.udi_pulseTimeout_ms/10);
		//fbSimulationTimer(); // set time/reset timer
		//fbSimulationTimer.IN := TRUE; // start timer
		FOR intNbOfLDS := 0 TO UINT_TO_INT(cuintMaxStation) DO
			intSubState[intNbOfLDS] := 500;	// Init Refill Substate
		END_FOR
	END_IF


//--------------------------------------------------------------------------------------
// Cyclic action
	IF (me.StateMachine.intState=me.StateMachine.intStateLastCycle) THEN
		
		// Simulation
		IF (CIf.SwCfg.bolSimulation) THEN
			//fbSimulationTimer(); // simulation time
			//IF (fbSimulationTimer.Q) THEN
			//	SIf.In.bolPulse.intern := NOT SIf.In.bolPulse.intern; // toggle pulse
			//	fbSimulationTimer.IN := FALSE;
			//ELSE
			//	fbSimulationTimer.IN := TRUE;
			//END_IF
		END_IF
		
		//IF NOT(pSLB_SIf^.Cur.bolBufferFull) THEN
		//	pStopperBuffer_CIf^.Job.intACmd := STB_CmdState.cCMD_RELEASE;
		//END_IF
		FOR intNbOfLDS := 0 TO UINT_TO_INT(cuintMaxStation) DO
			IF (SIf.Par.a_bolEnableJunction[intNbOfLDS]) AND (a_pMultiChildCtrl[intNbOfLDS]<>0) THEN
				Refill(intNbOfLDS);
			END_IF
			IF (INT_TO_UINT(intNbOfLDS) = (SIf.Cfg.uintNbOfLDS-1)) THEN // Last station = End of SLB, no VLV there
				IF (a_bolLDSNeedsHanger[intNbOfLDS]= TRUE) THEN
					IF (pSLB_SIf^.Cur.bolHangerDetected = TRUE) THEN // Just if Hanger is at Last STB
						pSLB_CIf^.Job.intACmd := SLB_CmdState.cCMD_RELEASE;	
					END_IF
				END_IF
			END_IF
		END_FOR
		
		// State Change Condition
		IF me.intCmd=cCMD_OFF THEN
			me.StateMachine.intStateNext := cSTA_OFFBusy;
		END_IF
		
	END_IF



//--------------------------------------------------------------------------------------
// Exit action
	IF (me.StateMachine.intState<>me.StateMachine.intStateNext) THEN
		;
	END_IF]]></ST>
      </Implementation>
    </Method>
    <Method Name="CtrlInit" Id="{e7c5b937-9ee0-4d79-b978-8457f8d90220}">
      <Declaration><![CDATA[METHOD PROTECTED CtrlInit : BOOL
VAR
	ii: INT;
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[SUPER^.CtrlInit();

// get child CIf
pTlpDrive_CIf := THIS^.AddChild(p_fbTlpDrive^);
pSLB_CIf := THIS^.AddChild(p_fbSLB^);
pSLB_SIf := p_fbSLB^.getCtrlSIf();

//initialize all multi Child controller.
FOR ii:=0 TO usiNumOfMultiChild-1 BY 1 DO	
	// Get child common if
	a_pMultiChildCIF[ii]:= THIS^.AddChild(a_pMultiChildCtrl[ii]^);	
	// Get specific interface for additional parmaeters or cur
	a_pMultiChildSIF[ii]:= a_pMultiChildCtrl[ii]^.getCtrlSIf();
END_FOR]]></ST>
      </Implementation>
    </Method>
    <Method Name="FB_init" Id="{fe94e761-66c6-4876-9312-76755a5c43ca}">
      <Declaration><![CDATA[METHOD FB_init : BOOL
VAR_INPUT
	///if TRUE, the retain variables are initialized (warm start / cold start)
	bInitRetains: BOOL;
	///if TRUE, the instance afterwards gets moved into the copy code (online change)
	bInCopyCode: BOOL;
END_VAR
VAR
	ii: UINT;
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[//------------------------------------------------------------------------------------------------------------------------
// to manually change in new FUB implementation!!!
// define valid commands for this controller
FOR ii:= 0 TO (SIZEOF(CIf.Job.aCmdList)/SIZEOF(CIf.Job.aCmdList[0])-1) BY 1 DO
	IF (CIf.Job.aCmdList[ii].intCmd=cCMD_INITIALIZED) THEN
		// found first empty array element
		EXIT;
	END_IF
END_FOR
CIf.Job.aCmdList[ii].intCmd := cCMD_RUN;
CIf.Job.aCmdList[ii].strName := 'Run'; 
CIf.Job.aCmdList[ii].bolAvailable := TRUE;
//ii := ii +1;
//CIf.Job.aCmdList[ii].intCmd := cCMD_RETRACT;
//CIf.Job.aCmdList[ii].strName := 'Retract';
//CIf.Job.aCmdList[ii].bolAvailable := TRUE;

// set name of class/typ
CIf.Info.strType := 'FB_HFE'; 

// set alarm class
//SIf.Alm[1].eAlmClass := E_AlmClass.TSTOP;
//SIf.Alm[1].strText := 'TLKV Motor does not move after timeout.'; 
//SIf.Alm[2].eAlmClass := E_AlmClass.STOP;
//SIf.Alm[2].strText := 'Emergency button pressed.'; 

//*******************************************************************************
// initial values
//*******************************************************************************

// software configuration
CIf.SwCfg.bolExist := TRUE;
CIf.SwCfg.bolSimulation := FALSE;

// parmeter
FOR ii:= 0 TO cuintMaxStation DO
	SIf.Par.a_udiTimeClose_ms[ii] := 10000;
	SIf.Par.a_udiTimeOpen_ms[ii] := 10000;
END_FOR
SIf.Par.udiWaitingTime_ms := 100;
SIf.Par.a_bolEnableJunction[0] := TRUE; // First LDS is enabled

// configuration
SIf.Cfg.uintNbOfLDS := 1;

// actual values
//SIf.Cur.dinCounter := 0;]]></ST>
      </Implementation>
    </Method>
    <ObjectProperties />
  </POU>
</TcPlcObject>