<TcPlcObject Version="1.1.0.1" ProductVersion="3.1.0.19">
  <POU Name="FB_HPS" Id="{e8ce3a42-d33f-4dad-92e2-86f764b9eca8}">
    <Declaration><![CDATA[FUNCTION_BLOCK FB_HPS EXTENDS FB_CtrlBase
VAR_INPUT
	/// Sensor Counter into the system
	In_bolCounterIn1: BOOL;
	In_bolCounterIn2: BOOL;
	/// Sensor Counter out of the system
	In_bolCounterOut1: BOOL;
	In_bolCounterOut2: BOOL;
	/// Signal to bring a T-Shirt directly (Line 1 without turning)
	In_bolBringShirtStraight: BOOL;
	/// Signal to bring a T-Shirt turned (Line 2 with hanger rotation unit)
	In_bolBringShirtTurned: BOOL;
	///pointer to function blocks Mergers
	p_fbSLB_S: POINTER TO FB_SLB;
	/// Slide buffer for turned T-Shirts
	p_fbSLB_T: POINTER TO FB_SLB;
	p_fbHRU: POINTER TO FB_HRU;
	p_fbSEP: POINTER TO FB_STB;
END_VAR
VAR_OUTPUT
	/// Interface to HeatPress without LineControl
	Out_ShirtStraightReady: BOOL;
	/// Shirt in SEP6 detected
	Out_ShirtTurnReady: BOOL;
END_VAR
VAR
	/// Specific interface struct for public access
	SIf: T_Ctrl_SIf_HPS;
	/// Interface to Childs
	pSLB_S_CIF: POINTER TO T_Ctrl_CIf;
	pSLB_T_CIF: POINTER TO T_Ctrl_CIf;
	pHRU_CIF: POINTER TO T_Ctrl_CIf;
	pSLB_S_SIF: POINTER TO T_Ctrl_SIf_SLB;
	pSLB_T_SIF: POINTER TO T_Ctrl_SIf_SLB;
	pHRU_SIF: POINTER TO T_Ctrl_SIf_HRU;
	pSLB_WORK_CIF: POINTER TO T_Ctrl_CIf;
	pSEP_CIF: POINTER TO T_Ctrl_CIf;
	pSEP_SIF: POINTER TO T_Ctrl_SIf_STB;
	/// Childs of Drives
	/// List of pointers to Childs
	a_pMultiChildCtrl: ARRAY[0..Base_Const.cMaxNrOfChilds] OF POINTER TO FB_DRV;
	/// List of childs common interface
	a_pMultiChildCIF: ARRAY[0..Base_Const.cMaxNrOfChilds] OF POINTER TO T_Ctrl_CIf;
	/// List of childs specific interface for additional parameters or cur
	a_pMultiChildSIF: ARRAY[0..Base_Const.cMaxNrOfChilds] OF POINTER TO T_Ctrl_SIf_DRV;
	usiNumOfMultiChild: USINT;
	usiNumOfValidPointerMultiChild: USINT;
	/// Function specific variables
	/// Rising Edge detection of Hanger Counter input
	bolRECounterIn1: BOOL;
	bolRECounterIn2: BOOL;
	/// Rising Edge detection of Hanger Counter output
	bolRECounterOut1: BOOL;
	bolRECounterOut2: BOOL;
	/// Loopvariable
	intI: INT;
	/// Index of Drive
	intDriveIndex: INT;
	/// Actual Line to charging
	usiLineAct: USINT;
	/// Charge Job
	aTblCharge: ARRAY[0..cintMaxCharge] OF INT;
	/// Datachannel
	/// Internal Variable Data Channel Variables
	intStatemachine: INT;
	/// Data not correct
	bolDataBad: BOOL;
	/// Data found
	bolDataFound: BOOL;
	/// Retry Counts for error message
	intCountRetry: INT;
	/// Datachannel to send done job
	fbDtChnToLine_ChargeDone: FB_DtChnToLine_ChargeDone;
	intDtChnToLineState: INT;
	/// Var. used for sub sequence refill
	intIndexRefill: INT;
	SubStateMachineRefill: INT;
	udiTimeInStateRefill_ms: UDINT;

END_VAR
VAR CONSTANT
	///sub States for RELEASE Function
	cSTA_SUB_INITIALIZED: INT := 500;
	cSTA_SUB_START_ELEMENTS: INT := 502;
	cSTA_SUB_START_CYCLE: INT := 504;
	cSTA_SUB_START_WAIT_CYCLE: INT := 506;
	cSTA_SUB_START_INLET: INT := 510;
	cSTA_SUB_START_FINAL: INT := 511;
	cSTA_SUB_STOP_INLET: INT := 512;
	cSTA_SUB_STOP_ELEMENTS: INT := 516;
	cSTA_SUB_STOP_CYCLE: INT := 518;
	cSTA_SUB_STOP_WAIT_CYCLE: INT := 520;
	cSTA_SUB_STOP_OUTLET: INT := 522;
	cSTA_SUB_STOP_FINAL: INT := 524;
	cSTA_SUB_RUN_WAIT_JOB: INT := 530;
	cSTA_SUB_RUN_SET_PAR: INT := 532;
	cSTA_SUB_RUN_SET_CMD: INT := 534;
	cSTA_SUB_RUN_WAIT_DONE: INT := 536;
	cSTA_SUB_RUN_SET_RELEASE: INT := 538;	// Step for SEP
	cSTA_SUB_RUN_WAIT_RELEASED: INT := 540;	// Step for SEP
	cSTA_SUB_RUN_UPDATE: INT := 542;
	cSTA_SUB_ERROR: INT := 598;
	cSTA_SUB_FINISHED: INT := 600;
END_VAR
]]></Declaration>
    <Implementation>
      <ST><![CDATA[(*__________________________________________________________________________________________________
¦	
¦	Vistaprint Schweiz GmbH
¦	CH - 8401 Winterthur
¦
¦	www.vistaprint.ch - info@vistaprint.ch
¦___________________________________________________________________________________________________

Function desription:
Heat Press Shirt Station
This controller brings T-Shirts separated to the Heat press over 2 Slides, 
one is directly, the other ower a Hanger rotation Unit to print the backside of the Shirt
Signal to bring the shirt is over digital Input or Data channel


History:
Version		Date			Author		Comment
---------------------------------------------------------------------------------------------------
0.00.1		12.09.2013		AVM/PRE		Start history
0.00.2		19.09.2013		AVME/PRE	Implement new Base Concept
0.00.3		24.09.2013		AVME/MRU	Changes in sta_RUN in SUB-States cSTA_SUB_RUN_WAIT_DONE / 
										cSTA_SUB_RUN_SET_CMD for Hanger Rotation Unit
										Error 'Excepted Hanger not in Rotation Unit' added
										Sensor Counter out of the system 2 added
0.00.4		03.10.2013		AVME/MRU	New Sensor SEP Hanger Detected added
										T_Ctrl_SIf_HPS_Out for Heatpress without LineControl added
										and calculated in RUN
0.00.5		11.12.2013		AVME/MRU	Add Methode checkChildAlmClass for Error Stop of childs
0.00.6		24.01.2014		AVME/MRU	Add SEP_7b

___________________________________________________________________________________________________*)


IF (me.bolActivate) AND (p_fbSLB_S<>0) AND (p_fbSLB_T<>0) AND (p_fbHRU<>0) AND (THIS^.checkChildPointer()) THEN // cyclic call enabled
	IF (CIf.Info.bolInitDone=FALSE) THEN // first cycle -> init
		CtrlInit();
		CIf.Info.bolInitDone := TRUE;
	ELSE
		CycleStartDuty();
	
		Always();
		
		StateMachine();
		
		CycleEndDuty();
	END_IF
END_IF;
]]></ST>
    </Implementation>
    <Method Name="AddDrive" Id="{45e7a34d-7744-48f4-9acb-0f5c8280dc28}">
      <Declaration><![CDATA[METHOD AddDrive
VAR_INPUT
	p_MultiChild: POINTER TO FB_DRV;
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[
// Method add the pointer address of the buffer zone child controller to the array list.
IF (usiNumOfMultiChild <= (Base_Const.cMaxNrOfChilds-1)) THEN
	// Add buffer zone child controller to list
	a_pMultiChildCtrl[usiNumOfMultiChild] := p_MultiChild;
	// Inc. number of buffer zones
	usiNumOfMultiChild:= usiNumOfMultiChild+1;
	// Check if the pointer is valid
	IF (p_MultiChild<>0) THEN
		usiNumOfValidPointerMultiChild:= usiNumOfValidPointerMultiChild+1;
	END_IF
END_IF]]></ST>
      </Implementation>
    </Method>
    <Method Name="getCtrlSIf" Id="{d707ba90-8a95-48e7-babb-3b57edc5edd9}">
      <Declaration><![CDATA[METHOD getCtrlSIf : POINTER TO T_Ctrl_SIf_HPS
]]></Declaration>
      <Implementation>
        <ST><![CDATA[getCtrlSIf := ADR(SIf);]]></ST>
      </Implementation>
    </Method>
    <Method Name="sta_RUNBusy" Id="{4bc833b2-54f1-4999-9dda-03412ffa2ed1}">
      <Declaration><![CDATA[METHOD PROTECTED sta_RUNBusy : BOOL
]]></Declaration>
      <Implementation>
        <ST><![CDATA[// state implemetation
//--------------------------------------------------------------------------------------
// Entry action
	IF (me.StateMachine.intState<>me.StateMachine.intStateLastCycle) THEN
		me.StateMachine.intStateLastCycle := me.StateMachine.intState;
		
		me.SubStateMachine.intState := cSTA_SUB_INITIALIZED; // init sub state machine
		me.SubStateMachine.intStateNext := cSTA_SUB_INITIALIZED; // init sub state machine
		
		fbSimulationTimer.IN := FALSE;
		fbSimulationTimer.PT := UDINT_TO_TIME(SIf.Par.udiTimeOutRead_ms);
		fbSimulationTimer(); // set time/reset timer
		fbSimulationTimer.IN := TRUE; // start timer
	END_IF


//--------------------------------------------------------------------------------------
// Cyclic action
	IF (me.StateMachine.intState=me.StateMachine.intStateLastCycle) THEN

		// Simulation
		IF (CIf.SwCfg.bolSimulation) THEN
			fbSimulationTimer(); // simulation time
			IF (fbSimulationTimer.Q) THEN
				;
			END_IF
		END_IF
		
		// Cyclicle action
		// Start Cycle with substates	
		//--------------------------------------------------------------------------------------
		// sub state machine for sequence
		CASE me.SubStateMachine.intState OF
			//--------------------------------------------------------------------------------------
			cSTA_SUB_INITIALIZED:
				me.SubStateMachine.intStateNext := cSTA_SUB_START_ELEMENTS;
				
			cSTA_SUB_START_ELEMENTS:
				// Start Slidbuffers
				pSLB_S_CIF^.Job.intACmd := cCMD_RUN;
				pSLB_T_CIF^.Job.intACmd := cCMD_RUN;
				// Start Hanger Rotation Unit
				// pHRU_CIF^.Job.intACmd := cCMD_RUN;	// In this state no RUN needed

				IF ((pSLB_S_CIF^.Job.intState = cSTA_RUN) AND (pSLB_T_CIF^.Job.intState = cSTA_RUN)
					 (*AND (pHRU_CIF^.Job.intState = cSTA_RUN)*)) THEN		// is not in RUN
					intDriveIndex := (usiNumOfMultiChild-1);
					me.SubStateMachine.intStateNext := cSTA_SUB_START_CYCLE;
				END_IF
					
			cSTA_SUB_START_CYCLE:
				//start all Buffers and Desicion Points
				a_pMultiChildCIF[intDriveIndex]^.Job.intACmd := cCMD_RUN;
				
				IF a_pMultiChildCIF[intDriveIndex]^.Job.intState = cSTA_RUN THEN
					me.SubStateMachine.intStateNext := cSTA_SUB_START_Wait_CYCLE;
				END_IF
				
			cSTA_SUB_START_Wait_CYCLE:								
				IF (me.SubStateMachine.udiTimeInState_ms >= SIf.Par.udiTimeDriveStart_ms) THEN
					IF intDriveIndex = 0 THEN
						me.SubStateMachine.intStateNext := cSTA_SUB_START_FINAL;
					ELSE
						intDriveIndex := intDriveIndex - 1;
						me.SubStateMachine.intStateNext := cSTA_SUB_START_CYCLE;
					END_IF
				END_IF
				
			cSTA_SUB_START_FINAL:
					me.SubStateMachine.intStateNext := cSTA_SUB_FINISHED;

		//--------------------------------------------------------------------------------------
			cSTA_SUB_FINISHED:
					;
					
		END_CASE
		me.SubStateMachine.intStateLastCycle := me.SubStateMachine.intState;
		CIf.Job.strSubState := THIS^.getCmdState(intCmdState:=me.SubStateMachine.intState,bolState:=TRUE);
		IF (me.SubStateMachine.intState<>me.SubStateMachine.intStateNext) THEN
			me.SubStateMachine.intState := me.SubStateMachine.intStateNext;  // set next state for next cycle
			me.SubStateMachine.udiTimeInState_ms := 0; // reset timer
			// log state change -> open point
		ELSE
			// increment time in state	
			me.SubStateMachine.udiTimeInState_ms := me.SubStateMachine.udiTimeInState_ms + me.FUBInfo.udiSample_ms;
		END_IF
		
		
		// State Change Condition
		IF (me.SubStateMachine.intState = cSTA_SUB_FINISHED) THEN
			me.StateMachine.intStateNext := cSTA_RUN;
		ELSIF (me.intCmd=cCMD_STOP) THEN
			me.StateMachine.intStateNext :=  cSTA_STOPBusy;	
		END_IF
	END_IF




//--------------------------------------------------------------------------------------
// Exit action
	IF (me.StateMachine.intState<>me.StateMachine.intStateNext) THEN
		;
	END_IF]]></ST>
      </Implementation>
    </Method>
    <Method Name="getCmdState" Id="{7d30c543-b248-4931-9792-14dd5417ceff}">
      <Declaration><![CDATA[METHOD PROTECTED getCmdState : STRING
VAR_INPUT
	intCmdState: INT;
	bolState: BOOL;
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[getCmdState := SUPER^.getCmdState(intCmdState:=intCmdState,bolState:=bolState); // get global/base defined cmds/states
IF (getCmdState='') THEN // global not defined get local
	// get string cmd/state string information in runtime
	IF (bolState=FALSE) THEN
		// cmd's
	ELSE
	
	// cmd's
		CASE intCmdState OF
				
			// SUB States
			cSTA_SUB_INITIALIZED:
				getCmdState := 'cSTA_SUB_INITIALIZED';
			cSTA_SUB_START_CYCLE:
				getCmdState := 'cSTA_SUB_START_CYCLE';
			cSTA_SUB_START_Wait_CYCLE:
				getCmdState := 'cSTA_SUB_START_Wait_CYCLE';
			cSTA_SUB_START_ELEMENTS:
				getCmdState := 'cSTA_SUB_START_ELEMENTS';
			cSTA_SUB_START_INLET:
				getCmdState := 'cSTA_SUB_START_INLET';
			cSTA_SUB_START_FINAL:
				getCmdState := 'cSTA_SUB_START_FINAL';
		
			cSTA_SUB_STOP_INLET:
				getCmdState := 'cSTA_SUB_STOP_INLET';
			cSTA_SUB_STOP_CYCLE:
				getCmdState := 'cSTA_SUB_STOP_CYCLE';
			cSTA_SUB_STOP_Wait_CYCLE:
				getCmdState := 'cSTA_SUB_STOP_Wait_CYCLE';
			cSTA_SUB_STOP_ELEMENTS:
				getCmdState := 'cSTA_SUB_STOP_ELEMENTS';
			cSTA_SUB_STOP_OUTLET:
				getCmdState := 'cSTA_SUB_STOPP_OUTLET';
			cSTA_SUB_ERROR:
				getCmdState := 'cSTA_SUB_ERROR';
			cSTA_SUB_FINISHED:
				getCmdState := 'cSTA_SUB_FINISHED';

			cSTA_SUB_RUN_WAIT_JOB:
				getCmdState := 'cSTA_SUB_RUN_WAIT_JOB';
			cSTA_SUB_RUN_SET_PAR:
				getCmdState := 'cSTA_SUB_RUN_SET_PAR';
			cSTA_SUB_RUN_SET_CMD:
				getCmdState := 'cSTA_SUB_RUN_SET_CMD';
			cSTA_SUB_RUN_WAIT_DONE:
				getCmdState := 'cSTA_SUB_RUN_WAIT_DONE';
			cSTA_SUB_RUN_UPDATE:
				getCmdState := 'cSTA_SUB_RUN_UPDATE';

		END_CASE;
	END_IF
END_IF
]]></ST>
      </Implementation>
    </Method>
    <Method Name="CtrlInit" Id="{f363fb42-29c7-43a4-bf7e-f7eb07b96de9}">
      <Declaration><![CDATA[METHOD PROTECTED CtrlInit : BOOL
VAR
	ii: INT;
	usiChildIndex: USINT;
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[SUPER^.CtrlInit();
// Add Childs
pSLB_S_CIf := THIS^.AddChild(p_fbSLB_S^);
pSLB_T_CIf := THIS^.AddChild(p_fbSLB_T^);
pHRU_CIf := THIS^.AddChild(p_fbHRU^);
pSEP_CIF := THIS^.AddChild(p_fbSEP^);

//initialize all multi Child controller.
FOR ii:=0 TO usiNumOfMultiChild-1 BY 1 DO	
	a_pMultiChildCIF[ii] := THIS^.AddChild(a_pMultiChildCtrl[ii]^);
	a_pMultiChildSIF[ii] := a_pMultiChildCtrl[ii]^.getCtrlSIf();		
END_FOR

pSLB_S_SIF := p_fbSLB_S^.getCtrlSIf();
pSLB_T_SIF := p_fbSLB_T^.getCtrlSIf();
pHRU_SIF := p_fbHRU^.getCtrlSIf();
pSEP_SIF := p_fbSEP^.getCtrlSIf();
]]></ST>
      </Implementation>
    </Method>
    <Method Name="Always" Id="{ebb7ab8c-fbf9-4bfb-8aae-b2aeef2bee7b}">
      <Declaration><![CDATA[METHOD PROTECTED Always : BOOL
]]></Declaration>
      <Implementation>
        <ST><![CDATA[IF (me.bolChangeBackToAUTO=TRUE) THEN // switch mode to automatic switch off controller
	//me.StateMachine.intStateNext := cSTA_OFFBusy;
	//me.bolChangeBackToAUTO := FALSE; // for cylinder no change to off when switch to automatic!!
END_IF

SUPER^.Always();

// ---------------------------------------------------------------------------------
// check child me and set parent alarm class
checkChildAlmClass();

// ----------------------------------------------------------------------------------
// cyclic actions outside of statemachine

// Count Hangers in Controller
// Hanger In
IF SIf.In.bolCounterIn1.intern = TRUE AND bolRECounterIn1 = FALSE THEN
	bolRECounterIn1 := TRUE;
	SIf.Cur.dinCurrentItemCount := SIf.Cur.dinCurrentItemCount + 1;
ELSIF SIf.In.bolCounterIn1.intern = FALSE THEN
	bolRECounterIn1 := FALSE;
END_IF
IF SIf.In.bolCounterIn2.intern = TRUE AND bolRECounterIn2 = FALSE THEN
	bolRECounterIn2 := TRUE;
	SIf.Cur.dinCurrentItemCount := SIf.Cur.dinCurrentItemCount + 1;
ELSIF SIf.In.bolCounterIn2.intern = FALSE THEN
	bolRECounterIn2 := FALSE;
END_IF
// Hanger Out
IF SIf.In.bolCounterOut1.intern = TRUE AND bolRECounterOut1 = FALSE THEN
	bolRECounterOut1 := TRUE;
	IF SIf.Cur.dinCurrentItemCount > 0 THEN
		SIf.Cur.dinCurrentItemCount := SIf.Cur.dinCurrentItemCount - 1;
	END_IF
ELSIF SIf.In.bolCounterOut1.intern = FALSE THEN
	bolRECounterOut1 := FALSE;
END_IF
IF SIf.In.bolCounterOut2.intern = TRUE AND bolRECounterOut2 = FALSE THEN
	bolRECounterOut2 := TRUE;
	IF SIf.Cur.dinCurrentItemCount > 0 THEN
		SIf.Cur.dinCurrentItemCount := SIf.Cur.dinCurrentItemCount - 1;
	END_IF
ELSIF SIf.In.bolCounterOut2.intern = FALSE THEN
	bolRECounterOut2 := FALSE;
END_IF

// Get Maximal Value of capacity
SIf.Cur.dinMaxCapacity := SIf.Cfg.dinMaxCapacity + pSLB_S_SIF^.Cur.dinMaxCapacity + pSLB_T_SIF^.Cur.dinMaxCapacity;

// ----------------------------------------------------------------------------------
// Always change actions in Base Library
// ----------------------------------------------------------------------------------
// overrule error always from base -> no EOFF State!! in EOFF go to OFF
IF (me.StateMachine.intStateNext = cSTA_EOFFBusy) THEN
	IF (me.StateMachine.intState=cSTA_OFF) THEN
		me.StateMachine.intStateNext := cSTA_OFF;
	ELSE // stay in OFF
		me.StateMachine.intStateNext := cSTA_OFFBusy;
	END_IF
END_IF

// Conditions Always
IF (((me.Alarm.eActivAlmClass=E_AlmClass.EOFF) OR (me.Alarm.eActivAlmClass=E_AlmClass.OFF) OR (me.intCmd=cCMD_OFF))
		 AND (me.StateMachine.intState<>cSTA_ERROR) AND (me.StateMachine.intState<>cSTA_ERRORQuit) AND
		(me.StateMachine.intState<>cSTA_OFF) AND (me.StateMachine.intState<>cSTA_OFFBusy)) THEN
	// alarm evt EOFF, OFF or cmd off
	me.StateMachine.intStateNext := cSTA_OFFBusy;
END_IF
]]></ST>
      </Implementation>
    </Method>
    <Method Name="sta_OFF" Id="{c6f54b67-19a0-4496-826f-47c20a34adc0}">
      <Declaration><![CDATA[METHOD PROTECTED sta_OFF : BOOL
]]></Declaration>
      <Implementation>
        <ST><![CDATA[// state implemetation
//--------------------------------------------------------------------------------------
// Entry action
	IF (me.StateMachine.intState<>me.StateMachine.intStateLastCycle) THEN
		me.StateMachine.intStateLastCycle := me.StateMachine.intState;
		
	END_IF


//--------------------------------------------------------------------------------------
// Cyclic action
	IF (me.StateMachine.intState=me.StateMachine.intStateLastCycle) THEN
		
		;
		
		
		// State Change Condition
		IF (me.intCmd=cCMD_RUN) THEN
			me.StateMachine.intStateNext :=  cSTA_RUNBusy;
		END_IF
	END_IF




//--------------------------------------------------------------------------------------
// Exit action
	IF (me.StateMachine.intState<>me.StateMachine.intStateNext) THEN
		;
	END_IF]]></ST>
      </Implementation>
    </Method>
    <Method Name="checkStateAllMultiChild" Id="{82221f82-60f4-4f4e-b828-7dae13488d80}">
      <Declaration><![CDATA[METHOD PROTECTED checkStateAllMultiChild : BOOL
VAR_INPUT
	cSTA: INT;
END_VAR
VAR
	ii: INT;
	usiNumOfCheckedChilds: USINT;
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[// Method check input state of all zones

//Init
checkStateAllMultiChild:= FALSE;
usiNumOfCheckedChilds:= 0;

// Loop over all childs
FOR ii:=0 TO usiNumOfMultiChild-1 BY 1 DO
	// Check state	
	IF (a_pMultiChildCIF[ii]^.Job.intState = cSTA) THEN
		usiNumOfCheckedChilds:= usiNumOfCheckedChilds+1;
	END_IF

END_FOR

// All states equal the input state
IF (usiNumOfCheckedChilds = usiNumOfMultiChild) THEN
	checkStateAllMultiChild:= TRUE;
END_IF]]></ST>
      </Implementation>
    </Method>
    <Method Name="IoInBridge" Id="{1809088e-e2d6-4dcb-b739-94b2af8ddf81}">
      <Declaration><![CDATA[METHOD PROTECTED IoInBridge : BOOL
]]></Declaration>
      <Implementation>
        <ST><![CDATA[// digitale and analoge inputs read from hardware or forcing
SIf.In.bolCounterIn1.map := THIS^.In_bolCounterIn1;
SIf.In.bolCounterIn2.map := THIS^.In_bolCounterIn2;
SIf.In.bolCounterOut1.map := THIS^.In_bolCounterOut1;
SIf.In.bolCounterOut2.map := THIS^.In_bolCounterOut2;
SIf.In.bolBringShirtStraight .map := THIS^.In_bolBringShirtStraight;
SIf.In.bolBringShirtTurned .map := THIS^.In_bolBringShirtTurned;

IF (CIf.SwCfg.bolSimulation = FALSE) THEN
	getInBol(CIf.Job.bolIoForce,ADR(SIf.In.bolCounterIn1));
	getInBol(CIf.Job.bolIoForce,ADR(SIf.In.bolCounterIn2));
	getInBol(CIf.Job.bolIoForce,ADR(SIf.In.bolCounterOut1));
	getInBol(CIf.Job.bolIoForce,ADR(SIf.In.bolCounterOut2));
	getInBol(CIf.Job.bolIoForce,ADR(SIf.In.bolBringShirtStraight));
	getInBol(CIf.Job.bolIoForce,ADR(SIf.In.bolBringShirtTurned));
ELSE
	//simulation of global IO
END_IF
]]></ST>
      </Implementation>
    </Method>
    <Method Name="IoOutBridge" Id="{acf1abad-1359-410d-80f6-c570387f24d1}">
      <Declaration><![CDATA[METHOD PROTECTED IoOutBridge : BOOL
]]></Declaration>
      <Implementation>
        <ST><![CDATA[// digitale and analoge inputs read from hardware or forcing
IF (CIf.SwCfg.bolSimulation = FALSE) THEN
	// check interlocks to prevent damages
	IF (CIf.Job.bolIlkOverwrite=FALSE) THEN
	
		;
	END_IF
	
	// Outputs for Interface to HeatPress without LineControl
	setOutBol(CIf.Job.bolIoForce ,ADR(SIf.Out.bolShirtStraightReady));
	setOutBol(CIf.Job.bolIoForce ,ADR(SIf.Out.bolShirtTurnReady));	
	THIS^.Out_ShirtStraightReady := SIf.Out.bolShirtStraightReady.map;
	THIS^.Out_ShirtTurnReady := SIf.Out.bolShirtTurnReady.map;
	
END_IF]]></ST>
      </Implementation>
    </Method>
    <Method Name="checkChildPointer" Id="{e561d79e-db85-4410-8df7-c8096985ffca}">
      <Declaration><![CDATA[METHOD PROTECTED checkChildPointer : BOOL
]]></Declaration>
      <Implementation>
        <ST><![CDATA[IF (usiNumOfMultiChild = usiNumOfValidPointerMultiChild) THEN
	checkChildPointer:= TRUE;
ELSE
	checkChildPointer:= FALSE;
END_IF

]]></ST>
      </Implementation>
    </Method>
    <Method Name="StateMachine" Id="{aca7619f-5d95-41b2-8b79-d7ce8a9d6f47}">
      <Declaration><![CDATA[METHOD PROTECTED StateMachine : BOOL
]]></Declaration>
      <Implementation>
        <ST><![CDATA[SUPER^.StateMachine();

// main statemachine of base controller
CASE me.StateMachine.intState OF
    cSTA_RUNBusy: 
        THIS^.sta_RUNBusy();
    cSTA_RUN: 
        THIS^.sta_RUN();
    cSTA_STOPBusy: 
        THIS^.sta_STOPBusy();
    cSTA_STOP: 
        THIS^.sta_STOP();
		
END_CASE;]]></ST>
      </Implementation>
    </Method>
    <Method Name="sta_STOPBusy" Id="{6d6aaca4-9d3d-410e-9e06-9a5d0db99766}">
      <Declaration><![CDATA[METHOD PROTECTED sta_STOPBusy : BOOL
]]></Declaration>
      <Implementation>
        <ST><![CDATA[// state implemetation
//--------------------------------------------------------------------------------------
// Entry action
	IF (me.StateMachine.intState<>me.StateMachine.intStateLastCycle) THEN
		me.StateMachine.intStateLastCycle := me.StateMachine.intState;
		
		me.SubStateMachine.intState := cSTA_SUB_INITIALIZED; // init sub state machine
		me.SubStateMachine.intStateNext := cSTA_SUB_INITIALIZED; // init sub state machine
		
		fbSimulationTimer.IN := FALSE;
		fbSimulationTimer.PT := UDINT_TO_TIME(SIf.Par.udiTimeOutRead_ms);
		fbSimulationTimer(); // set time/reset timer
		fbSimulationTimer.IN := TRUE; // start timer
	END_IF


//--------------------------------------------------------------------------------------
// Cyclic action
	IF (me.StateMachine.intState=me.StateMachine.intStateLastCycle) THEN

		// Simulation
		IF (CIf.SwCfg.bolSimulation) THEN
			fbSimulationTimer(); // simulation time
			IF (fbSimulationTimer.Q) THEN
				;
			END_IF
		END_IF
		
		// Cyclicle action
		// Stop Cycle with substates	
		//--------------------------------------------------------------------------------------
		// sub state machine for sequence
		CASE me.SubStateMachine.intState OF
			//--------------------------------------------------------------------------------------
			cSTA_SUB_INITIALIZED:
				me.SubStateMachine.intStateNext := cSTA_SUB_STOP_ELEMENTS;
										
			cSTA_SUB_STOP_ELEMENTS: 
				// Stopp Slidebuffers
				pSLB_S_CIF^.Job.intACmd := cCMD_STOP;
				pSLB_T_CIF^.Job.intACmd := cCMD_STOP;
				IF ((pSLB_S_CIF^.Job.intState = cSTA_STOP) AND (pSLB_S_CIF^.Job.intState = cSTA_STOP)) THEN
					me.SubStateMachine.intStateNext := cSTA_SUB_STOP_CYCLE;
					intDriveIndex := 0;
				END_IF

			cSTA_SUB_STOP_CYCLE:
				//start all Buffers and Desicion Points
				a_pMultiChildCIF[intDriveIndex]^.Job.intACmd := cCMD_OFF;
				
				IF a_pMultiChildCIF[intDriveIndex]^.Job.intState = cSTA_OFF THEN
					me.SubStateMachine.intStateNext := cSTA_SUB_STOP_Wait_CYCLE;
				END_IF
				
			cSTA_SUB_STOP_Wait_CYCLE:								
				IF (me.SubStateMachine.udiTimeInState_ms >= SIf.Par.udiTimeDriveStart_ms) THEN
					IF intDriveIndex >= (usiNumOfMultiChild-1) THEN
						me.SubStateMachine.intStateNext := cSTA_SUB_STOP_OUTLET;
					ELSE
						intDriveIndex := intDriveIndex + 1;
						me.SubStateMachine.intStateNext := cSTA_SUB_STOP_CYCLE;
					END_IF
				END_IF
			
			cSTA_SUB_STOP_OUTLET:	
				// Stopp Hanger Rotation Unit
				pHRU_CIF^.Job.intACmd := cCMD_OFF;
				IF (pHRU_CIF^.Job.intState = cSTA_OFF) THEN
					me.SubStateMachine.intStateNext := cSTA_SUB_FINISHED;
				END_IF

		
			
			//--------------------------------------------------------------------------------------
			cSTA_SUB_FINISHED:
					;
					
		END_CASE
		me.SubStateMachine.intStateLastCycle := me.SubStateMachine.intState;
		CIf.Job.strSubState := THIS^.getCmdState(intCmdState:=me.SubStateMachine.intState,bolState:=TRUE);
		IF (me.SubStateMachine.intState<>me.SubStateMachine.intStateNext) THEN
			me.SubStateMachine.intState := me.SubStateMachine.intStateNext;  // set next state for next cycle
			me.SubStateMachine.udiTimeInState_ms := 0; // reset timer
			// log state change -> open point
		ELSE
			// increment time in state	
			me.SubStateMachine.udiTimeInState_ms := me.SubStateMachine.udiTimeInState_ms + me.FUBInfo.udiSample_ms;
		END_IF
		
		
		// State Change Condition
		IF (me.SubStateMachine.intState = cSTA_SUB_FINISHED) THEN
			me.StateMachine.intStateNext := cSTA_STOP;
		ELSIF (me.intCmd=cCMD_RUN) THEN
			me.StateMachine.intStateNext :=  cSTA_RUNBusy;	
		END_IF
	END_IF




//--------------------------------------------------------------------------------------
// Exit action
	IF (me.StateMachine.intState<>me.StateMachine.intStateNext) THEN
		;
	END_IF]]></ST>
      </Implementation>
    </Method>
    <Method Name="CmdToAllMultiChild" Id="{bf626568-3771-4c0a-97fe-3955ffda1c91}">
      <Declaration><![CDATA[METHOD PROTECTED CmdToAllMultiChild
VAR_INPUT
	cCMD: INT;
END_VAR
VAR
	ii: INT;
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[// Method send input command to all existing multi child controller.
FOR ii:=0 TO usiNumOfMultiChild-1 BY 1 DO	
	a_pMultiChildCIF[ii]^.Job.intACmd:= cCMD;
END_FOR


]]></ST>
      </Implementation>
    </Method>
    <Method Name="FB_init" Id="{d145926a-f6db-42ad-9128-3552f475355e}">
      <Declaration><![CDATA[METHOD FB_init : BOOL
VAR_INPUT
	///if TRUE, the retain variables are initialized (warm start / cold start)
	bInitRetains: BOOL;
	///if TRUE, the instance afterwards gets moved into the copy code (online change)
	bInCopyCode: BOOL;
END_VAR
VAR
	udiTaskCnt: UDINT;
	ii: UINT;
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[//------------------------------------------------------------------------------------------------------------------------
// to manually change in new FUB implementation!!!
// define valid commands for this controller
FOR ii:= 0 TO (SIZEOF(CIf.Job.aCmdList)/SIZEOF(CIf.Job.aCmdList[0])-1) BY 1 DO
	IF (CIf.Job.aCmdList[ii].intCmd=cCMD_INITIALIZED) THEN
		// found first empty array element
		EXIT;
	END_IF
END_FOR
CIf.Job.aCmdList[ii].intCmd := cCMD_RUN;
CIf.Job.aCmdList[ii].strName := 'Run'; 
CIf.Job.aCmdList[ii].bolAvailable := TRUE;
ii := ii +1;
CIf.Job.aCmdList[ii].intCmd := cCMD_STOP;
CIf.Job.aCmdList[ii].strName := 'Stop'; 
CIf.Job.aCmdList[ii].bolAvailable := TRUE;
ii := ii +1;


// set name of class/typ
CIf.Info.strType := 'FB_HPS'; 

// set alarm class
SIf.Alm[1].eAlmClass := E_AlmClass.EOFF;
SIf.Alm[1].strText := 'Communication Error to Line Controller'; 
SIf.Alm[2].eAlmClass := E_AlmClass.EOFF;
SIf.Alm[2].strText := 'Emergency Button pressed';
SIf.Alm[3].eAlmClass := E_AlmClass.INFO;
SIf.Alm[3].strText := 'Communication Error to Line Controller'; 
SIf.Alm[4].eAlmClass := E_AlmClass.INFO;
SIf.Alm[4].strText := 'Line to charge already busy, Job not possible';
SIf.Alm[5].eAlmClass := E_AlmClass.INFO;
SIf.Alm[5].strText := 'False Job Parameter';
SIf.Alm[6].eAlmClass := E_AlmClass.INFO;
SIf.Alm[6].strText := 'Hashtable full, no more input possible';
SIf.Alm[7].eAlmClass := E_AlmClass.INFO;
SIf.Alm[7].strText := 'Data Channel Error Receive Data';
SIf.Alm[8].eAlmClass := E_AlmClass.INFO;
SIf.Alm[8].strText := 'Data Channel Error Send Data';

//*******************************************************************************
// initial values
//*******************************************************************************
// software configuration
CIf.SwCfg.bolExist := TRUE;
CIf.SwCfg.bolSimulation := FALSE;

// Configuration
SIf.Cfg.bolDtChToLine_send := TRUE;

// parmeter
SIf.Par.udiTimeDriveStart_ms := 2000;
SIf.Par.udiTimeDriveStop_ms := 500;
SIf.Par.udiIntervalBufferFilling_ms:= 2000;
]]></ST>
      </Implementation>
    </Method>
    <Method Name="DtChnToPLC_NewCharge" Id="{750a454f-0d91-4157-b2f0-a81033fbce2f}">
      <Declaration><![CDATA[METHOD DtChnToPLC_NewCharge : BOOL
VAR
	ii: INT;
END_VAR
VAR CONSTANT
	cSTA_SUB_Data_Init: INT := 900;
	cSTA_SUB_Data_WaitForJob: INT := 902;
	cSTA_SUB_Data_CheckData: INT := 904;
	cSTA_SUB_Data_Acknowledge: INT := 906;
	cSTA_SUB_Data_Retry: INT := 908;
	cSTA_SUB_Data_Error: INT := 910;
	cDataState_DONE: INT := -1;
	cDataState_Ready: INT := 1;
	cDataState_Retry: INT := -99;
	cDataState_Error: INT := -100;
	cMAX_RETRY: INT := 10;
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[// Data Channel to Receive Data from Line Controller
// Startup check States
IF intStatemachine < cSTA_SUB_Data_Init THEN
	intStatemachine := cSTA_SUB_Data_Init;
END_IF

CASE intStatemachine OF
	cSTA_SUB_Data_Init:
		IF CIf.Job.intState > cSTA_PON THEN
			intCountRetry := 0;
			SIf.DtChnToPLC.stNewCharge.intDataState := cDataState_DONE;
			intStatemachine := cSTA_SUB_Data_WaitForJob;
		END_IF
		
	cSTA_SUB_Data_WaitForJob:
		// New data arrived
		IF SIf.DtChnToPLC.stNewCharge.intDataState = cDataState_Ready THEN
			bolDataBad := FALSE;
			intStatemachine := cSTA_SUB_Data_CheckData;
		END_IF
	
	cSTA_SUB_Data_CheckData:	
		// Check Data
		IF SIf.DtChnToPLC.stNewCharge.intLine <= 0 THEN
				bolDataBad := TRUE;
				// Set Alarm: SIf.Alm[5].strText := 'False Job Parameter';
				pfbAlarmCtrl^.setAlarm(CIf.Info.intCtrlId,5,0,ADR(SIf.Alm),E_AlmState.RST,CIf.Job.eMe_ActivAlmClass);					
		END_IF 
		
		CASE SIf.DtChnToPLC.stNewCharge.intJob OF
			/////////////////////////////////////////////////////
			// Insert new desiction item
			/////////////////////////////////////////////////////							
			E_DtChnJob.NEW:
				// Set new charge Job
				bolDataFound := FALSE;
				FOR ii := 0 TO cintMaxCharge DO
					IF aTblCharge[ii] = SIf.DtChnToPLC.stNewCharge.intLine THEN
						// Set Alarm: SIf.Alm[4].strText := 'Line to charge already busy, Job not possible';
						pfbAlarmCtrl^.setAlarm(CIf.Info.intCtrlId,4,ii,ADR(SIf.Alm),E_AlmState.RST,CIf.Job.eMe_ActivAlmClass);
						bolDataBad := TRUE;	
						EXIT;					
					ELSIF aTblCharge[ii] = 0 THEN
						aTblCharge[ii] := SIf.DtChnToPLC.stNewCharge.intLine;
						bolDataFound := TRUE;
						EXIT;
					END_IF
				END_FOR
				
				IF ((bolDataFound = FALSE) AND (bolDataBad = FALSE)) THEN
					// Set Alarm: SIf.Alm[6].strText := 'Hashtable full, no more input possible';
					pfbAlarmCtrl^.setAlarm(CIf.Info.intCtrlId,6,0,ADR(SIf.Alm),E_AlmState.RST,CIf.Job.eMe_ActivAlmClass);
					bolDataBad := TRUE;						
				END_IF

			/////////////////////////////////////////////////////
			// Delete ID
			/////////////////////////////////////////////////////			
			E_DtChnJob.DELETE_ID:
				// Init value
				bolDataFound := FALSE;
				// Check if Line not allready exist
				// Do not delete the active one index 0
				FOR ii := 1 TO cintMaxCharge DO
					IF aTblCharge[ii] = SIf.DtChnToPLC.stNewCharge.intLine THEN
						aTblCharge[ii] := 0;
						bolDataFound := TRUE;					
					END_IF
					IF ((bolDataFound = TRUE) AND (ii < cintMaxCharge)) THEN
						aTblCharge[ii] := aTblCharge[ii+1];
					ELSIF ((bolDataFound = TRUE) AND (ii = cintMaxCharge)) THEN
						aTblCharge[ii] := 0;						
					END_IF
				END_FOR
								
			/////////////////////////////////////////////////////
			// Delete Junction
			/////////////////////////////////////////////////////			
			E_DtChnJob.DELETE_JUNCTION:
				// Init value
				bolDataFound := FALSE;
				// Check if Line not allready exist
				// Do not delete the active one index 0
				FOR ii := 1 TO cintMaxCharge DO
					IF aTblCharge[ii] = SIf.DtChnToPLC.stNewCharge.intLine THEN
						aTblCharge[ii] := 0;
						bolDataFound := TRUE;					
					END_IF
					IF ((bolDataFound = TRUE) AND (ii < cintMaxCharge)) THEN
						aTblCharge[ii] := aTblCharge[ii+1];
					ELSIF ((bolDataFound = TRUE) AND (ii = cintMaxCharge)) THEN
						aTblCharge[ii] := 0;						
					END_IF
				END_FOR

			/////////////////////////////////////////////////////
			// Delete ALL
			/////////////////////////////////////////////////////			
			E_DtChnJob.DELETE_ALL:
				// Check if RF ID not allready exist
				FOR ii := 0 TO cintMaxCharge DO
					aTblCharge[ii] := 0;					
				END_FOR
				intStatemachine := cSTA_SUB_Data_Acknowledge;
		ELSE
			bolDataBad := TRUE;
			// Set Alarm: SIf.Alm[5].strText := 'False Job Parameter';
			pfbAlarmCtrl^.setAlarm(CIf.Info.intCtrlId,5,0,ADR(SIf.Alm),E_AlmState.RST,CIf.Job.eMe_ActivAlmClass);					
		END_CASE

		IF bolDataBad = TRUE THEN
			IF intCountRetry >= cMAX_RETRY THEN
				intStatemachine := cSTA_SUB_Data_Error;
			ELSE
				intCountRetry := intCountRetry + 1;
				intStatemachine := cSTA_SUB_Data_Retry;
			END_IF	
		ELSE
			intStatemachine := cSTA_SUB_Data_Acknowledge;
		END_IF
		
		
	cSTA_SUB_Data_Acknowledge:	
		// Delete all values
		SIf.DtChnToPLC.stNewCharge.intLine := 0;
		SIf.DtChnToPLC.stNewCharge.intJob := 0;
		// Acknowledge communication
		SIf.DtChnToPLC.stNewCharge.intDataState := cDataState_DONE;
		intStatemachine := cSTA_SUB_Data_WaitForJob;
		
	cSTA_SUB_Data_Retry:
		SIf.DtChnToPLC.stNewCharge.intDataState := cDataState_Retry;
		intStatemachine := cSTA_SUB_Data_WaitForJob;

	cSTA_SUB_Data_Error:
		SIf.DtChnToPLC.stNewCharge.intDataState := cDataState_Error;
		// Set Alarm: SIf.Alm[7].strText := 'Data Channel Error Receive Data';
		pfbAlarmCtrl^.setAlarm(CIf.Info.intCtrlId,7,0,ADR(SIf.Alm),E_AlmState.RST,CIf.Job.eMe_ActivAlmClass);										
		IF CIf.Job.bolAlmReset = TRUE THEN
			intStatemachine := cSTA_SUB_Data_Init;
		END_IF
			
END_CASE]]></ST>
      </Implementation>
    </Method>
    <Method Name="sta_STOP" Id="{68fbada5-fbd3-4f73-85cc-f094c63d9052}">
      <Declaration><![CDATA[METHOD PROTECTED sta_STOP : BOOL
]]></Declaration>
      <Implementation>
        <ST><![CDATA[// state implemetation
//--------------------------------------------------------------------------------------
// Entry action
	IF (me.StateMachine.intState<>me.StateMachine.intStateLastCycle) THEN
		me.StateMachine.intStateLastCycle := me.StateMachine.intState;
		
	END_IF


//--------------------------------------------------------------------------------------
// Cyclic action
	IF (me.StateMachine.intState=me.StateMachine.intStateLastCycle) THEN
		
		;
		
		
		// State Change Condition
		IF (me.intCmd=cCMD_RUN) THEN
			me.StateMachine.intStateNext :=  cSTA_RUNBusy;
		END_IF
	END_IF




//--------------------------------------------------------------------------------------
// Exit action
	IF (me.StateMachine.intState<>me.StateMachine.intStateNext) THEN
		;
	END_IF]]></ST>
      </Implementation>
    </Method>
    <Method Name="sta_RUN" Id="{3ba87d9f-ca05-421c-a76f-35355223a41d}">
      <Declaration><![CDATA[METHOD PROTECTED sta_RUN : BOOL
]]></Declaration>
      <Implementation>
        <ST><![CDATA[// state implemetation
//--------------------------------------------------------------------------------------
// Entry action
	IF (me.StateMachine.intState<>me.StateMachine.intStateLastCycle) THEN
		me.StateMachine.intStateLastCycle := me.StateMachine.intState;
		
		me.SubStateMachine.intState := cSTA_SUB_RUN_WAIT_JOB; // init sub state machine
		me.SubStateMachine.intStateNext := cSTA_SUB_RUN_WAIT_JOB; // init sub state machine

	END_IF


//--------------------------------------------------------------------------------------
// Cyclic action
	IF (me.StateMachine.intState=me.StateMachine.intStateLastCycle) THEN

		// Simulation
		IF (CIf.SwCfg.bolSimulation) THEN
			;
		END_IF

		// Get emptying command from Line with Data Channel
		// Communication to the Line Controll over Data Channel
		THIS^.DtChnToPLC_NewCharge();
		fbDtChnToLine_ChargeDone.bolResetError := CIf.Job.bolAlmReset;
		fbDtChnToLine_ChargeDone.pSIf := ADR(SIf);
		fbDtChnToLine_ChargeDone();
		IF fbDtChnToLine_ChargeDone.intError <> 0 THEN
			// Set Alarm: SIf.Alm[8].strText := 'Data Channel Error Send Data';
			pfbAlarmCtrl^.setAlarm(CIf.Info.intCtrlId,8,fbDtChnToLine_ChargeDone.intError,ADR(SIf.Alm),E_AlmState.RST,CIf.Job.eMe_ActivAlmClass);	
		END_IF
		
		// Start Cycle with substates	
		//--------------------------------------------------------------------------------------
		// sub state machine for sequence
		CASE me.SubStateMachine.intState OF
			//--------------------------------------------------------------------------------------
			cSTA_SUB_RUN_WAIT_JOB:
				// Job set by digital input or with Datachannel from Line Controller
				IF (aTblCharge[0] > 0) OR SIf.In.bolBringShirtStraight.intern OR SIf.In.bolBringShirtTurned.intern THEN
					me.SubStateMachine.intStateNext := cSTA_SUB_RUN_SET_CMD;
				END_IF
				
				// Interface to HeatPress without LineControl
				SIf.Out.bolShirtStraightReady.intern := pSLB_S_SIF^.Cur.bolHangerDetected; 	// Sensor SEP7 has Hanger detected
				SIf.Out.bolShirtTurnReady.intern := pSEP_SIF^.Cur.bolHangerDetected; // pSLB_T_SIF^.Cur.bolHangerDetected;		// Sensor SEP6 has Hanger detected
				
			cSTA_SUB_RUN_SET_CMD:
				// Digital Input has priority to the data channel
				// get the correct Common interface to set the RELEASE Command
				IF (SIf.In.bolBringShirtStraight.intern = TRUE) THEN
					pSLB_WORK_CIF := pSLB_S_CIF;
				ELSIF (SIf.In.bolBringShirtTurned.intern = TRUE) THEN
					pSLB_WORK_CIF := pSEP_CIF; //pSLB_T_CIF;
				ELSIF (aTblCharge[0] = 1) THEN
					// If job from Datachannel, save the line number
					usiLineAct := INT_TO_USINT(aTblCharge[0]);
					pSLB_WORK_CIF := pSLB_S_CIF;
				ELSIF (aTblCharge[0] = 2) THEN
					// If job from Datachannel, save the line number
					usiLineAct := INT_TO_USINT(aTblCharge[0]);
					pSLB_WORK_CIF := pSEP_CIF; //pSLB_T_CIF;
				END_IF
				
				// Send Release command to the correct job interface to release one hanger 
				pSLB_WORK_CIF^.Job.intACmd := STB_CmdState.cCMD_RELEASE;				
(*				// Send Run command to HRU if Shirt is in Turn Line
				IF (pSLB_WORK_CIF^.Info.intCtrlId = pSLB_T_CIF^.Info.intCtrlId) THEN	// Check if Shirt is in Turn Line
					pHRU_CIF^.Job.intACmd := cCMD_RUN;									// Send Command Run to HRU
				END_IF
*)		
				// Interface to HeatPress without LineControl
				SIf.Out.bolShirtStraightReady.intern := FALSE; 	// Not Ready
				SIf.Out.bolShirtTurnReady.intern := FALSE;		// Not Ready
				
				me.SubStateMachine.intStateNext := cSTA_SUB_RUN_WAIT_DONE;
			
			cSTA_SUB_RUN_WAIT_DONE:
				IF (pSLB_WORK_CIF^.Job.intACmd = cSTA_DONE) THEN
					IF (pSLB_WORK_CIF^.Info.intCtrlId = pSEP_CIF^.Info.intCtrlId) THEN		// Check if Shirt is in Turn Line
						pSLB_WORK_CIF^.Job.intACmd := BASE_PLC.cCMD_STOP;
(*						IF (pHRU_CIf^.Job.intACmd = cSTA_DONE) THEN							// Hanger Rotation Unit done
							me.SubStateMachine.intStateNext := cSTA_SUB_RUN_SET_RELEASE;
						ELSIF (pHRU_CIf^.Job.intState = cSTA_ERROR) THEN					// Hanger Rotation Unit failed
							me.SubStateMachine.intStateNext := cSTA_SUB_ERROR;
						END_IF
					ELSE																	// Straight Line -> no HRU check required
*)					END_IF
					me.SubStateMachine.intStateNext := cSTA_SUB_RUN_UPDATE;
				END_IF
				
(*			cSTA_SUB_RUN_SET_RELEASE:		// SEP between HRU and SLS
				IF (pSEP_SIF^.Cur.bolHangerDetected = TRUE) THEN
					pSEP_CIF^.Job.intACmd := STB_CmdState.cCMD_RELEASE;
					me.SubStateMachine.intStateNext := cSTA_SUB_RUN_WAIT_RELEASED;
				END_IF
				
			cSTA_SUB_RUN_WAIT_RELEASED:		// SEP between HRU and SLS
				IF (pSEP_CIF^.Job.intACmd = BASE_PLC.cSTA_DONE) THEN
					me.SubStateMachine.intStateNext := cSTA_SUB_RUN_UPDATE;
					pSEP_CIF^.Job.intACmd := BASE_PLC.cCMD_STOP;
				END_IF
*)				
			cSTA_SUB_RUN_UPDATE:
				// only delete the table if the job was from the table
				IF 	usiLineAct = INT_TO_USINT(aTblCharge[0]) THEN
					FOR intI := 0 TO (cintMaxCharge-1) DO
						aTblCharge[intI] := aTblCharge[intI+1];
					END_FOR
					aTblCharge[cintMaxCharge-1] := 0;
				END_IF
				usiLineAct := 0;
				
				// Send a message over Datachannel to the linecontroler
				IF (SIf.Cfg.bolDtChToLine_send = TRUE) THEN	
					intDtChnToLineState	:= fbDtChnToLine_ChargeDone.Creat(In_intLine := USINT_TO_INT(usiLineAct));
					IF  intDtChnToLineState < 0 THEN
						// SIf.Alm[8].strText := 'Data Channel Error Send Data';
						pfbAlarmCtrl^.setAlarm(CIf.Info.intCtrlId,8,intDtChnToLineState,ADR(SIf.Alm),E_AlmState.RST,CIf.Job.eMe_ActivAlmClass);
					END_IF
				END_IF
				
				me.SubStateMachine.intStateNext := cSTA_SUB_RUN_WAIT_JOB;
				
			cSTA_SUB_ERROR:
				; // Do nothing
					
		END_CASE
		
		//----------------------------------------------------------------------
		// Continuous refill of last SEP
		//----------------------------------------------------------------------
		THIS^.RefillTurnedLine();
		
		
		me.SubStateMachine.intStateLastCycle := me.SubStateMachine.intState;
		CIf.Job.strSubState := THIS^.getCmdState(intCmdState:=me.SubStateMachine.intState,bolState:=TRUE);
		IF (me.SubStateMachine.intState<>me.SubStateMachine.intStateNext) THEN
			me.SubStateMachine.intState := me.SubStateMachine.intStateNext;  // set next state for next cycle
			me.SubStateMachine.udiTimeInState_ms := 0; // reset timer
			// log state change -> open point
		ELSE
			// increment time in state	
			me.SubStateMachine.udiTimeInState_ms := me.SubStateMachine.udiTimeInState_ms + me.FUBInfo.udiSample_ms;
		END_IF
				
		// State Change Condition	
		IF ((me.intCmd=cCMD_STOP) AND (me.SubStateMachine.intStateNext = cSTA_SUB_RUN_WAIT_JOB)) THEN
			me.StateMachine.intStateNext :=  cSTA_STOPBusy;	
		END_IF
		
		IF ((me.intCmd=cCMD_STOP) AND (me.SubStateMachine.intStateNext = cSTA_SUB_ERROR)) THEN
			me.StateMachine.intStateNext :=  cSTA_STOPBusy;	
		END_IF

	END_IF




//--------------------------------------------------------------------------------------
// Exit action
	IF (me.StateMachine.intState<>me.StateMachine.intStateNext) THEN
		// Interface to HeatPress without LineControl
		SIf.Out.bolShirtStraightReady.intern := FALSE; 	// Not Ready
		SIf.Out.bolShirtTurnReady.intern := FALSE;		// Not Ready
	END_IF]]></ST>
      </Implementation>
    </Method>
    <Method Name="checkChildAlmClass" Id="{7ed35258-df4b-4b5a-9465-5bf15c06dcef}">
      <Declaration><![CDATA[METHOD checkChildAlmClass : BOOL
]]></Declaration>
      <Implementation>
        <ST><![CDATA[//------------------------------------------------------------------------------------------------------
// check child alarm classes
// set me alarm class active if at least one child has an EOFF
IF CheckAllChildAlmClass(E_AlmClass.EOFF) THEN
	CIf.Job.eMe_ActivAlmClass := E_AlmClass.EOFF;
	me.Alarm.bolfp := TRUE;
ELSIF CheckAllChildAlmClass(E_AlmClass.OFF) THEN
	CIf.Job.eMe_ActivAlmClass := E_AlmClass.OFF;
	me.Alarm.bolfp := TRUE;
ELSIF CheckAllChildAlmClass(E_AlmClass.STOP) THEN  // FB_MER needs alarm class STOP
	CIf.Job.eMe_ActivAlmClass := E_AlmClass.STOP;
	me.Alarm.bolfp := TRUE;
ELSE
	IF (me.Alarm.bolfp) THEN
		CIf.Job.eMe_ActivAlmClass := E_AlmClass.NONE; // no reset necessary
		me.Alarm.bolfp := FALSE;
	END_IF
END_IF

//------------------------------------------------------------------------------------------------------
// set alarm class parent of childs
//------------------------------------------------------------------------------------------------------
// set alarm class parent of childs in the case of a parent EOFF or me=OFF or EOFF
IF (CIf.Job.eParent_ActivAlmClass=E_AlmClass.EOFF) THEN
	SetAllChildAlmClass(CIf.Job.eParent_ActivAlmClass);
ELSIF(CIf.Job.eMe_ActivAlmClass=E_AlmClass.EOFF) OR (CIf.Job.eMe_ActivAlmClass=E_AlmClass.OFF) THEN
	SetAllChildAlmClass(CIf.Job.eMe_ActivAlmClass);
ELSE
	// no important alarm for child active
	SetAllChildAlmClass(E_AlmClass.NONE);
END_IF]]></ST>
      </Implementation>
    </Method>
    <Method Name="RefillTurnedLine" Id="{dd22b8af-a22d-4d5a-907c-43546cb41955}">
      <Declaration><![CDATA[METHOD RefillTurnedLine
VAR
	/// Loop variable
	ii: INT;
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[// Simulation
IF (CIf.SwCfg.bolSimulation) THEN
;
END_IF
	
	
// Method refill all zones
CASE SubStateMachineRefill OF		
			
	// Check space in buffer X
	//-------------------------------
	0:
		// Check if number of hangers "per Pulse" have space in the next buffer
		// Condition: (zone[X].NumOfHangers + zone[ X + 1] .NumOfHangersPerPuls) < zone[X].MaxCapacity   			
		IF ((pSEP_SIF^.Cur.dinNumOfHangersInBuffer < pSEP_SIF^.Cfg.dinMaxCapacity) AND 
			(pSLB_T_SIF^.Cur.dinNumOfHangersInBuffer <> 0) AND (pSLB_T_SIF^.Cur.bolHangerDetected = TRUE)) THEN
			
			// Send release command to buffer zone X+1
			pSLB_T_CIF^.Job.intACmd:= SLB_CmdState.cCMD_RELEASE;	
			SubStateMachineRefill:= 1;						
		END_IF
	
	// Check if zone X+1 is released
	//-------------------------------
	1:
		IF(pSLB_T_CIF^.Job.intACmd = BASE_PLC.cCMD_DONE)THEN
			// Send stop command to buffer zone X+1
			//pSLB_T_CIF^.Job.intACmd:= cCMD_STOP;					
			SubStateMachineRefill:= 2;
			// Counter correction if no counter at inside of Buffer
			IF pSEP_SIF^.Cfg.bolHasBufferFullSensor = FALSE THEN
				pSEP_SIF^.Cur.dinNumOfHangersInBuffer := pSEP_SIF^.Cur.dinNumOfHangersInBuffer + 1;
			END_IF
		END_IF	
	
	// Check if zone X+1 is stopped
	//-------------------------------
	2:
	//	IF(pSLB_T_CIF^.Job.intState  = cSTA_STOP)THEN
			udiTimeInStateRefill_ms:= 0;
			SubStateMachineRefill:= 3;
			pHRU_CIF^.Job.intACmd := cCMD_RUN;	// Set Command to HRU				
	//	END_IF

	// Check if HRU is done
	//-------------------------------
	3: 
		IF (pHRU_CIf^.Job.intACmd = cSTA_DONE) THEN							// Hanger Rotation Unit done
			SubStateMachineRefill:= 4;
		END_IF

		
	// Break
	//-------------------------------
	4:	
		// Increment time in state	
		udiTimeInStateRefill_ms:= udiTimeInStateRefill_ms + me.FUBInfo.udiSample_ms;
		IF (udiTimeInStateRefill_ms > SIf.Par.udiIntervalBufferFilling_ms) THEN
			// Back to first state
			SubStateMachineRefill:= 0;	
		END_IF
		
END_CASE]]></ST>
      </Implementation>
      <ObjectProperties />
    </Method>
    <ObjectProperties />
  </POU>
</TcPlcObject>