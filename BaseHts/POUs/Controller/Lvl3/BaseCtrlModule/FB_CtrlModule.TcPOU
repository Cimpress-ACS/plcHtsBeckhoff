<TcPlcObject Version="1.1.0.1" ProductVersion="3.1.0.19">
  <POU Name="FB_CtrlModule" Id="{cca8a16d-f5ca-42f4-b972-17fda3ab3e23}">
    <Declaration><![CDATA[FUNCTION_BLOCK FB_CtrlModule EXTENDS FB_CtrlBase

VAR_INPUT
	// Inputs from global module for general supervision 
	// Emergency circuit ok
	In_bolEmergencyOffOk: BOOL;
	// No general error active, will be set to FALSE if there is an global error like e.g. over temperature in cabinet. 
	In_bolNoGeneralError: BOOL;
END_VAR

VAR
	// Timeout supervision of Keep alive Toggle Bit
	udinTimeToggle_ms: UDINT;
	// Specific interface struct
	SIf_MOD: T_Ctrl_SIf_MOD;
	uinGroupIndex: UINT;
	intCheckCounter: INT;
	uinMaxNrOfGroups: UINT := Base_Const.cMaxNrOfChilds;
	// List of sequences
	aListOfSeq: ARRAY[0..Base_Const.cMaxNrOfChilds] OF T_Sequence;
	usiNumOfSeq: USINT := 0;
	usiNumOfValidPointerSeqChild: USINT := 0;
	// [ms] List of waiting times for run sequence until the next group will execute
	// If wait time is zero, next group will be directly executed after current group.  
	aListOfRunGrpWaitTime_ms: ARRAY[0..Base_Const.cMaxNrOfChilds] OF UDINT;
	usiNumOfRunGrpWaitTime: USINT := 0;
	// [ms] List of waiting times for stop sequence until the next group will execute
	// If wait time is zero, next group will be directly executed after current group. 
	aListOfStopGrpWaitTime_ms: ARRAY[0..Base_Const.cMaxNrOfChilds] OF UDINT;
	usiNumOfStopGrpWaitTime: USINT := 0;
	// Array includes all registered childs of type IBuffer
	a_IBufferChildCtrl: ARRAY[0..Base_Const.cMaxNrOfChilds] OF IBuffer;
	usiNumOfIBufferChild: USINT;
	// Counter
	ii: INT;	
END_VAR

VAR CONSTANT
	// sub States for run and stop sequences
	cSTA_SUB_INITIALIZED: INT := 500;
	cSTA_SUB_SEND_GROUP_CMD: INT := 502;
	cSTA_SUB_CHECK_GROUP_STATUS: INT := 504;
	cSTA_SUB_WAIT: INT := 506;
	cSTA_SUB_FINISHED: INT := 508;
END_VAR
]]></Declaration>
    <Implementation>
      <ST><![CDATA[(*__________________________________________________________________________________________________
¦	
¦	Vistaprint Schweiz GmbH
¦	CH - 8401 Winterthur
¦
¦	www.vistaprint.ch - info@vistaprint.ch
¦___________________________________________________________________________________________________

Function desription:
Basic module controller implementation. This Controller should be the base father controller for all modules in shirt stream. 
e.g. used for ICL, ICB, Loading ...

Controller handle following basic functions:
--------------------------------------------
- Monitoring of common signals from cabinet
- Keep alive bit to line control
- General child handling RUN_busy, STOP_busy sequences and error handling

History:
Version		Date			Author		Comment
---------------------------------------------------------------------------------------------------
0.00.1		06.11.2013		AVM/DSC		Start history
0.00.2		14.11.2013		AVM/MRU		Changes in some methods
0.00.3		29.11.2013		AVM/MRU		Changes in IoInBridge
0.00.4		04.12.2013		AVM/MRU		Changes in Always - EOFFBusy
0.00.5		04.12.2013		AVM/MRU		Changes in Always - EOFFBusy at GeneralError
0.00.6		04.12.2013		AVM/MRU		Changes in Always - EOFFBusy if not in sta_EOFF 
0.00.7		05.12.2013		AVM/DSC		General revision of behaviour in case of emergency off (state EOFF) and general error (state ERROR).
										New handling for module specific interface.
0.00.8		06.12.2013		AVM/MRU		Add TSTOP in checkChildAlmClass
___________________________________________________________________________________________________*)


IF (me.bolActivate) AND (SIf_MOD.Cur<>0) AND (SIf_MOD.Cfg<>0) AND (SIf_MOD.Par<>0) AND (SIf_MOD.In<>0) THEN // cyclic call enabled
	IF (CIf.Info.bolInitDone=FALSE) THEN // first cycle -> init
		CtrlInit();
		CIf.Info.bolInitDone := TRUE;
	ELSE
		CycleStartDuty();

		Always();
		
		StateMachine();
		
		CycleEndDuty();
	END_IF
END_IF;
]]></ST>
    </Implementation>
    <Method Name="sta_RUNBusy" Id="{8e793960-d899-4403-a70f-dad72d52a320}">
      <Declaration><![CDATA[METHOD PROTECTED sta_RUNBusy : BOOL
VAR
	ii: INT;
	bolFurtherGrpExist: BOOL;
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[// state implemetation
//--------------------------------------------------------------------------------------
// Entry action
	IF (me.StateMachine.intState<>me.StateMachine.intStateLastCycle) THEN
		me.StateMachine.intStateLastCycle := me.StateMachine.intState;
		// Init sub state machine
		me.SubStateMachine.intState := cSTA_SUB_INITIALIZED; 
		me.SubStateMachine.intStateNext := cSTA_SUB_INITIALIZED;
	END_IF

//--------------------------------------------------------------------------------------
// Cyclic action
	IF (me.StateMachine.intState=me.StateMachine.intStateLastCycle) THEN

		// Simulation
		IF (CIf.SwCfg.bolSimulation) THEN
			;
		END_IF
	
		// Start Cycle with substates	
		//--------------------------------------------------------------------------------------
		// sub state machine for sequence
		CASE me.SubStateMachine.intState OF
			//--------------------------------------------------------------------------------------
			cSTA_SUB_INITIALIZED:
				uinGroupIndex:= 1;
				me.SubStateMachine.intStateNext := cSTA_SUB_SEND_GROUP_CMD;
				
			cSTA_SUB_SEND_GROUP_CMD:
				
				intCheckCounter:= 0;
				// Loop over all registered childs
				FOR ii:=0 TO usiNumOfSeq-1 BY 1 DO
					// If child is associated for the current group index		
					IF (aListOfSeq[ii].uinGroupRun = uinGroupIndex) THEN
						// Send defined command
						aListOfSeq[ii].pCIF^.Job.intACmd:= aListOfSeq[ii].intCmdSeqRun;
						intCheckCounter:= intCheckCounter + 1;
					END_IF			
				END_FOR
				// Change state
				me.SubStateMachine.intStateNext := cSTA_SUB_CHECK_GROUP_STATUS;
			
			
			cSTA_SUB_CHECK_GROUP_STATUS:
	
				// Loop over all registered childs
				FOR ii:=0 TO usiNumOfSeq-1 BY 1 DO
					// If child is associated for the current group index		
					IF (aListOfSeq[ii].uinGroupRun = uinGroupIndex) THEN
						// Check defined status
						IF (aListOfSeq[ii].pCIF^.Job.intState = aListOfSeq[ii].intStatusSeqRun) THEN
							intCheckCounter:= intCheckCounter - 1;
						END_IF				
					END_IF			
				END_FOR
				
				// All childs in group has the right state
				IF (intCheckCounter <= 0) THEN		
					bolFurtherGrpExist:= FALSE;
					// Check if a further group exist!	
					FOR ii:=0 TO usiNumOfSeq-1 BY 1 DO	
						IF (aListOfSeq[ii].uinGroupRun > uinGroupIndex) THEN
							bolFurtherGrpExist:= TRUE;
							EXIT;
						END_IF			
					END_FOR
					// further group exist
					IF (bolFurtherGrpExist = TRUE) THEN
						IF (uinGroupIndex < uinMaxNrOfGroups) THEN			
							me.SubStateMachine.intStateNext := cSTA_SUB_WAIT;	
						END_IF
					ELSE
						me.SubStateMachine.intStateNext := cSTA_SUB_FINISHED;		
					END_IF
				END_IF

			cSTA_SUB_WAIT:
				
				IF (me.SubStateMachine.udiTimeInState_ms >= aListOfRunGrpWaitTime_ms[uinGroupIndex-1]) THEN
					// Inc. group index 
					uinGroupIndex:= uinGroupIndex + 1;	
					// Change state, send command for next group
					me.SubStateMachine.intStateNext := cSTA_SUB_SEND_GROUP_CMD;
				END_IF
			
			cSTA_SUB_FINISHED:
					;		
		END_CASE
		
		// State Change Condition
		IF (me.SubStateMachine.intState = cSTA_SUB_FINISHED) THEN
			me.StateMachine.intStateNext := cSTA_RUN;
		ELSIF (me.intCmd=cCMD_STOP) THEN
			me.StateMachine.intStateNext :=  cSTA_STOPBusy;	
		END_IF
	END_IF

//--------------------------------------------------------------------------------------
// Exit action
	IF (me.StateMachine.intState<>me.StateMachine.intStateNext) THEN
		;
	END_IF]]></ST>
      </Implementation>
    </Method>
    <Method Name="CtrlInit" Id="{c52d5bac-2cda-43dd-8532-3cb71d2aa83f}">
      <Declaration><![CDATA[METHOD PROTECTED CtrlInit : BOOL
VAR
	ii: INT;
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[SUPER^.CtrlInit();

// Initialize all child controller
// Childs are listed in list of sequences
FOR ii:=0 TO usiNumOfSeq-1 BY 1 DO	
	aListOfSeq[ii].pCIF := THIS^.AddChild(aListOfSeq[ii].pChild^);
END_FOR]]></ST>
      </Implementation>
    </Method>
    <Method Name="sta_RUN" Id="{10e6062d-7819-4866-bdec-b3efbba611df}">
      <Declaration><![CDATA[METHOD PROTECTED sta_RUN : BOOL
]]></Declaration>
      <Implementation>
        <ST><![CDATA[// state implemetation
//--------------------------------------------------------------------------------------
// Entry action
	IF (me.StateMachine.intState<>me.StateMachine.intStateLastCycle) THEN
		me.StateMachine.intStateLastCycle := me.StateMachine.intState;
		;
	END_IF

//--------------------------------------------------------------------------------------
// Cyclic action
	IF (me.StateMachine.intState=me.StateMachine.intStateLastCycle) THEN

		// Simulation
		IF (CIf.SwCfg.bolSimulation) THEN
			;
		END_IF

		// State Change Condition	
		IF (me.intCmd=cCMD_STOP)  THEN
			me.StateMachine.intStateNext :=  cSTA_STOPBusy;	
		END_IF

	END_IF

//--------------------------------------------------------------------------------------
// Exit action
	IF (me.StateMachine.intState<>me.StateMachine.intStateNext) THEN
		;
	END_IF]]></ST>
      </Implementation>
    </Method>
    <Method Name="Always" Id="{e8d1e197-ee23-4f77-975e-0c43010ac957}">
      <Declaration><![CDATA[METHOD PROTECTED Always : BOOL
]]></Declaration>
      <Implementation>
        <ST><![CDATA[SUPER^.Always();

// ---------------------------------------------------------------------------------
// Simulation
IF (CIf.SwCfg.bolSimulation) THEN
	SIf_Cur^.bolKeepAliveHost := NOT SIf_Cur^.bolKeepAlivePlc;
	// Simulate inputs from global module for general supervision (no physical inputs)
	SIf_In^.bolEmergencyOffOK.intern := TRUE;
	SIf_In^.bolNoGeneralError.intern := TRUE;
END_IF

// ----------------------------------------------------------------------------------
// cyclic actions outside of statemachine
IF (me.StateMachine.intState<>cSTA_SINGLE_ANSWER) THEN
	
	//-------------------------------------------------------------------------------
	// Monitoring of inputs from global module (no physical inputs)
	//-------------------------------------------------------------------------------
	
	// No general error
	IF ((SIf_In^.bolNoGeneralError.intern = FALSE) AND (me.StateMachine.intState <> cSTA_ERROR) AND (me.StateMachine.intState <> cSTA_ERRORQuit) 
		AND (me.StateMachine.intState <> cSTA_EOFF) AND (me.StateMachine.intState <> cSTA_EOFFBusy)) THEN
		// Set Alarm: SIf_MOD.Alm[4].strText := 'General error active'; 
		pfbAlarmCtrl^.setAlarm(CIf.Info.intCtrlId,4,0,ADR(SIf_MOD.Alm),E_AlmState.RST,CIf.Job.eMe_ActivAlmClass);		
		me.StateMachine.intStateNext := cSTA_Error;		
	END_IF
	
	// Emergency Off
	IF ((SIf_In^.bolEmergencyOffOk.intern = FALSE) AND (me.StateMachine.intState <> cSTA_EOFF) AND (me.StateMachine.intState <> cSTA_EOFFBusy)
		AND (me.StateMachine.intState <> cSTA_ERROR) AND (me.StateMachine.intState <> cSTA_ERRORQuit)) THEN
		// Set Alarm: SIf_MOD.Alm[3].strText := 'Emergency off active'; 
		pfbAlarmCtrl^.setAlarm(CIf.Info.intCtrlId,3,0,ADR(SIf_MOD.Alm),E_AlmState.RST,CIf.Job.eMe_ActivAlmClass);				
		me.StateMachine.intStateNext := cSTA_EOFFBusy;				
	END_IF
	
END_IF

//-------------------------------------------------------------------------------
// Keep Alive function to line controller with togglebit
//-------------------------------------------------------------------------------

// Communication to line control enabled
IF (SIf_Cfg^.bolComToLineControlEnabled = TRUE) THEN
	IF (SIf_Cur^.bolKeepAliveHost <> SIf_Cur^.bolKeepAlivePlc) THEN
		udinTimeToggle_ms := 0;
		SIf_Cur^.bolKeepAlivePlc := SIf_Cur^.bolKeepAliveHost;
	ELSE
		IF (udinTimeToggle_ms >= SIf_Par^.udiComTimeOutLineCtrl_ms) THEN
			// Set Alarm: SIf_MOD.Alm[2].strText := 'Communication error to line control'; 
			pfbAlarmCtrl^.setAlarm(CIf.Info.intCtrlId,2,UDINT_TO_DINT(udinTimeToggle_ms),ADR(SIf_MOD.Alm),E_AlmState.RST,CIf.Job.eMe_ActivAlmClass);	
			me.StateMachine.intStateNext := cSTA_Error;	
		END_IF
		udinTimeToggle_ms:= udinTimeToggle_ms + me.FUBInfo.udiSample_ms;
	END_IF
// Communication to line control disabled
ELSE
	SIf_Cur^.bolKeepAliveHost:= NOT SIf_Cur^.bolKeepAlivePlc;
END_IF

//-------------------------------------------------------------------------------
// Calculate the sum of all hangers in the system and the capacity of the system
//-------------------------------------------------------------------------------
IF (usiNumOfIBufferChild>0) THEN 
	SIf_Cur^.dinNumOfHangers:= 0;
	SIf_Cur^.dinMaxCapacity:= 0;
	FOR ii:= 0 TO (usiNumOfIBufferChild-1) DO
		SIf_Cur^.dinNumOfHangers:= SIf_Cur^.dinNumOfHangers + a_IBufferChildCtrl[ii].NumOfHangers;
		SIf_Cur^.dinMaxCapacity:= SIf_Cur^.dinMaxCapacity + a_IBufferChildCtrl[ii].MaxCapacity;
	END_FOR
END_IF

// ----------------------------------------------------------------------------------
// Conditions Always

// EOFF exist in FB_CtrlModule. Not overrule.
(*
// overrule error always from base -> no EOFF State!! in EOFF go to OFF
IF (me.StateMachine.intStateNext = cSTA_EOFFBusy) THEN
	IF (me.StateMachine.intState=cSTA_OFF) THEN
		me.StateMachine.intStateNext := cSTA_OFF;
	ELSE // stay in OFF
		me.StateMachine.intStateNext := cSTA_OFFBusy;
	END_IF
*)
IF (me.Alarm.eActivAlmClass=E_AlmClass.STOP) AND (me.StateMachine.intStateNext<>cSTA_Error)
		AND ((me.StateMachine.intState = cSTA_RUN) OR (me.StateMachine.intState = cSTA_RUNBusy))THEN
	// alarm evt STOP
	me.StateMachine.intStateNext := cSTA_STOPBusy;	
END_IF
]]></ST>
      </Implementation>
    </Method>
    <Method Name="sta_STOPBusy" Id="{2d97cb84-93fd-4e69-a78f-6853c3b836ca}">
      <Declaration><![CDATA[METHOD PROTECTED sta_STOPBusy : BOOL
VAR
	ii: INT;
	bolFurtherGrpExist: BOOL;
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[// state implemetation
//--------------------------------------------------------------------------------------
// Entry action
	IF (me.StateMachine.intState<>me.StateMachine.intStateLastCycle) THEN
		me.StateMachine.intStateLastCycle := me.StateMachine.intState;	
		// Init sub state machine
		me.SubStateMachine.intState := cSTA_SUB_INITIALIZED; 
		me.SubStateMachine.intStateNext := cSTA_SUB_INITIALIZED;
	END_IF


//--------------------------------------------------------------------------------------
// Cyclic action
	IF (me.StateMachine.intState=me.StateMachine.intStateLastCycle) THEN

		// Simulation
		IF (CIf.SwCfg.bolSimulation) THEN
			;
		END_IF
		
		// Stop Cycle with substates	
		//--------------------------------------------------------------------------------------
		// sub state machine for sequence
		CASE me.SubStateMachine.intState OF
			//--------------------------------------------------------------------------------------
			cSTA_SUB_INITIALIZED:
				uinGroupIndex:= 1;
				me.SubStateMachine.intStateNext := cSTA_SUB_SEND_GROUP_CMD;
				
			cSTA_SUB_SEND_GROUP_CMD:
				
				intCheckCounter:= 0;
				// Loop over all registered childs
				FOR ii:=0 TO usiNumOfSeq-1 BY 1 DO
					// If child is associated for the current group index		
					IF (aListOfSeq[ii].uinGroupStop = uinGroupIndex) THEN
						// Send defined command
						aListOfSeq[ii].pCIF^.Job.intACmd:= aListOfSeq[ii].intCmdSeqStop;
						intCheckCounter:= intCheckCounter + 1;
					END_IF			
				END_FOR
				// Change state
				me.SubStateMachine.intStateNext := cSTA_SUB_CHECK_GROUP_STATUS;
			
			
			cSTA_SUB_CHECK_GROUP_STATUS:
	
				// Loop over all registered childs
				FOR ii:=0 TO usiNumOfSeq-1 BY 1 DO
					// If child is associated for the current group index		
					IF (aListOfSeq[ii].uinGroupStop = uinGroupIndex) THEN
						// Check defined status
						IF (aListOfSeq[ii].pCIF^.Job.intState = aListOfSeq[ii].intStatusSeqStop) THEN
							intCheckCounter:= intCheckCounter - 1;
						END_IF				
					END_IF			
				END_FOR
				
				// All childs in group has the right state
				IF (intCheckCounter <= 0) THEN		
					bolFurtherGrpExist:= FALSE;
					// Check if a further group exist!	
					FOR ii:=0 TO usiNumOfSeq-1 BY 1 DO	
						IF (aListOfSeq[ii].uinGroupStop > uinGroupIndex) THEN
							bolFurtherGrpExist:= TRUE;
							EXIT;
						END_IF			
					END_FOR
					// further group exist
					IF (bolFurtherGrpExist = TRUE) THEN
						IF (uinGroupIndex < uinMaxNrOfGroups) THEN			
							me.SubStateMachine.intStateNext := cSTA_SUB_WAIT;	
						END_IF
					ELSE
						me.SubStateMachine.intStateNext := cSTA_SUB_FINISHED;		
					END_IF
				END_IF

			cSTA_SUB_WAIT:
				
				IF (me.SubStateMachine.udiTimeInState_ms >= aListOfRunGrpWaitTime_ms[uinGroupIndex-1]) THEN
					// Inc. group index 
					uinGroupIndex:= uinGroupIndex + 1;	
					// Change state, send command for next group
					me.SubStateMachine.intStateNext := cSTA_SUB_SEND_GROUP_CMD;
				END_IF
			
			cSTA_SUB_FINISHED:
					;		
		END_CASE
	
		// State Change Condition
		IF (me.SubStateMachine.intState = cSTA_SUB_FINISHED) THEN
			me.StateMachine.intStateNext := cSTA_STOP;
		ELSIF (me.intCmd=cCMD_RUN) THEN
			me.StateMachine.intStateNext :=  cSTA_RUNBusy;	
		END_IF
	END_IF

//--------------------------------------------------------------------------------------
// Exit action
	IF (me.StateMachine.intState<>me.StateMachine.intStateNext) THEN
		;
	END_IF]]></ST>
      </Implementation>
    </Method>
    <Method Name="sta_STOP" Id="{3b049153-b5a6-47b8-b8cb-cc470b6b00b8}">
      <Declaration><![CDATA[METHOD PROTECTED sta_STOP : BOOL
]]></Declaration>
      <Implementation>
        <ST><![CDATA[// state implemetation
//--------------------------------------------------------------------------------------
// Entry action
	IF (me.StateMachine.intState<>me.StateMachine.intStateLastCycle) THEN
		me.StateMachine.intStateLastCycle := me.StateMachine.intState;
		
	END_IF


//--------------------------------------------------------------------------------------
// Cyclic action
	IF (me.StateMachine.intState=me.StateMachine.intStateLastCycle) THEN
		
		;	
		// State Change Condition
		IF (me.Alarm.eActivAlmClass<>E_AlmClass.STOP ) THEN
			IF (me.intCmd=cCMD_RUN) THEN
				me.StateMachine.intStateNext :=  cSTA_RUNBusy;
			END_IF
		END_IF
	END_IF

//--------------------------------------------------------------------------------------
// Exit action
	IF (me.StateMachine.intState<>me.StateMachine.intStateNext) THEN
		;
	END_IF]]></ST>
      </Implementation>
    </Method>
    <Method Name="FB_init" Id="{ae324315-115c-4a81-8772-9882bcb3036d}">
      <Declaration><![CDATA[METHOD FB_init : BOOL
VAR_INPUT
	///if TRUE, the retain variables are initialized (warm start / cold start)
	bInitRetains: BOOL;
	///if TRUE, the instance afterwards gets moved into the copy code (online change)
	bInCopyCode: BOOL;
END_VAR
VAR
	ii: UINT;
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[// to manually change in new FUB implementation!!!
// define valid commands for this controller
FOR ii:= 0 TO (SIZEOF(CIf.Job.aCmdList)/SIZEOF(CIf.Job.aCmdList[0])-1) BY 1 DO
	IF (CIf.Job.aCmdList[ii].intCmd=cCMD_INITIALIZED) THEN
		// found first empty array element
		EXIT;
	END_IF
END_FOR

CIf.Job.aCmdList[ii].intCmd := cCMD_RUN;
CIf.Job.aCmdList[ii].strName := 'Run'; 
CIf.Job.aCmdList[ii].bolAvailable := TRUE;
ii := ii +1;
CIf.Job.aCmdList[ii].intCmd := cCMD_STOP;
CIf.Job.aCmdList[ii].strName := 'Stop'; 
CIf.Job.aCmdList[ii].bolAvailable := TRUE;
ii := ii +1;

// set name of class/typ
CIf.Info.strType := 'FB_CtrlModule'; 

// set alarm class
SIf_MOD.Alm[1].eAlmClass := E_AlmClass.STOP;
SIf_MOD.Alm[1].strText := 'Invalid pointer';
SIf_MOD.Alm[2].eAlmClass := E_AlmClass.OFF;
SIf_MOD.Alm[2].strText := 'Communication error to line control'; 
SIf_MOD.Alm[3].eAlmClass := E_AlmClass.EOFF;
SIf_MOD.Alm[3].strText := 'Emergency off active'; 
SIf_MOD.Alm[4].eAlmClass := E_AlmClass.OFF;
SIf_MOD.Alm[4].strText := 'General error active'; 

//*******************************************************************************
// initial values
//*******************************************************************************
udinTimeToggle_ms := 0;
// software configuration
CIf.SwCfg.bolExist := TRUE;
CIf.SwCfg.bolSimulation := FALSE;

// No initialization for cfg and par in this base module!
// Pointer address of the property is not defined at this time]]></ST>
      </Implementation>
    </Method>
    <Method Name="getCmdState" Id="{d8d1de4b-01ee-4d9e-ae70-a782cc05d122}">
      <Declaration><![CDATA[METHOD PROTECTED getCmdState : STRING
VAR_INPUT
	intCmdState: INT;
	bolState: BOOL;
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[getCmdState := SUPER^.getCmdState(intCmdState:=intCmdState,bolState:=bolState); // get global/base defined cmds/states
IF (getCmdState='') THEN // global not defined get local
	// get string cmd/state string information in runtime
	IF (bolState=FALSE) THEN
		// cmd's
	ELSE
	
	// cmd's
		CASE intCmdState OF	
			// SUB States
			cSTA_SUB_INITIALIZED:
				getCmdState := 'cSTA_SUB_INITIALIZED';
			cSTA_SUB_SEND_GROUP_CMD:
				getCmdState := 'cSTA_SUB_SEND_GROUP_CMD';
			cSTA_SUB_CHECK_GROUP_STATUS:
				getCmdState := 'cSTA_SUB_CHECK_GROUP_STATUS';
			cSTA_SUB_WAIT:
				getCmdState := 'cSTA_SUB_WAIT';
			cSTA_SUB_FINISHED:
				getCmdState := 'cSTA_SUB_FINISHED';
		END_CASE;
	END_IF
END_IF]]></ST>
      </Implementation>
    </Method>
    <Method Name="IoInBridge" Id="{2c2fd893-974c-4d86-bfda-b8346aa22892}">
      <Declaration><![CDATA[METHOD PROTECTED IoInBridge : BOOL
]]></Declaration>
      <Implementation>
        <ST><![CDATA[// Inputs from global module for general supervision (no physical inputs)
SIf_In^.bolEmergencyOffOk.map := THIS^.In_bolEmergencyOffOk;
SIf_In^.bolNoGeneralError.map := THIS^.In_bolNoGeneralError;

IF (CIf.SwCfg.bolSimulation = FALSE) THEN
	getInBol(CIf.Job.bolIoForce,ADR(SIf_In^.bolEmergencyOffOk));
	getInBol(CIf.Job.bolIoForce,ADR(SIf_In^.bolNoGeneralError));
ELSE
	//simulation of global IO
END_IF]]></ST>
      </Implementation>
    </Method>
    <Method Name="sta_OFF" Id="{c0014833-d0ef-4032-98d6-fd0007c135d3}">
      <Declaration><![CDATA[METHOD PROTECTED sta_OFF : BOOL
]]></Declaration>
      <Implementation>
        <ST><![CDATA[// state implemetation
//--------------------------------------------------------------------------------------
// Entry action
	IF (me.StateMachine.intState<>me.StateMachine.intStateLastCycle) THEN
		me.StateMachine.intStateLastCycle := me.StateMachine.intState;
		;		
	END_IF

//--------------------------------------------------------------------------------------
// Cyclic action
	IF (me.StateMachine.intState=me.StateMachine.intStateLastCycle) THEN
				
		// State Change Condition
		IF (me.Alarm.eActivAlmClass<>E_AlmClass.EOFF) AND (me.Alarm.eActivAlmClass<>E_AlmClass.OFF) THEN
			IF (me.intCmd=cCMD_RUN) THEN 
				me.StateMachine.intStateNext := cSTA_RUNBusy;
			END_IF
		END_IF
	END_IF

//--------------------------------------------------------------------------------------
// Exit action
	IF (me.StateMachine.intState<>me.StateMachine.intStateNext) THEN
		;
	END_IF]]></ST>
      </Implementation>
    </Method>
    <Method Name="checkChildAlmClass" Id="{4a3d18b9-acae-420d-9743-86dc093ddb02}">
      <Declaration><![CDATA[METHOD checkChildAlmClass : BOOL
]]></Declaration>
      <Implementation>
        <ST><![CDATA[//------------------------------------------------------------------------------------------------------
// check child alarm classes
// set me alarm class active if at least one child has an EOFF
IF CheckAllChildAlmClass(E_AlmClass.EOFF) THEN
	CIf.Job.eMe_ActivAlmClass := E_AlmClass.EOFF;
	me.Alarm.bolfp := TRUE;
ELSIF CheckAllChildAlmClass(E_AlmClass.OFF) THEN
	CIf.Job.eMe_ActivAlmClass := E_AlmClass.OFF;
	me.Alarm.bolfp := TRUE;
ELSIF CheckAllChildAlmClass(E_AlmClass.STOP) THEN
	CIf.Job.eMe_ActivAlmClass := E_AlmClass.STOP;
	me.Alarm.bolfp := TRUE;
ELSIF CheckAllChildAlmClass(E_AlmClass.TSTOP) THEN
	CIf.Job.eMe_ActivAlmClass := E_AlmClass.TSTOP;
	me.Alarm.bolfp := TRUE;
ELSE
	IF (me.Alarm.bolfp) THEN
		CIf.Job.eMe_ActivAlmClass := E_AlmClass.NONE; // no reset necessary
		me.Alarm.bolfp := FALSE;
	END_IF
END_IF

//------------------------------------------------------------------------------------------------------
// set alarm class parent of childs
//------------------------------------------------------------------------------------------------------
// set alarm class parent of childs in the case of a parent EOFF or me=OFF or EOFF
IF (CIf.Job.eParent_ActivAlmClass=E_AlmClass.EOFF) THEN
	SetAllChildAlmClass(CIf.Job.eParent_ActivAlmClass);
ELSIF(CIf.Job.eMe_ActivAlmClass=E_AlmClass.EOFF) OR (CIf.Job.eMe_ActivAlmClass=E_AlmClass.OFF) THEN
	SetAllChildAlmClass(CIf.Job.eMe_ActivAlmClass);
ELSE
	// no important alarm for child active
	SetAllChildAlmClass(E_AlmClass.NONE);
END_IF]]></ST>
      </Implementation>
    </Method>
    <Method Name="StateMachine" Id="{331bc12e-6503-403e-a3c0-832b30026903}">
      <Declaration><![CDATA[METHOD PROTECTED StateMachine : BOOL
]]></Declaration>
      <Implementation>
        <ST><![CDATA[SUPER^.StateMachine();

// main statemachine of base controller
CASE me.StateMachine.intState OF
	cSTA_RUN: 
        THIS^.sta_RUN();
    cSTA_RUNBusy: 
        THIS^.sta_RUNBusy();
	cSTA_STOP: 
        THIS^.sta_STOP();
    cSTA_STOPBusy: 
        THIS^.sta_STOPBusy();
END_CASE;]]></ST>
      </Implementation>
    </Method>
    <Method Name="IoOutBridge" Id="{5f6ba1b2-8577-42d1-ba96-1c4e2a5a862b}">
      <Declaration><![CDATA[METHOD PROTECTED IoOutBridge : BOOL
]]></Declaration>
      <Implementation>
        <ST><![CDATA[// digitale and analoge inputs read from hardware or forcing
IF (CIf.SwCfg.bolSimulation = FALSE) THEN
	// check interlocks to prevent damages
	IF (CIf.Job.bolIlkOverwrite=FALSE) THEN
	;
	END_IF
END_IF]]></ST>
      </Implementation>
    </Method>
    <Method Name="sta_EOFFBusy" Id="{45aba3ee-31ad-4b6d-b081-e67c4a74ddf2}">
      <Declaration><![CDATA[METHOD PROTECTED sta_EOFFBusy : BOOL
]]></Declaration>
      <Implementation>
        <ST><![CDATA[// state implemetation
//--------------------------------------------------------------------------------------
// Entry action
	IF (me.StateMachine.intState<>me.StateMachine.intStateLastCycle) THEN
		me.StateMachine.intStateLastCycle := me.StateMachine.intState;
		// Clear pending command to prevent automatic recovery!
		CIf.Job.intACmd:=cSTA_DONE;
		// In case on an emergency, set all childs to off
		SetAllChildCmd(cCMD_OFF);
	END_IF

//--------------------------------------------------------------------------------------
// Cyclic action
	IF (me.StateMachine.intState=me.StateMachine.intStateLastCycle) THEN
		;
		// check if all childs have reached the state
		IF CheckAllChildState(cSTA_OFF) THEN
			me.StateMachine.intStateNext := cSTA_EOFF;
		END_IF
	END_IF

//--------------------------------------------------------------------------------------
// Exit action
	IF (me.StateMachine.intState<>me.StateMachine.intStateNext) THEN
		;
	END_IF]]></ST>
      </Implementation>
    </Method>
    <Method Name="sta_EOFF" Id="{b0421bbf-83d0-403a-bc5c-f85e4848f427}">
      <Declaration><![CDATA[METHOD PROTECTED sta_EOFF : BOOL
]]></Declaration>
      <Implementation>
        <ST><![CDATA[// state implemetation
//--------------------------------------------------------------------------------------
// Entry action
	IF (me.StateMachine.intState<>me.StateMachine.intStateLastCycle) THEN
		me.StateMachine.intStateLastCycle := me.StateMachine.intState;	
	END_IF

//--------------------------------------------------------------------------------------
// Cyclic action
	IF (me.StateMachine.intState=me.StateMachine.intStateLastCycle) THEN		
		
		// State Change Condition
		IF (me.Alarm.eActivAlmClass<>E_AlmClass.EOFF) AND (me.intCmd<>cCMD_EOFF) AND (me.intCmd<>cCMD_DONE) THEN
			me.StateMachine.intStateNext := cSTA_OFF;
		END_IF
	END_IF

//--------------------------------------------------------------------------------------
// Exit action
	IF (me.StateMachine.intState<>me.StateMachine.intStateNext) THEN
		;
	END_IF]]></ST>
      </Implementation>
    </Method>
    <Method Name="AddSeqChild" Id="{543da3ac-6a50-48e9-87e5-6f8a78a6859e}">
      <Declaration><![CDATA[METHOD AddSeqChild
VAR_INPUT
	stSequence: T_Sequence;
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[// Method add a sequence to list
IF (usiNumOfSeq <= (Base_Const.cMaxNrOfChilds-1)) THEN
	aListOfSeq[usiNumOfSeq].pChild:= stSequence.pChild;
	aListOfSeq[usiNumOfSeq].uinGroupRun:= stSequence.uinGroupRun;
	aListOfSeq[usiNumOfSeq].uinGroupStop:= stSequence.uinGroupStop;
	aListOfSeq[usiNumOfSeq].intCmdSeqRun:= stSequence.intCmdSeqRun;
	aListOfSeq[usiNumOfSeq].intStatusSeqRun:= stSequence.intStatusSeqRun;
	aListOfSeq[usiNumOfSeq].intCmdSeqStop:= stSequence.intCmdSeqStop;
	aListOfSeq[usiNumOfSeq].intStatusSeqStop:= stSequence.intStatusSeqStop;
	// Inc. number of sequence
	usiNumOfSeq:= usiNumOfSeq+1;
	// Check if the pointer is valid
	IF (stSequence.pChild<>0) THEN
		usiNumOfValidPointerSeqChild:= usiNumOfValidPointerSeqChild+1;
	END_IF
END_IF]]></ST>
      </Implementation>
    </Method>
    <Method Name="AddRunGrpTime" Id="{b8c22f31-2c20-46b4-8f42-7722292782f2}">
      <Declaration><![CDATA[METHOD AddRunGrpTime
VAR_INPUT
	udiGrpWaitTime_ms: UDINT;
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[// Method add a wait time to the list
IF (usiNumOfRunGrpWaitTime <= (Base_Const.cMaxNrOfChilds-1)) THEN
	aListOfRunGrpWaitTime_ms[usiNumOfRunGrpWaitTime]:= udiGrpWaitTime_ms;
	usiNumOfRunGrpWaitTime:= usiNumOfRunGrpWaitTime+1;
END_IF]]></ST>
      </Implementation>
    </Method>
    <Method Name="AddStopGrpTime" Id="{9c546cfd-12a1-474d-80c9-f24a4f230e4f}">
      <Declaration><![CDATA[METHOD AddStopGrpTime
VAR_INPUT
	udiGrpWaitTime_ms: UDINT;
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[// Method add a wait time to the list
IF (usiNumOfStopGrpWaitTime <= (Base_Const.cMaxNrOfChilds-1)) THEN
	aListOfStopGrpWaitTime_ms[usiNumOfStopGrpWaitTime]:= udiGrpWaitTime_ms;
	usiNumOfStopGrpWaitTime:= usiNumOfStopGrpWaitTime+1;
END_IF]]></ST>
      </Implementation>
    </Method>
    <Method Name="checkValidPointer" Id="{ccd0fab0-c2c6-48eb-8513-ffa0d4ea4f7c}">
      <Declaration><![CDATA[METHOD PROTECTED checkValidPointer : BOOL
]]></Declaration>
      <Implementation>
        <ST><![CDATA[IF (usiNumOfSeq = usiNumOfValidPointerSeqChild) AND (SIf_Cfg<>0) AND (SIf_Par<>0) AND (SIf_Cur<>0) AND (SIf_In<>0) THEN
	checkValidPointer:= TRUE;
ELSE
	// Invalid child pointer
	checkValidPointer:= FALSE;	
	// SIf.Alm[1].strText := 'Invalid pointer'; 
	pfbAlarmCtrl^.setAlarm(CIf.Info.intCtrlId,1,0,ADR(SIf_MOD.Alm),E_AlmState.RST,CIf.Job.eMe_ActivAlmClass);	
END_IF]]></ST>
      </Implementation>
    </Method>
    <Method Name="AddIBufferChilds" Id="{ca70c08a-2ad8-4f57-9883-53b21990cefd}">
      <Declaration><![CDATA[METHOD AddIBufferChilds
VAR_INPUT
	pFB_ChildTypeIBuffer: POINTER TO FB_IBuffer;
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[// Method add childs with type of IBuffer to the array
IF (usiNumOfIBufferChild <= (Base_Const.cMaxNrOfChilds-1)) THEN
	// Add child controller to list
	a_IBufferChildCtrl[usiNumOfIBufferChild] := pFB_ChildTypeIBuffer^;
	// Inc. number of IBuffer childs
	usiNumOfIBufferChild:= usiNumOfIBufferChild+1;
END_IF

]]></ST>
      </Implementation>
    </Method>
    <Method Name="sta_ERROR" Id="{6bb9de7c-ef80-4409-9aab-3765b30a1f7d}">
      <Declaration><![CDATA[METHOD PROTECTED sta_ERROR : BOOL]]></Declaration>
      <Implementation>
        <ST><![CDATA[// state implemetation
//--------------------------------------------------------------------------------------
// Entry action
	IF (me.StateMachine.intState<>me.StateMachine.intStateLastCycle) THEN
		me.StateMachine.intStateHistory := me.StateMachine.intStateLastCycle; // -> possibillity to go back to state before error
		me.StateMachine.intStateLastCycle := me.StateMachine.intState;
		// Clear pending command to prevent automatic recovery!
		CIf.Job.intACmd:=cSTA_DONE;
		// In case on an error, set all childs to off
		SetAllChildCmd(cCMD_OFF);
	END_IF

//--------------------------------------------------------------------------------------
// Cyclic action
	IF (me.StateMachine.intState=me.StateMachine.intStateLastCycle) THEN
		
		;
		// State Change Condition
		IF ((CIf.Job.bolAlmReset = TRUE) AND (CheckAllChildState(cSTA_OFF))) THEN
			me.StateMachine.intStateNext := cSTA_ERRORQuit;
		END_IF
	END_IF

//--------------------------------------------------------------------------------------
// Exit action
	IF (me.StateMachine.intState<>me.StateMachine.intStateNext) THEN
		;
	END_IF]]></ST>
      </Implementation>
    </Method>
    <Property Name="SIf_Cur" Id="{4e7ccb3c-736e-4025-a79c-7e37eef79e0a}">
      <Declaration><![CDATA[PROPERTY SIf_Cur : POINTER TO T_Ctrl_SIf_MOD_Cur]]></Declaration>
      <Get Name="Get" Id="{4e3a18e8-723e-47d3-b005-2aa0f460b14a}">
        <Declaration><![CDATA[]]></Declaration>
        <Implementation>
          <ST><![CDATA[SIf_Cur:= SIf_MOD.Cur; ]]></ST>
        </Implementation>
      </Get>
      <Set Name="Set" Id="{91a263a5-51eb-41b5-a9f6-d6e05947fb9a}">
        <Declaration><![CDATA[]]></Declaration>
        <Implementation>
          <ST><![CDATA[SIf_MOD.Cur := SIf_Cur; ]]></ST>
        </Implementation>
      </Set>
    </Property>
    <Property Name="SIf_Par" Id="{9cf6f9c8-1b71-4f00-b0c6-15e188edefbc}">
      <Declaration><![CDATA[PROPERTY SIf_Par : POINTER TO T_Ctrl_SIf_MOD_Par
]]></Declaration>
      <Get Name="Get" Id="{c803637c-d474-4e29-af7c-67ed7925f818}">
        <Declaration><![CDATA[]]></Declaration>
        <Implementation>
          <ST><![CDATA[SIf_Par:= SIf_MOD.Par; ]]></ST>
        </Implementation>
      </Get>
      <Set Name="Set" Id="{ae664cb4-750f-4390-95d4-8d818db996ee}">
        <Declaration><![CDATA[]]></Declaration>
        <Implementation>
          <ST><![CDATA[SIf_MOD.Par := SIf_Par; ]]></ST>
        </Implementation>
      </Set>
    </Property>
    <Property Name="SIf_Cfg" Id="{1e87a95f-08d3-4500-a3ab-126890a10bf9}">
      <Declaration><![CDATA[PROPERTY SIf_Cfg : POINTER TO T_Ctrl_SIf_MOD_Cfg
]]></Declaration>
      <Get Name="Get" Id="{ef502ad9-b3fd-4971-84d0-a0b246ceb70b}">
        <Declaration><![CDATA[]]></Declaration>
        <Implementation>
          <ST><![CDATA[SIf_Cfg:= SIf_MOD.Cfg; ]]></ST>
        </Implementation>
      </Get>
      <Set Name="Set" Id="{0e892710-83e8-4f0f-8694-452508272c40}">
        <Declaration><![CDATA[]]></Declaration>
        <Implementation>
          <ST><![CDATA[SIf_MOD.Cfg := SIf_Cfg;]]></ST>
        </Implementation>
      </Set>
    </Property>
    <Property Name="SIf_In" Id="{2ac37c1f-ba34-4557-98b0-82f96a662392}">
      <Declaration><![CDATA[PROPERTY SIf_In : POINTER TO T_Ctrl_SIf_MOD_In]]></Declaration>
      <Get Name="Get" Id="{5ac45788-12a5-4ec6-86d9-42b1fe50abe3}">
        <Declaration><![CDATA[
]]></Declaration>
        <Implementation>
          <ST><![CDATA[SIf_In:= SIf_MOD.In; ]]></ST>
        </Implementation>
      </Get>
      <Set Name="Set" Id="{bf83a296-1a0e-426b-a219-fc3756225ed3}">
        <Declaration><![CDATA[]]></Declaration>
        <Implementation>
          <ST><![CDATA[SIf_MOD.In := SIf_In;]]></ST>
        </Implementation>
      </Set>
    </Property>
    <ObjectProperties>﻿<XmlArchive>
  <Data>
    <o xml:space="preserve" t="POUImageProperty">
      <n n="ImageData" />
      <v n="TransparencyColor">"White"</v>
      <v n="MakeTransparent">false</v>
    </o>
  </Data>
  <TypeList>
    <Type n="Boolean">System.Boolean</Type>
    <Type n="POUImageProperty">{bb741845-1ec5-4be9-bb0d-2cf7058af574}</Type>
    <Type n="String">System.String</Type>
  </TypeList>
</XmlArchive></ObjectProperties>
  </POU>
</TcPlcObject>