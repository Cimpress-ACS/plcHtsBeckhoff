<TcPlcObject Version="1.1.0.1" ProductVersion="3.1.0.19">
  <POU Name="FB_CtrlModule" Id="{688741db-fc46-43a1-b0ea-4dfe62676523}">
    <Declaration><![CDATA[FUNCTION_BLOCK FB_CtrlModule EXTENDS FB_CtrlBase

VAR_INPUT
	// Inputs from global module for general supervision 
	// Emergency circuit ok
	In_bolEmergencyOffOk: BOOL;
	// No general error active, will be set to FALSE if there is an global error like e.g. over temperature in cabinet. 
	In_bolNoGeneralError: BOOL;
END_VAR

VAR
	// Timeout supervision of Keep alive Toggle Bit
	udinTimeToggle_ms: UDINT;
	// Specific interface struct
	SIf_MOD: T_Ctrl_SIf_MOD;
	uinGroupIndex: UINT;
	intCheckCounter: INT;
	uinMaxNrOfGroups: UINT := Base_Const.cMaxNrOfChilds;
	// List of sequences
	aListOfSeq: ARRAY[0..Base_Const.cMaxNrOfChilds] OF T_Sequence;
	usiNumOfSeq: USINT := 0;
	usiNumOfValidPointerSeqChild: USINT := 0;
	// [ms] List of waiting times for run sequence until the next group will execute
	// If wait time is zero, next group will be directly executed after current group.  
//	aListOfRunGrpWaitTime_ms: ARRAY[0..Base_Const.cMaxNrOfChilds] OF UDINT;
	usiNumOfRunGrpWaitTime: USINT := 0;
	// [ms] List of waiting times for stop sequence until the next group will execute
	// If wait time is zero, next group will be directly executed after current group. 
//	aListOfStopGrpWaitTime_ms: ARRAY[0..Base_Const.cMaxNrOfChilds] OF UDINT;
	usiNumOfStopGrpWaitTime: USINT := 0;
	// Array includes all registered childs of type IBuffer
	a_IBufferChildCtrl: ARRAY[0..Base_Const.cMaxNrOfChilds] OF IBuffer;
	a_IBufferFullChildCtrl: ARRAY[0..Base_Const.cMaxNrOfChilds] OF IBuffer;

	usiNumOfIBufferChild: USINT;
	usiNumOfIBufferFullChild: USINT;
	// Counter
	ii: INT;	
END_VAR

VAR CONSTANT
	// sub States for run and stop sequences
	cSTA_SUB_INITIALIZED: INT := 500;
	cSTA_SUB_SEND_GROUP_CMD: INT := 502;
	cSTA_SUB_CHECK_GROUP_STATUS: INT := 504;
	cSTA_SUB_WAIT: INT := 506;
	cSTA_SUB_FINISHED: INT := 508;
END_VAR
]]></Declaration>
    <Implementation>
      <ST><![CDATA[(*__________________________________________________________________________________________________
¦	
¦	Vistaprint Schweiz GmbH
¦	CH - 8401 Winterthur
¦
¦	www.vistaprint.ch - info@vistaprint.ch
¦___________________________________________________________________________________________________

Function desription:
Basic module controller implementation. This Controller should be the base father controller for all modules in shirt stream. 
e.g. used for ICL, ICB, Loading ...

Controller handle following basic functions:
--------------------------------------------
- Monitoring of common signals from cabinet
- Keep alive bit to line control
- General child handling RUN_busy, STOP_busy sequences and error handling

History:
Version		Date			Author		Comment
---------------------------------------------------------------------------------------------------
0.00.1		06.11.2013		AVM/DSC		Start history
0.00.2		14.11.2013		AVM/MRU		Changes in some methods
0.00.3		29.11.2013		AVM/MRU		Changes in IoInBridge
0.00.4		04.12.2013		AVM/MRU		Changes in Always - EOFFBusy
0.00.5		04.12.2013		AVM/MRU		Changes in Always - EOFFBusy at GeneralError
0.00.6		04.12.2013		AVM/MRU		Changes in Always - EOFFBusy if not in sta_EOFF 
0.00.7		05.12.2013		AVM/DSC		General revision of behaviour in case of emergency off (state EOFF) and general error (state ERROR).
										New handling for module specific interface.
0.00.8		06.12.2013		AVM/MRU		Add TSTOP in checkChildAlmClass
0.00.9		09.12.2013		AVM/DSC		BugFix in sub state "cSTA_SUB_CHECK_GROUP_STATUS" from run and stop sequence. Insert new "bolChecked" flag
						 				to detect if the sequence has been processed correctly.
0.00.10		11.12.2013		AVM/MRU		Clear pending command to prevent automatic recovery in sta_STOPBusy
0.00.11		13.01.2014		AVM/MRU		Bugzilla ID 03: BufferFull added
0.00.12		20.01.2014		AVM/MRU		EMO, general error reworked; AddRunGrp, AddStopGrp removed
										Timeout run/stop group added 
0.00.13		22.01.2014		AVM/MRU		Alternativ status for run sequence added

___________________________________________________________________________________________________*)


IF (me.bolActivate) AND (SIf_MOD.Cur<>0) AND (SIf_MOD.Cfg<>0) AND (SIf_MOD.Par<>0) AND (SIf_MOD.In<>0) THEN // cyclic call enabled
	IF (CIf.Info.bolInitDone=FALSE) THEN // first cycle -> init
		CtrlInit();
		CIf.Info.bolInitDone := TRUE;
	ELSE
		CycleStartDuty();

		Always();
		
		StateMachine();
		
		CycleEndDuty();
	END_IF
END_IF;
]]></ST>
    </Implementation>
    <Method Name="sta_RUNBusy" Id="{d6a4d666-a686-4bfe-8a83-0833c6ade5a5}">
      <Declaration><![CDATA[METHOD PROTECTED sta_RUNBusy : BOOL
VAR
	ii: INT;
	bolFurtherGrpExist: BOOL;
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[// state implemetation
//--------------------------------------------------------------------------------------
// Entry action
	IF (me.StateMachine.intState<>me.StateMachine.intStateLastCycle) THEN
		me.StateMachine.intStateLastCycle := me.StateMachine.intState;
		// Init sub state machine
		me.SubStateMachine.intState := cSTA_SUB_INITIALIZED; 
		me.SubStateMachine.intStateNext := cSTA_SUB_INITIALIZED;
	END_IF

//--------------------------------------------------------------------------------------
// Cyclic action
	IF (me.StateMachine.intState=me.StateMachine.intStateLastCycle) THEN

		// Simulation
		IF (CIf.SwCfg.bolSimulation) THEN
			;
		END_IF
	
		// Start Cycle with substates	
		//--------------------------------------------------------------------------------------
		// sub state machine for sequence
		CASE me.SubStateMachine.intState OF
			//--------------------------------------------------------------------------------------
			cSTA_SUB_INITIALIZED:
			
				// Loop over all registered childs
				FOR ii:=0 TO usiNumOfSeq-1 BY 1 DO
					// Clear checked flag		
					aListOfSeq[ii].bolChecked:= FALSE;
				END_FOR
				uinGroupIndex:= 1;
				me.SubStateMachine.intStateNext := cSTA_SUB_SEND_GROUP_CMD;
				
			cSTA_SUB_SEND_GROUP_CMD:
				
				intCheckCounter:= 0;
				// Loop over all registered childs
				FOR ii:=0 TO usiNumOfSeq-1 BY 1 DO
					// If child is associated for the current group index		
					IF (aListOfSeq[ii].uinGroupRun = uinGroupIndex) THEN
						// Send defined command
						aListOfSeq[ii].pCIF^.Job.intACmd:= aListOfSeq[ii].intCmdSeqRun;
						intCheckCounter:= intCheckCounter + 1;
					END_IF			
				END_FOR
				// Change state
				me.SubStateMachine.intStateNext := cSTA_SUB_CHECK_GROUP_STATUS;
			
			
			cSTA_SUB_CHECK_GROUP_STATUS:
	
				// Loop over all registered childs
				FOR ii:=0 TO usiNumOfSeq-1 BY 1 DO
					// If child is associated for the current group index		
					IF (aListOfSeq[ii].uinGroupRun = uinGroupIndex) THEN
						// Check defined status and if child not already checked
						IF (((aListOfSeq[ii].pCIF^.Job.intState = aListOfSeq[ii].intStatusSeqRun) OR 
						(aListOfSeq[ii].pCIF^.Job.intState = aListOfSeq[ii].intStatusSeqRun2)) AND (aListOfSeq[ii].bolChecked = FALSE)) THEN
							aListOfSeq[ii].bolChecked:= TRUE;
							intCheckCounter:= intCheckCounter - 1;
						END_IF				
					END_IF			
				END_FOR
				
				// All childs in group has the right state
				IF (intCheckCounter <= 0) THEN		
					bolFurtherGrpExist:= FALSE;
					// Check if a further group exist!	
					FOR ii:=0 TO usiNumOfSeq-1 BY 1 DO	
						IF (aListOfSeq[ii].uinGroupRun > uinGroupIndex) THEN
							bolFurtherGrpExist:= TRUE;
							EXIT;
						END_IF			
					END_FOR
					// further group exist
					IF (bolFurtherGrpExist = TRUE) THEN
						IF (uinGroupIndex < uinMaxNrOfGroups) THEN			
							me.SubStateMachine.intStateNext := cSTA_SUB_WAIT;	
						END_IF
					ELSE
						me.SubStateMachine.intStateNext := cSTA_SUB_FINISHED;		
					END_IF
				END_IF

			cSTA_SUB_WAIT:
				
				IF (me.SubStateMachine.udiTimeInState_ms >= SIf_Par^.aListOfRunGrpWaitTime_ms[uinGroupIndex-1]) THEN
					// Inc. group index 
					uinGroupIndex:= uinGroupIndex + 1;	
					// Change state, send command for next group
					me.SubStateMachine.intStateNext := cSTA_SUB_SEND_GROUP_CMD;
				END_IF
			
			cSTA_SUB_FINISHED:
					;		
		END_CASE
		
		// Check time out error
		IF (me.SubStateMachine.udiTimeInState_ms > (SIf_Par^.aListOfRunGrpWaitTime_ms[uinGroupIndex-1] + 30000)) THEN
			// SIf_MOD.Alm[5].strText := 'Timeout start group '; 
			pfbAlarmCtrl^.setAlarm(CIf.Info.intCtrlId,5,uinGroupIndex,ADR(SIf_MOD.Alm),E_AlmState.RST,CIf.Job.eMe_ActivAlmClass);
		END_IF
		
		// State Change Condition
		IF (me.SubStateMachine.intState = cSTA_SUB_FINISHED) THEN
			me.StateMachine.intStateNext := cSTA_RUN;
		ELSIF (me.intCmd=cCMD_STOP) THEN
			me.StateMachine.intStateNext :=  cSTA_STOPBusy;	
		END_IF
	END_IF

//--------------------------------------------------------------------------------------
// Exit action
	IF (me.StateMachine.intState<>me.StateMachine.intStateNext) THEN
		;
	END_IF]]></ST>
      </Implementation>
    </Method>
    <Method Name="CtrlInit" Id="{f3204552-2244-4621-90ab-c60992569af4}">
      <Declaration><![CDATA[METHOD PROTECTED CtrlInit : BOOL
VAR
	ii: INT;
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[SUPER^.CtrlInit();

// Initialize all child controller
// Childs are listed in list of sequences
FOR ii:=0 TO usiNumOfSeq-1 BY 1 DO	
	aListOfSeq[ii].pCIF := THIS^.AddChild(aListOfSeq[ii].pChild^);
END_FOR]]></ST>
      </Implementation>
    </Method>
    <Method Name="sta_RUN" Id="{41c55644-7a00-4d79-b266-125261b220bd}">
      <Declaration><![CDATA[METHOD PROTECTED sta_RUN : BOOL
]]></Declaration>
      <Implementation>
        <ST><![CDATA[// state implemetation
//--------------------------------------------------------------------------------------
// Entry action
	IF (me.StateMachine.intState<>me.StateMachine.intStateLastCycle) THEN
		me.StateMachine.intStateLastCycle := me.StateMachine.intState;
		;
	END_IF

//--------------------------------------------------------------------------------------
// Cyclic action
	IF (me.StateMachine.intState=me.StateMachine.intStateLastCycle) THEN

		// Simulation
		IF (CIf.SwCfg.bolSimulation) THEN
			;
		END_IF

		// State Change Condition	
		IF (me.intCmd=cCMD_STOP)  THEN
			me.StateMachine.intStateNext :=  cSTA_STOPBusy;	
		END_IF

	END_IF

//--------------------------------------------------------------------------------------
// Exit action
	IF (me.StateMachine.intState<>me.StateMachine.intStateNext) THEN
		;
	END_IF]]></ST>
      </Implementation>
    </Method>
    <Method Name="Always" Id="{00903eb6-c255-4379-babe-f7e45faa5e6c}">
      <Declaration><![CDATA[METHOD PROTECTED Always : BOOL
]]></Declaration>
      <Implementation>
        <ST><![CDATA[SUPER^.Always();

// ---------------------------------------------------------------------------------
// Simulation
IF (CIf.SwCfg.bolSimulation) THEN
	SIf_Cur^.bolKeepAliveHost := NOT SIf_Cur^.bolKeepAlivePlc;
	// Simulate inputs from global module for general supervision (no physical inputs)
	SIf_In^.bolEmergencyOffOK.intern := TRUE;
	SIf_In^.bolNoGeneralError.intern := TRUE;
END_IF

// ----------------------------------------------------------------------------------
// cyclic actions outside of statemachine
IF (me.StateMachine.intState<>cSTA_SINGLE_ANSWER) THEN
	
	//-------------------------------------------------------------------------------
	// Monitoring of inputs from global module (no physical inputs)
	//-------------------------------------------------------------------------------
	
	// No general error
	IF ((SIf_In^.bolNoGeneralError.intern = FALSE) AND (me.StateMachine.intState <> cSTA_ERROR) AND (me.StateMachine.intState <> cSTA_ERRORQuit) 
		AND (me.StateMachine.intState <> cSTA_EOFF) AND (me.StateMachine.intState <> cSTA_EOFFBusy)) THEN
		me.StateMachine.intStateNext := cSTA_Error;		
	END_IF
	// As long as general error is not OK, set Alarm
	IF (SIf_In^.bolNoGeneralError.intern = FALSE) AND (me.StateMachine.intState = BASE_PLC.cSTA_ERROR) THEN
		// Set Alarm: SIf_MOD.Alm[4].strText := 'General error active'; 
		pfbAlarmCtrl^.setAlarm(CIf.Info.intCtrlId,4,0,ADR(SIf_MOD.Alm),E_AlmState.RST,CIf.Job.eMe_ActivAlmClass);		
	END_IF
	
	// Emergency Off
	IF ((SIf_In^.bolEmergencyOffOk.intern = FALSE) AND (me.StateMachine.intState <> cSTA_EOFF) AND (me.StateMachine.intState <> cSTA_EOFFBusy)
		AND (me.StateMachine.intState <> cSTA_ERROR) AND (me.StateMachine.intState <> cSTA_ERRORQuit)) THEN
		me.StateMachine.intStateNext := cSTA_EOFFBusy;				
	END_IF
	// As long as EMO is not OK, set Alarm
	IF (SIf_In^.bolEmergencyOffOk.intern = FALSE) AND ((me.StateMachine.intState = cSTA_EOFF) OR (me.StateMachine.intState = cSTA_EOFFBusy)) THEN
		// Set Alarm: SIf_MOD.Alm[3].strText := 'Emergency off active'; 
		pfbAlarmCtrl^.setAlarm(CIf.Info.intCtrlId,3,0,ADR(SIf_MOD.Alm),E_AlmState.RST,CIf.Job.eMe_ActivAlmClass);				
	END_IF
	
END_IF

//-------------------------------------------------------------------------------
// Keep Alive function to line controller with togglebit
//-------------------------------------------------------------------------------

// Communication to line control enabled
IF (SIf_Cfg^.bolComToLineControlEnabled = TRUE) THEN
	IF (SIf_Cur^.bolKeepAliveHost <> SIf_Cur^.bolKeepAlivePlc) THEN
		udinTimeToggle_ms := 0;
		SIf_Cur^.bolKeepAlivePlc := SIf_Cur^.bolKeepAliveHost;
	ELSE
		IF (udinTimeToggle_ms >= SIf_Par^.udiComTimeOutLineCtrl_ms) THEN
			// Set Alarm: SIf_MOD.Alm[2].strText := 'Communication error to line control'; 
			pfbAlarmCtrl^.setAlarm(CIf.Info.intCtrlId,2,UDINT_TO_DINT(udinTimeToggle_ms),ADR(SIf_MOD.Alm),E_AlmState.RST,CIf.Job.eMe_ActivAlmClass);	
			me.StateMachine.intStateNext := cSTA_Error;	
		END_IF
		udinTimeToggle_ms:= udinTimeToggle_ms + me.FUBInfo.udiSample_ms;
	END_IF
// Communication to line control disabled
ELSE
	SIf_Cur^.bolKeepAliveHost:= NOT SIf_Cur^.bolKeepAlivePlc;
END_IF

//-------------------------------------------------------------------------------
// Calculate the sum of all hangers in the system and the capacity of the system
//-------------------------------------------------------------------------------
IF (usiNumOfIBufferChild>0) THEN 
	SIf_Cur^.dinNumOfHangers:= 0;
	SIf_Cur^.dinMaxCapacity:= 0;
	FOR ii:= 0 TO (usiNumOfIBufferChild-1) DO
		SIf_Cur^.dinNumOfHangers:= SIf_Cur^.dinNumOfHangers + a_IBufferChildCtrl[ii].NumOfHangers;
		SIf_Cur^.dinMaxCapacity:= SIf_Cur^.dinMaxCapacity + a_IBufferChildCtrl[ii].MaxCapacity;
	END_FOR
END_IF

//-------------------------------------------------------------------------------
// Write BufferFull for LineControl into SIF
//-------------------------------------------------------------------------------
IF (usiNumOfIBufferFullChild>0) THEN 
	FOR ii:= 0 TO (usiNumOfIBufferFullChild-1) DO
		SIf_Cur^.a_bBufferIsFull[ii]:= a_IBufferFullChildCtrl[ii].BufferFull;
	END_FOR
END_IF


// ----------------------------------------------------------------------------------
// Conditions Always

// EOFF exist in FB_CtrlModule. Not overrule.
(*
// overrule error always from base -> no EOFF State!! in EOFF go to OFF
IF (me.StateMachine.intStateNext = cSTA_EOFFBusy) THEN
	IF (me.StateMachine.intState=cSTA_OFF) THEN
		me.StateMachine.intStateNext := cSTA_OFF;
	ELSE // stay in OFF
		me.StateMachine.intStateNext := cSTA_OFFBusy;
	END_IF
*)
IF (me.Alarm.eActivAlmClass=E_AlmClass.STOP) AND (me.StateMachine.intStateNext<>cSTA_Error)
		AND ((me.StateMachine.intState = cSTA_RUN) OR (me.StateMachine.intState = cSTA_RUNBusy))THEN
	// alarm evt STOP
	me.StateMachine.intStateNext := cSTA_STOPBusy;	
END_IF
]]></ST>
      </Implementation>
    </Method>
    <Method Name="sta_STOPBusy" Id="{041bf862-019b-485c-80d1-fa913c8c8bc1}">
      <Declaration><![CDATA[METHOD PROTECTED sta_STOPBusy : BOOL
VAR
	ii: INT;
	bolFurtherGrpExist: BOOL;
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[// state implemetation
//--------------------------------------------------------------------------------------
// Entry action
	IF (me.StateMachine.intState<>me.StateMachine.intStateLastCycle) THEN
		me.StateMachine.intStateLastCycle := me.StateMachine.intState;	
		// Init sub state machine
		me.SubStateMachine.intState := cSTA_SUB_INITIALIZED; 
		me.SubStateMachine.intStateNext := cSTA_SUB_INITIALIZED;
	END_IF


//--------------------------------------------------------------------------------------
// Cyclic action
	IF (me.StateMachine.intState=me.StateMachine.intStateLastCycle) THEN

		// Simulation
		IF (CIf.SwCfg.bolSimulation) THEN
			;
		END_IF
		
		// Stop Cycle with substates	
		//--------------------------------------------------------------------------------------
		// sub state machine for sequence
		CASE me.SubStateMachine.intState OF
			//--------------------------------------------------------------------------------------
			cSTA_SUB_INITIALIZED:
			
				// Loop over all registered childs
				FOR ii:=0 TO usiNumOfSeq-1 BY 1 DO
					// Clear checked flag		
					aListOfSeq[ii].bolChecked:= FALSE;
				END_FOR
				uinGroupIndex:= 1;
				me.SubStateMachine.intStateNext := cSTA_SUB_SEND_GROUP_CMD;
				
			cSTA_SUB_SEND_GROUP_CMD:
				
				intCheckCounter:= 0;
				// Loop over all registered childs
				FOR ii:=0 TO usiNumOfSeq-1 BY 1 DO
					// If child is associated for the current group index		
					IF (aListOfSeq[ii].uinGroupStop = uinGroupIndex) THEN
						// Send defined command
						aListOfSeq[ii].pCIF^.Job.intACmd:= aListOfSeq[ii].intCmdSeqStop;
						intCheckCounter:= intCheckCounter + 1;
					END_IF			
				END_FOR
				// Change state
				me.SubStateMachine.intStateNext := cSTA_SUB_CHECK_GROUP_STATUS;
			
			
			cSTA_SUB_CHECK_GROUP_STATUS:
	
				// Loop over all registered childs
				FOR ii:=0 TO usiNumOfSeq-1 BY 1 DO
					// If child is associated for the current group index		
					IF (aListOfSeq[ii].uinGroupStop = uinGroupIndex) THEN
						// Check defined status and if child not already checked
						IF ((aListOfSeq[ii].pCIF^.Job.intState = aListOfSeq[ii].intStatusSeqStop) AND (aListOfSeq[ii].bolChecked = FALSE)) THEN
							aListOfSeq[ii].bolChecked:= TRUE;
							intCheckCounter:= intCheckCounter - 1;
						END_IF				
					END_IF			
				END_FOR
				
				// All childs in group has the right state
				IF (intCheckCounter <= 0) THEN		
					bolFurtherGrpExist:= FALSE;
					// Check if a further group exist!	
					FOR ii:=0 TO usiNumOfSeq-1 BY 1 DO	
						IF (aListOfSeq[ii].uinGroupStop > uinGroupIndex) THEN
							bolFurtherGrpExist:= TRUE;
							EXIT;
						END_IF			
					END_FOR
					// further group exist
					IF (bolFurtherGrpExist = TRUE) THEN
						IF (uinGroupIndex < uinMaxNrOfGroups) THEN			
							me.SubStateMachine.intStateNext := cSTA_SUB_WAIT;	
						END_IF
					ELSE
						me.SubStateMachine.intStateNext := cSTA_SUB_FINISHED;		
					END_IF
				END_IF

			cSTA_SUB_WAIT:
				
				IF (me.SubStateMachine.udiTimeInState_ms >= SIf_Par^.aListOfStopGrpWaitTime_ms[uinGroupIndex-1]) THEN
					// Inc. group index 
					uinGroupIndex:= uinGroupIndex + 1;	
					// Change state, send command for next group
					me.SubStateMachine.intStateNext := cSTA_SUB_SEND_GROUP_CMD;
				END_IF
			
			cSTA_SUB_FINISHED:
					;		
		END_CASE
		
		// Check time out error
		IF (me.SubStateMachine.udiTimeInState_ms > (SIf_Par^.aListOfStopGrpWaitTime_ms[uinGroupIndex-1] + 30000)) THEN
			// SIf_MOD.Alm[6].strText := 'Timeout stop group '; 
			pfbAlarmCtrl^.setAlarm(CIf.Info.intCtrlId,6,uinGroupIndex,ADR(SIf_MOD.Alm),E_AlmState.RST,CIf.Job.eMe_ActivAlmClass);
		END_IF
	
		// State Change Condition
		IF (me.SubStateMachine.intState = cSTA_SUB_FINISHED) THEN
			me.StateMachine.intStateNext := cSTA_STOP;
		ELSIF (me.intCmd=cCMD_RUN) THEN
			// State Change Condition
			IF (me.Alarm.eActivAlmClass<>E_AlmClass.STOP) THEN	
				me.StateMachine.intStateNext := cSTA_RUNBusy;	
			ELSE
				// Clear pending command to prevent automatic recovery!
				CIf.Job.intACmd:=cSTA_DONE;
			END_IF
		END_IF

	END_IF

//--------------------------------------------------------------------------------------
// Exit action
	IF (me.StateMachine.intState<>me.StateMachine.intStateNext) THEN
		;
	END_IF]]></ST>
      </Implementation>
    </Method>
    <Method Name="sta_STOP" Id="{fb63a740-8b51-43c2-a762-f4e7d2e8a825}">
      <Declaration><![CDATA[METHOD PROTECTED sta_STOP : BOOL
]]></Declaration>
      <Implementation>
        <ST><![CDATA[// state implemetation
//--------------------------------------------------------------------------------------
// Entry action
	IF (me.StateMachine.intState<>me.StateMachine.intStateLastCycle) THEN
		me.StateMachine.intStateLastCycle := me.StateMachine.intState;
		
	END_IF


//--------------------------------------------------------------------------------------
// Cyclic action
	IF (me.StateMachine.intState=me.StateMachine.intStateLastCycle) THEN
		
		;	
		// State Change Condition
		IF (me.Alarm.eActivAlmClass<>E_AlmClass.STOP) THEN
			IF (me.intCmd=cCMD_RUN) THEN
				me.StateMachine.intStateNext :=  cSTA_RUNBusy;
			END_IF
		END_IF
	END_IF

//--------------------------------------------------------------------------------------
// Exit action
	IF (me.StateMachine.intState<>me.StateMachine.intStateNext) THEN
		;
	END_IF]]></ST>
      </Implementation>
    </Method>
    <Method Name="FB_init" Id="{4e8d539c-d414-472e-a843-6fffe152d6df}">
      <Declaration><![CDATA[METHOD FB_init : BOOL
VAR_INPUT
	///if TRUE, the retain variables are initialized (warm start / cold start)
	bInitRetains: BOOL;
	///if TRUE, the instance afterwards gets moved into the copy code (online change)
	bInCopyCode: BOOL;
END_VAR
VAR
	ii: UINT;
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[// to manually change in new FUB implementation!!!
// define valid commands for this controller
FOR ii:= 0 TO (SIZEOF(CIf.Job.aCmdList)/SIZEOF(CIf.Job.aCmdList[0])-1) BY 1 DO
	IF (CIf.Job.aCmdList[ii].intCmd=cCMD_INITIALIZED) THEN
		// found first empty array element
		EXIT;
	END_IF
END_FOR

CIf.Job.aCmdList[ii].intCmd := cCMD_RUN;
CIf.Job.aCmdList[ii].strName := 'Run'; 
CIf.Job.aCmdList[ii].bolAvailable := TRUE;
ii := ii +1;
CIf.Job.aCmdList[ii].intCmd := cCMD_STOP;
CIf.Job.aCmdList[ii].strName := 'Stop'; 
CIf.Job.aCmdList[ii].bolAvailable := TRUE;
ii := ii +1;

// set name of class/typ
CIf.Info.strType := 'FB_CtrlModule'; 

// set alarm class
SIf_MOD.Alm[1].eAlmClass := E_AlmClass.STOP;
SIf_MOD.Alm[1].strText := 'Invalid pointer';
SIf_MOD.Alm[2].eAlmClass := E_AlmClass.OFF;
SIf_MOD.Alm[2].strText := 'Communication error to line control'; 
SIf_MOD.Alm[3].eAlmClass := E_AlmClass.EOFF;
SIf_MOD.Alm[3].strText := 'Emergency off active'; 
SIf_MOD.Alm[4].eAlmClass := E_AlmClass.OFF;
SIf_MOD.Alm[4].strText := 'General error active'; 
SIf_MOD.Alm[5].eAlmClass := E_AlmClass.OFF;
SIf_MOD.Alm[5].strText := 'Timeout start group '; 
SIf_MOD.Alm[6].eAlmClass := E_AlmClass.OFF;
SIf_MOD.Alm[6].strText := 'Timeout stop group '; 

//*******************************************************************************
// initial values
//*******************************************************************************
udinTimeToggle_ms := 0;
// software configuration
CIf.SwCfg.bolExist := TRUE;
CIf.SwCfg.bolSimulation := FALSE;

// No initialization for cfg and par in this base module!
// Pointer address of the property is not defined at this time]]></ST>
      </Implementation>
    </Method>
    <Method Name="getCmdState" Id="{a078c97a-5182-488f-8667-8079dd8856a0}">
      <Declaration><![CDATA[METHOD PROTECTED getCmdState : STRING
VAR_INPUT
	intCmdState: INT;
	bolState: BOOL;
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[getCmdState := SUPER^.getCmdState(intCmdState:=intCmdState,bolState:=bolState); // get global/base defined cmds/states
IF (getCmdState='') THEN // global not defined get local
	// get string cmd/state string information in runtime
	IF (bolState=FALSE) THEN
		// cmd's
	ELSE
	
	// cmd's
		CASE intCmdState OF	
			// SUB States
			cSTA_SUB_INITIALIZED:
				getCmdState := 'cSTA_SUB_INITIALIZED';
			cSTA_SUB_SEND_GROUP_CMD:
				getCmdState := 'cSTA_SUB_SEND_GROUP_CMD';
			cSTA_SUB_CHECK_GROUP_STATUS:
				getCmdState := 'cSTA_SUB_CHECK_GROUP_STATUS';
			cSTA_SUB_WAIT:
				getCmdState := 'cSTA_SUB_WAIT';
			cSTA_SUB_FINISHED:
				getCmdState := 'cSTA_SUB_FINISHED';
		END_CASE;
	END_IF
END_IF]]></ST>
      </Implementation>
    </Method>
    <Method Name="IoInBridge" Id="{d5e522c0-5c01-4e59-bbf1-ec4cea3e9421}">
      <Declaration><![CDATA[METHOD PROTECTED IoInBridge : BOOL
]]></Declaration>
      <Implementation>
        <ST><![CDATA[// Inputs from global module for general supervision (no physical inputs)
SIf_In^.bolEmergencyOffOk.map := THIS^.In_bolEmergencyOffOk;
SIf_In^.bolNoGeneralError.map := THIS^.In_bolNoGeneralError;

IF (CIf.SwCfg.bolSimulation = FALSE) THEN
	getInBol(CIf.Job.bolIoForce,ADR(SIf_In^.bolEmergencyOffOk));
	getInBol(CIf.Job.bolIoForce,ADR(SIf_In^.bolNoGeneralError));
ELSE
	//simulation of global IO
END_IF]]></ST>
      </Implementation>
    </Method>
    <Method Name="sta_OFF" Id="{78ed42c6-2949-4968-a527-66824914bda6}">
      <Declaration><![CDATA[METHOD PROTECTED sta_OFF : BOOL
]]></Declaration>
      <Implementation>
        <ST><![CDATA[// state implemetation
//--------------------------------------------------------------------------------------
// Entry action
	IF (me.StateMachine.intState<>me.StateMachine.intStateLastCycle) THEN
		me.StateMachine.intStateLastCycle := me.StateMachine.intState;
		;		
	END_IF

//--------------------------------------------------------------------------------------
// Cyclic action
	IF (me.StateMachine.intState=me.StateMachine.intStateLastCycle) THEN
				
		// State Change Condition
		IF (me.Alarm.eActivAlmClass<>E_AlmClass.EOFF) AND (me.Alarm.eActivAlmClass<>E_AlmClass.OFF) THEN
			IF (me.intCmd=cCMD_RUN) THEN 
				me.StateMachine.intStateNext := cSTA_RUNBusy;
			END_IF
		END_IF
	END_IF

//--------------------------------------------------------------------------------------
// Exit action
	IF (me.StateMachine.intState<>me.StateMachine.intStateNext) THEN
		;
	END_IF]]></ST>
      </Implementation>
    </Method>
    <Method Name="checkChildAlmClass" Id="{f7f92540-ee73-43a3-801d-c3b5a079914f}">
      <Declaration><![CDATA[METHOD checkChildAlmClass : BOOL
]]></Declaration>
      <Implementation>
        <ST><![CDATA[//------------------------------------------------------------------------------------------------------
// check child alarm classes
// set me alarm class active if at least one child has an EOFF
IF CheckAllChildAlmClass(E_AlmClass.EOFF) THEN
	CIf.Job.eMe_ActivAlmClass := E_AlmClass.EOFF;
	me.Alarm.bolfp := TRUE;
ELSIF CheckAllChildAlmClass(E_AlmClass.OFF) THEN
	CIf.Job.eMe_ActivAlmClass := E_AlmClass.OFF;
	me.Alarm.bolfp := TRUE;
ELSIF CheckAllChildAlmClass(E_AlmClass.STOP) THEN
	CIf.Job.eMe_ActivAlmClass := E_AlmClass.STOP;
	me.Alarm.bolfp := TRUE;
ELSIF CheckAllChildAlmClass(E_AlmClass.TSTOP) THEN
	CIf.Job.eMe_ActivAlmClass := E_AlmClass.TSTOP;
	me.Alarm.bolfp := TRUE;
ELSE
	IF (me.Alarm.bolfp) THEN
		CIf.Job.eMe_ActivAlmClass := E_AlmClass.NONE; // no reset necessary
		me.Alarm.bolfp := FALSE;
	END_IF
END_IF

//------------------------------------------------------------------------------------------------------
// set alarm class parent of childs
//------------------------------------------------------------------------------------------------------
// set alarm class parent of childs in the case of a parent EOFF or me=OFF or EOFF
IF (CIf.Job.eParent_ActivAlmClass=E_AlmClass.EOFF) THEN
	SetAllChildAlmClass(CIf.Job.eParent_ActivAlmClass);
ELSIF(CIf.Job.eMe_ActivAlmClass=E_AlmClass.EOFF) OR (CIf.Job.eMe_ActivAlmClass=E_AlmClass.OFF) THEN
	SetAllChildAlmClass(CIf.Job.eMe_ActivAlmClass);
ELSE
	// no important alarm for child active
	SetAllChildAlmClass(E_AlmClass.NONE);
END_IF]]></ST>
      </Implementation>
    </Method>
    <Method Name="StateMachine" Id="{78ea7042-a10b-4680-b2bd-6635a7f59840}">
      <Declaration><![CDATA[METHOD PROTECTED StateMachine : BOOL
]]></Declaration>
      <Implementation>
        <ST><![CDATA[SUPER^.StateMachine();

// main statemachine of base controller
CASE me.StateMachine.intState OF
	cSTA_RUN: 
        THIS^.sta_RUN();
    cSTA_RUNBusy: 
        THIS^.sta_RUNBusy();
	cSTA_STOP: 
        THIS^.sta_STOP();
    cSTA_STOPBusy: 
        THIS^.sta_STOPBusy();
END_CASE;]]></ST>
      </Implementation>
    </Method>
    <Method Name="IoOutBridge" Id="{a262f034-5c74-41ce-a298-1ca1a39b0a78}">
      <Declaration><![CDATA[METHOD PROTECTED IoOutBridge : BOOL
]]></Declaration>
      <Implementation>
        <ST><![CDATA[// digitale and analoge inputs read from hardware or forcing
IF (CIf.SwCfg.bolSimulation = FALSE) THEN
	// check interlocks to prevent damages
	IF (CIf.Job.bolIlkOverwrite=FALSE) THEN
	;
	END_IF
END_IF]]></ST>
      </Implementation>
    </Method>
    <Method Name="sta_EOFFBusy" Id="{48ff182a-3e28-4fcd-b00e-a593ec37e852}">
      <Declaration><![CDATA[METHOD PROTECTED sta_EOFFBusy : BOOL
]]></Declaration>
      <Implementation>
        <ST><![CDATA[// state implemetation
//--------------------------------------------------------------------------------------
// Entry action
	IF (me.StateMachine.intState<>me.StateMachine.intStateLastCycle) THEN
		me.StateMachine.intStateLastCycle := me.StateMachine.intState;
	END_IF

//--------------------------------------------------------------------------------------
// Cyclic action
	IF (me.StateMachine.intState=me.StateMachine.intStateLastCycle) THEN
		
		// In case of an emergency, set all childs to off 
		// Set in cyclic action because of possible errors or manual/auto changes!
		SUPER^.SetAllChildCmd(BASE_PLC.cCMD_OFF);

		// check if all childs have reached the state
		IF CheckAllChildState(cSTA_OFF) THEN
			me.StateMachine.intStateNext := cSTA_EOFF;
		END_IF
	END_IF

//--------------------------------------------------------------------------------------
// Exit action
	IF (me.StateMachine.intState<>me.StateMachine.intStateNext) THEN
		;
	END_IF]]></ST>
      </Implementation>
    </Method>
    <Method Name="sta_EOFF" Id="{d74d2413-2f21-47d2-9117-778c21ee4812}">
      <Declaration><![CDATA[METHOD PROTECTED sta_EOFF : BOOL
]]></Declaration>
      <Implementation>
        <ST><![CDATA[// state implemetation
//--------------------------------------------------------------------------------------
// Entry action
	IF (me.StateMachine.intState<>me.StateMachine.intStateLastCycle) THEN
		me.StateMachine.intStateLastCycle := me.StateMachine.intState;	
	END_IF

//--------------------------------------------------------------------------------------
// Cyclic action
	IF (me.StateMachine.intState=me.StateMachine.intStateLastCycle) THEN		
		
		// As long as the EMO is not reseted!
		IF NOT (SIf_In^.bolEmergencyOffOk.intern) THEN
			// Clear pending and new commands cyclic to prevent automatic recovery!
			CIf.Job.intACmd := BASE_PLC.cCMD_DONE;
			CIf.Job.intMCmd := BASE_PLC.cCMD_DONE;
		END_IF
	
		// State Change Condition
		IF (SIf_In^.bolEmergencyOffOk.intern) AND (me.Alarm.eActivAlmClass<>E_AlmClass.EOFF) AND (me.intCmd<>BASE_PLC.cCMD_EOFF) AND (me.intCmd<>BASE_PLC.cCMD_DONE) THEN
			me.StateMachine.intStateNext := cSTA_OFF;
		END_IF
	END_IF

//--------------------------------------------------------------------------------------
// Exit action
	IF (me.StateMachine.intState<>me.StateMachine.intStateNext) THEN
		;
	END_IF]]></ST>
      </Implementation>
    </Method>
    <Method Name="AddSeqChild" Id="{1b84a93c-c7a1-4f76-be20-3d0069bd1bd2}">
      <Declaration><![CDATA[METHOD AddSeqChild
VAR_INPUT
	stSequence: T_Sequence;
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[// Method add a sequence to list
IF (usiNumOfSeq <= (Base_Const.cMaxNrOfChilds-1)) THEN
	aListOfSeq[usiNumOfSeq].pChild:= stSequence.pChild;
	aListOfSeq[usiNumOfSeq].uinGroupRun:= stSequence.uinGroupRun;
	aListOfSeq[usiNumOfSeq].uinGroupStop:= stSequence.uinGroupStop;
	aListOfSeq[usiNumOfSeq].intCmdSeqRun:= stSequence.intCmdSeqRun;
	aListOfSeq[usiNumOfSeq].intStatusSeqRun:= stSequence.intStatusSeqRun;
	aListOfSeq[usiNumOfSeq].intStatusSeqRun2:= stSequence.intStatusSeqRun2;
	aListOfSeq[usiNumOfSeq].intCmdSeqStop:= stSequence.intCmdSeqStop;
	aListOfSeq[usiNumOfSeq].intStatusSeqStop:= stSequence.intStatusSeqStop;
	// Inc. number of sequence
	usiNumOfSeq:= usiNumOfSeq+1;
	// Check if the pointer is valid
	IF (stSequence.pChild<>0) THEN
		usiNumOfValidPointerSeqChild:= usiNumOfValidPointerSeqChild+1;
	END_IF
END_IF]]></ST>
      </Implementation>
    </Method>
    <Method Name="checkValidPointer" Id="{fb94e00e-ae6c-439e-8879-444057e7c248}">
      <Declaration><![CDATA[METHOD PROTECTED checkValidPointer : BOOL
]]></Declaration>
      <Implementation>
        <ST><![CDATA[IF (usiNumOfSeq = usiNumOfValidPointerSeqChild) AND (SIf_Cfg<>0) AND (SIf_Par<>0) AND (SIf_Cur<>0) AND (SIf_In<>0) THEN
	checkValidPointer:= TRUE;
ELSE
	// Invalid child pointer
	checkValidPointer:= FALSE;	
	// SIf.Alm[1].strText := 'Invalid pointer'; 
	pfbAlarmCtrl^.setAlarm(CIf.Info.intCtrlId,1,0,ADR(SIf_MOD.Alm),E_AlmState.RST,CIf.Job.eMe_ActivAlmClass);	
END_IF]]></ST>
      </Implementation>
    </Method>
    <Method Name="AddIBufferChilds" Id="{6d3d3899-c556-4128-90d2-dcc730ca6b35}">
      <Declaration><![CDATA[METHOD AddIBufferChilds
VAR_INPUT
	pFB_ChildTypeIBuffer: POINTER TO FB_IBuffer;
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[// Method add childs with type of IBuffer to the array
IF (usiNumOfIBufferChild <= (Base_Const.cMaxNrOfChilds-1)) THEN
	// Add child controller to list
	a_IBufferChildCtrl[usiNumOfIBufferChild] := pFB_ChildTypeIBuffer^;
	// Inc. number of IBuffer childs
	usiNumOfIBufferChild:= usiNumOfIBufferChild+1;
END_IF

]]></ST>
      </Implementation>
    </Method>
    <Method Name="sta_ERROR" Id="{049b8bc0-659f-4fd3-987e-7aa5067c18bc}">
      <Declaration><![CDATA[METHOD PROTECTED sta_ERROR : BOOL]]></Declaration>
      <Implementation>
        <ST><![CDATA[// state implemetation
//--------------------------------------------------------------------------------------
// Entry action
	IF (me.StateMachine.intState<>me.StateMachine.intStateLastCycle) THEN
		me.StateMachine.intStateHistory := me.StateMachine.intStateLastCycle; // -> possibillity to go back to state before error
		me.StateMachine.intStateLastCycle := me.StateMachine.intState;
		// Clear pending command to prevent automatic recovery!
		CIf.Job.intACmd:=cSTA_DONE;
		// In case on an error, set all childs to off
		SetAllChildCmd(cCMD_OFF);
	END_IF

//--------------------------------------------------------------------------------------
// Cyclic action
	IF (me.StateMachine.intState=me.StateMachine.intStateLastCycle) THEN
		
		;
		// State Change Condition
		IF ((CIf.Job.bolAlmReset = TRUE) AND (CheckAllChildState(cSTA_OFF))) THEN
			me.StateMachine.intStateNext := cSTA_ERRORQuit;
		END_IF
	END_IF

//--------------------------------------------------------------------------------------
// Exit action
	IF (me.StateMachine.intState<>me.StateMachine.intStateNext) THEN
		;
	END_IF]]></ST>
      </Implementation>
    </Method>
    <Method Name="AddIBufferFullChilds" Id="{3b96e4bd-8cae-49d2-8e00-8de38b5dc701}">
      <Declaration><![CDATA[METHOD AddIBufferFullChilds
VAR_INPUT
	pFB_ChildTypeIBuffer: POINTER TO FB_IBuffer;
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[// Method add childs with BufferFull information to the array
IF (usiNumOfIBufferFullChild <= (Base_Const.cMaxNrOfChilds-1)) THEN
	// Add child controller to list
	a_IBufferFullChildCtrl[usiNumOfIBufferFullChild] := pFB_ChildTypeIBuffer^;

	// Inc. number of IBufferFull childs
	usiNumOfIBufferFullChild:= usiNumOfIBufferFullChild+1;
END_IF

]]></ST>
      </Implementation>
    </Method>
    <Property Name="SIf_Cur" Id="{da09324d-d509-4c63-87a6-56489e58339e}">
      <Declaration><![CDATA[PROPERTY SIf_Cur : POINTER TO T_Ctrl_SIf_MOD_Cur]]></Declaration>
      <Get Name="Get" Id="{122ac4db-9666-4538-a1ba-0cded613e833}">
        <Declaration><![CDATA[]]></Declaration>
        <Implementation>
          <ST><![CDATA[SIf_Cur:= SIf_MOD.Cur; ]]></ST>
        </Implementation>
      </Get>
      <Set Name="Set" Id="{6ac1c127-3ff7-4378-bd04-b450f061c24a}">
        <Declaration><![CDATA[]]></Declaration>
        <Implementation>
          <ST><![CDATA[SIf_MOD.Cur := SIf_Cur; ]]></ST>
        </Implementation>
      </Set>
    </Property>
    <Property Name="SIf_Par" Id="{b5c66939-c58e-45c9-89fc-5cfc53253a6d}">
      <Declaration><![CDATA[PROPERTY SIf_Par : POINTER TO T_Ctrl_SIf_MOD_Par
]]></Declaration>
      <Get Name="Get" Id="{65982a28-7c19-4d53-b6bc-21b03191247e}">
        <Declaration><![CDATA[]]></Declaration>
        <Implementation>
          <ST><![CDATA[SIf_Par:= SIf_MOD.Par; ]]></ST>
        </Implementation>
      </Get>
      <Set Name="Set" Id="{69b18f07-6859-4618-97af-350fbaf7f176}">
        <Declaration><![CDATA[]]></Declaration>
        <Implementation>
          <ST><![CDATA[SIf_MOD.Par := SIf_Par; ]]></ST>
        </Implementation>
      </Set>
    </Property>
    <Property Name="SIf_Cfg" Id="{8f5b6bf3-c398-4c4d-9ed0-11a81c7b0dc3}">
      <Declaration><![CDATA[PROPERTY SIf_Cfg : POINTER TO T_Ctrl_SIf_MOD_Cfg
]]></Declaration>
      <Get Name="Get" Id="{64b93d81-accf-4579-a41d-a90868e6ef8e}">
        <Declaration><![CDATA[]]></Declaration>
        <Implementation>
          <ST><![CDATA[SIf_Cfg:= SIf_MOD.Cfg; ]]></ST>
        </Implementation>
      </Get>
      <Set Name="Set" Id="{b1367432-8208-4440-bda8-d3258dfc31dd}">
        <Declaration><![CDATA[]]></Declaration>
        <Implementation>
          <ST><![CDATA[SIf_MOD.Cfg := SIf_Cfg;]]></ST>
        </Implementation>
      </Set>
    </Property>
    <Property Name="SIf_In" Id="{7bbca7b5-ade5-48f3-a3a1-d7dc7310183d}">
      <Declaration><![CDATA[PROPERTY SIf_In : POINTER TO T_Ctrl_SIf_MOD_In]]></Declaration>
      <Get Name="Get" Id="{8d4dacfd-ad1a-4930-b902-02d093f97f43}">
        <Declaration><![CDATA[
]]></Declaration>
        <Implementation>
          <ST><![CDATA[SIf_In:= SIf_MOD.In; ]]></ST>
        </Implementation>
      </Get>
      <Set Name="Set" Id="{83cf6edb-9722-486e-85ab-0184a27fa079}">
        <Declaration><![CDATA[]]></Declaration>
        <Implementation>
          <ST><![CDATA[SIf_MOD.In := SIf_In;]]></ST>
        </Implementation>
      </Set>
    </Property>
    <ObjectProperties>﻿<XmlArchive>
  <Data>
    <o xml:space="preserve" t="POUImageProperty">
      <n n="ImageData" />
      <v n="TransparencyColor">"White"</v>
      <v n="MakeTransparent">false</v>
    </o>
  </Data>
  <TypeList>
    <Type n="Boolean">System.Boolean</Type>
    <Type n="POUImageProperty">{bb741845-1ec5-4be9-bb0d-2cf7058af574}</Type>
    <Type n="String">System.String</Type>
  </TypeList>
</XmlArchive></ObjectProperties>
  </POU>
</TcPlcObject>