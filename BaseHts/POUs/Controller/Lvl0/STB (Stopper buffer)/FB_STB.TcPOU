<TcPlcObject Version="1.1.0.1" ProductVersion="3.1.0.23">
  <POU Name="FB_STB" Id="{2c0e0df1-8c09-41f8-a0bd-c96c8ecb57b7}">
    <Declaration><![CDATA[FUNCTION_BLOCK FB_STB EXTENDS FB_CtrlBase IMPLEMENTS IBuffer
VAR_INPUT
	/// Sensor hanger detected
	In_bolHangerDetected: BOOL;
	/// Buffer full sensor
	In_bolBufferFull: BOOL;
	/// DecrementCounter Sensor (option)
	In_bolDecrementCounter: BOOL;
END_VAR
VAR_OUTPUT
	/// if bolRetract2 is not used  = 1 -> second pin up first pin (inlet) down
	Out_bolRetract: BOOL;
	/// = 1 -> second pin down (outlet)
	Out_bolRetract2: BOOL;
END_VAR
VAR
	/// Specific interface struct for public access
	SIf: T_Ctrl_SIf_STB;
	/// Internal Variables
	bolHangerDetected: BOOL;
	dinNumOfHangersToRelease: DINT;
	dinSetNumOfHangersToRelease: DINT;
	bolSensorBufferFull: BOOL;
	bolSensorHangerDetected: BOOL;
	bolBufferFullOld: BOOL;
	bolBufferFullSigCountOld: BOOL;
	/// Shadow copy of SIf.In.bolDecrementCounter.intern
	bolDecrementCountOld: BOOL;
	bolSignalForPosLostMonitoring: BOOL;
	bolSignalForPosLostMonitoringOld: BOOL;
	uinPosEdgeCounter: UINT;
	bolErrorPosLost: BOOL;
	fbTimerBufferFullSignal: TON;
	fbTimerHangerDetecSignal: TON;
	fbTimerHangerDeleteNoDetected: TON;
	/// Var. used for simulation
	bolRESimHangerIn: BOOL;
	/// Rising Edge Hanger go out
	bolRESimHangerOut: BOOL;
	/// Var. used for decrementing with sensor
	bolWaitForDecrement: BOOL;
	/// Copy of Output
	bolRetractOld: BOOL;
	///Last new position value from parent
	dinTransportPositionOld_um: DINT;
	///Position correction in faster Task cycletime
	dinPositionCorrection_um: DINT;
	/// [um] Calculated negative trigger offset 
	dinCalcTrigNegPosOffset_um: DINT;
	/// Loop variable
	intBufferIndex: INT;
END_VAR
VAR CONSTANT
	/// sub States for RELEASE_ALL Function
	cSTA_SUB_INITIALIZED: INT := 500;
	cSTA_SUB_HANGER_PASSING: INT := 502;
	cSTA_SUB_HANGER_PASSED: INT := 504;
	cSTA_SUB_FINISHED: INT := 506;
	cSTA_SUB_CHECK_FOR_RESERVATION: INT := 508;
	cSTA_SUB_RELEASE_BUSY: INT := 510;
	cSTA_SUB_STOP: INT := 512;
END_VAR
]]></Declaration>
    <Implementation>
      <ST><![CDATA[(*__________________________________________________________________________________________________
¦	
¦	Vistaprint Schweiz GmbH
¦	CH - 8401 Winterthur
¦
¦	www.vistaprint.ch - info@vistaprint.ch
¦___________________________________________________________________________________________________

Function desription:
The stopper buffer controller let pass hanger(s) with every pulse (retract/extend) of the pneumatic cylinder.
This controller can be used for the following units: Separator, Double stopper and Single stopper.

Note:  With the given sensors it's not possible to detect exactly one hanger per sensor pulse to inc. the number of hangers in buffer.
       Means that all calculated values ​​are only approximate.

History:
Version		Date			Author		Comment
---------------------------------------------------------------------------------------------------
0.00.1		22.08.2013		AVME/PRE	Start history
0.00.2		29.08.2013		AVME/DSC	Integration of all separator basic functionalities
0.00.3		30.08.2013		AVME/DSC	Integration monitoring cylinder position lost in state STOP.
0.00.4      09.09.2013      AVME/DSC    Generate signal "hanger detected". In case if only buffer full sensor exist, 
										use number of hangers to generate hanger detection signal.
										Renaming FUB "FB_SEP" to "FB_STB". Decided by Rolf and PRE.
0.00.5		19.09.2013		AVME/PRE	Limit Counter to max capacity if higher as max capacity
0.00.6		19.09.2013		AVME/PRE	Implement new Base Concept
0.00.7		26.09.2013		AVME/KVO	- Add new output for douplestopper with two valves
										- Add new config bolReleaseAllNonPulse -> to release all over time 
											-> new par udiReleaseAllTime_ms: UDINT;
										- calculation of hangers corrected
										- if hanger dtedction sensor detects a hanger and buffer is 0 -> set 1 always
										-  max number of hangers detected in STOP if bolCylPosLostMonitoring activated until an error occures
											uinMaxNumOfHangers_PosMonitoring
										- info buffer full and hanger detected removed - not necessary
0.00.8		27.09.2013		AVME/DSC	Modification for error condition of hanger position lost monitoring.										
0.00.9		02.10.2013		AVME/DSC	Modification set number of hangers in buffer to max. capacity if buffer full signal detected.
0.00.10		07.10.2013		AVME/DSC    Modification in always action. If buffer full detected, number of hangers in buffer must be always set to max. capacity.
0.00.11		09.10.2013		VP/RE		Only decrease dinNumOfHangersInBuffer when is NOT full (but only if full sensor is available)
0.00.12		07.11.2013		AVME/MRU	Add debounced inputs and configuration with bolHasDecrementSensor
0.00.13		03.12.2013		AVME/MRU	Add MaxCapacity / NumOfHangers properties
0.00.14		12.12.2013		AVME/MRU	Bug fixed with decrement sensor, Min. Limit of dinNumOfHangersInBuffer = 0;
										Add bolDisableBufferDelete for preventing deleting buffer count 
0.00.15		17.12.2013		AVME/MRU	sta_Release_AllBusy Buffermode=0, Bug fixed
										Code review, some comments changed
0.00.16		10.01.2014		AVME/MRU	Bugzilla ID 55: Limitation of dinNumOfHangersInBuffer reworked
										Bug in Simulation resolved
0.00.17		13.01.2014		AVME/MRU	Bugzilla ID 03: BufferFull for LineControl added
0.00.18		28.04.2014		AVME/DSC	Inserted new states RUNBusy and RUN. Used if STB works in combination with FB_MTR.	

___________________________________________________________________________________________*)


IF (me.bolActivate) THEN // cyclic call enabled
	IF (CIf.Info.bolInitDone=FALSE) THEN // first cycle -> init
		CtrlInit();
		CIf.Info.bolInitDone := TRUE;
	ELSE
		CycleStartDuty();
	
		Always();
		
		StateMachine();
		
		CycleEndDuty();
	END_IF
END_IF;
]]></ST>
    </Implementation>
    <Property Name="BufferFull" Id="{02284bae-b0f7-4a3a-834f-eefb1f826051}">
      <Declaration><![CDATA[PROPERTY BufferFull : BOOL
]]></Declaration>
      <Get Name="Get" Id="{7e5bfe22-a6d6-4c42-bc48-1c9a217e37c2}">
        <Declaration><![CDATA[]]></Declaration>
        <Implementation>
          <ST><![CDATA[BufferFull:= SIf.Cur.bolBufferFull;]]></ST>
        </Implementation>
        <ObjectProperties />
      </Get>
      <ObjectProperties />
    </Property>
    <Method Name="sta_RELEASE_ALL" Id="{0695e32c-02f5-48c8-b73b-3f463f88cf33}">
      <Declaration><![CDATA[METHOD PROTECTED sta_RELEASE_ALL : BOOL
]]></Declaration>
      <Implementation>
        <ST><![CDATA[// state implemetation
//--------------------------------------------------------------------------------------
// Entry action
	IF (me.StateMachine.intState<>me.StateMachine.intStateLastCycle) THEN
		me.StateMachine.intStateLastCycle := me.StateMachine.intState;	
		;
	END_IF

//--------------------------------------------------------------------------------------
// Cyclic action
	IF (me.StateMachine.intState=me.StateMachine.intStateLastCycle) THEN
		

		// State Change Condition
		IF ((me.intCmd=cCMD_STOP) OR (me.intCmd=STB_CmdState.cCMD_RELEASE)) THEN
			me.StateMachine.intStateNext := cSTA_STOPBusy;
		END_IF
	END_IF

//--------------------------------------------------------------------------------------
// Exit action
	IF (me.StateMachine.intState<>me.StateMachine.intStateNext) THEN
		;
	END_IF]]></ST>
      </Implementation>
      <ObjectProperties />
    </Method>
    <Method Name="sta_STOPBusy" Id="{088b1a7b-32dc-4c78-9a4a-516f95b15a9f}">
      <Declaration><![CDATA[METHOD PROTECTED sta_STOPBusy : BOOL
]]></Declaration>
      <Implementation>
        <ST><![CDATA[// state implemetation
//--------------------------------------------------------------------------------------
// Entry action
	IF (me.StateMachine.intState<>me.StateMachine.intStateLastCycle) THEN
		me.StateMachine.intStateLastCycle := me.StateMachine.intState;

	END_IF


//--------------------------------------------------------------------------------------
// Cyclic action
	IF (me.StateMachine.intState=me.StateMachine.intStateLastCycle) THEN
			
		// Switch valve off, cylinder back to extend position -> stop hanger
		SIf.Out.bolRetract.intern := FALSE;
		SIf.Out.bolRetract2.intern := TRUE;	
				
		// State Change Condition
		IF (me.StateMachine.udiTimeInState_ms > SIf.Par.udiPulseLengthValve_ms) THEN
			me.StateMachine.intStateNext := cSTA_STOP;
		END_IF
	END_IF


//--------------------------------------------------------------------------------------
// Exit action
	IF (me.StateMachine.intState<>me.StateMachine.intStateNext) THEN
		;
	END_IF]]></ST>
      </Implementation>
      <ObjectProperties />
    </Method>
    <Method Name="getCtrlSIf" Id="{15f5c180-a2b3-495e-b78f-09cae671113b}">
      <Declaration><![CDATA[METHOD getCtrlSIf : POINTER TO T_Ctrl_SIf_STB
]]></Declaration>
      <Implementation>
        <ST><![CDATA[getCtrlSIf := ADR(SIf);]]></ST>
      </Implementation>
      <ObjectProperties />
    </Method>
    <Method Name="sta_STOP" Id="{18e0f5bc-2ce1-4277-9ce8-609e3e93faca}">
      <Declaration><![CDATA[METHOD PROTECTED sta_STOP : BOOL
]]></Declaration>
      <Implementation>
        <ST><![CDATA[// state implemetation
//--------------------------------------------------------------------------------------
// Entry action
	IF (me.StateMachine.intState<>me.StateMachine.intStateLastCycle) THEN
		me.StateMachine.intStateLastCycle := me.StateMachine.intState;
		
		bolErrorPosLost:= FALSE;
		uinPosEdgeCounter:= 0;
	END_IF


//--------------------------------------------------------------------------------------
// Cyclic action
	IF (me.StateMachine.intState=me.StateMachine.intStateLastCycle) THEN
	
		//--------------------------------------------------------------------
		// Monitoring for cylinder position lost
		//--------------------------------------------------------------------
		IF (Sif.cfg.bolCylPosLostMonitoring=TRUE) THEN
			
			// -> Checked indirectly via sensor "buffer full" or "hanger detected" if exist.
			
			// Decision, which sensor should be used for monitoring
			// Prio 1. Always use the hanger detection sensor if exists
			IF (SIf.Cfg.bolHasHangerDetection = TRUE) THEN
				// Use hanger detection sensor signal
				bolSignalForPosLostMonitoring:= SIf.In.bolHangerDetected.intern;
			ELSE
				// Prio 2. Check if buffer full sensor exists 
				IF (SIf.Cfg.bolHasBufferFullSensor = TRUE) THEN
					// Use buffer full sensor signal
					bolSignalForPosLostMonitoring:= SIf.In.bolBufferFull.intern;
				ELSE
					// No sensor exist. Not possible to monitor cylinder position lost! 
					bolSignalForPosLostMonitoring:= FALSE;
				END_IF
			END_IF
				
			// Count sensor pos. edges
			IF ((bolSignalForPosLostMonitoring <> bolSignalForPosLostMonitoringOld) AND (bolSignalForPosLostMonitoring = TRUE))THEN	
				uinPosEdgeCounter:= uinPosEdgeCounter + 1;
			END_IF
			bolSignalForPosLostMonitoringOld:= bolSignalForPosLostMonitoring;
						
			// Check condition for set error
			// Wait until the counter is > than dinMaxNumOfHangers_PosMonitoring
			IF (uinPosEdgeCounter > SIf.Cfg.dinMaxNumOfHangers_PosMonitoring) THEN
				bolErrorPosLost:= TRUE;
			END_IF
			
		END_IF
		
		//--------------------------------------------------------------------
		//--------------------------------------------------------------------
		
		// State Change Condition	
		// Error cylinder position lost
		IF ((bolErrorPosLost=TRUE) AND (Sif.cfg.bolCylPosLostMonitoring=TRUE))THEN
			// SIf.Alm[3].strText := 'Cylinder position lost. Hangers slip through';
			pfbAlarmCtrl^.setAlarm(CIf.Info.intCtrlId,3,0,ADR(SIf.Alm),E_AlmState.RST,CIf.Job.eMe_ActivAlmClass);
			bolErrorPosLost:= FALSE;
			uinPosEdgeCounter:= 0;
			me.StateMachine.intStateNext := cSTA_ERROR;
		ELSIF (me.intCmd=STB_CmdState.cCMD_RELEASE) THEN 
			me.StateMachine.intStateNext := STB_CmdState.cSTA_RELEASEBusy;
		ELSIF(me.intCmd=STB_CmdState.cCMD_RELEASE_ALL) THEN
			me.StateMachine.intStateNext := STB_CmdState.cSTA_RELEASE_ALLBusy;
		ELSIF (me.intCmd=cCMD_RUN) THEN
			me.StateMachine.intStateNext := cSTA_RUNBusy;
		END_IF
	END_IF

//-------------------------------------------------------------------------------------
// Exit action
	IF (me.StateMachine.intState<>me.StateMachine.intStateNext) THEN
		;
	END_IF]]></ST>
      </Implementation>
      <ObjectProperties />
    </Method>
    <Method Name="sta_RELEASE" Id="{1da0ee01-0cdc-4e7f-9127-89d072bd7bce}">
      <Declaration><![CDATA[METHOD PROTECTED sta_RELEASE : BOOL
]]></Declaration>
      <Implementation>
        <ST><![CDATA[// state implemetation
//--------------------------------------------------------------------------------------
// Entry action
	IF (me.StateMachine.intState<>me.StateMachine.intStateLastCycle) THEN
		me.StateMachine.intStateLastCycle := me.StateMachine.intState;
			
		;
	END_IF

//--------------------------------------------------------------------------------------
// Cyclic action
	IF (me.StateMachine.intState=me.StateMachine.intStateLastCycle) THEN
		
		// Switch valve off, cylinder back to extend position -> stop hanger
		SIf.Out.bolRetract.intern := FALSE;
		SIf.Out.bolRetract2.intern := TRUE;	
		
		// State Change Condition
		IF (me.intCmd=cCMD_STOP) THEN
			me.StateMachine.intStateNext := cSTA_STOPBusy;
		ELSIF(me.intCmd=STB_CmdState.cCMD_RELEASE_ALL) THEN
			me.StateMachine.intStateNext := STB_CmdState.cSTA_RELEASE_ALLBusy;
		END_IF
		
	END_IF

//--------------------------------------------------------------------------------------
// Exit action
	IF (me.StateMachine.intState<>me.StateMachine.intStateNext) THEN
		;
	END_IF]]></ST>
      </Implementation>
      <ObjectProperties />
    </Method>
    <Property Name="MaxCapacity" Id="{1e6304d1-0221-44bd-a956-b9950d6623bc}">
      <Declaration><![CDATA[PROPERTY MaxCapacity : DINT
]]></Declaration>
      <Get Name="Get" Id="{96f5bfb5-fb4d-48e4-b8a7-cb03a42f5e7d}">
        <Declaration><![CDATA[]]></Declaration>
        <Implementation>
          <ST><![CDATA[MaxCapacity:= SIf.Cfg.dinMaxCapacity;]]></ST>
        </Implementation>
        <ObjectProperties />
      </Get>
      <ObjectProperties />
    </Property>
    <Method Name="getCmdState" Id="{2bdf6a61-a73b-4fe4-b312-0c81796df710}">
      <Declaration><![CDATA[METHOD PROTECTED getCmdState : STRING
VAR_INPUT
	intCmdState: INT;
	bolState: BOOL;
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[getCmdState := SUPER^.getCmdState(intCmdState:=intCmdState,bolState:=bolState); // get global/base defined cmds/states
IF (getCmdState='') THEN // global not defined get local
	// get string cmd/state string information in runtime
	IF (bolState=FALSE) THEN
		// cmd's
		CASE intCmdState OF
			STB_CmdState.cCMD_RELEASE_ALL: 
				getCmdState := 'cCMD_RELEASE_ALL';
			STB_CmdState.cCMD_RELEASE: 
				getCmdState := 'cCMD_RELEASE';
		END_CASE;
	ELSE
	
	// states
		CASE intCmdState OF
			STB_CmdState.cSTA_RELEASE_ALLBusy: 
				getCmdState := 'cSTA_RELEASE_ALLBusy';
			STB_CmdState.cSTA_RELEASE_ALL: 
				getCmdState := 'cSTA_RELEASE_ALL';
			STB_CmdState.cSTA_RELEASEBusy: 
				getCmdState := 'cSTA_RELEASEBusy';
			STB_CmdState.cCMD_RELEASE: 
				getCmdState := 'cCMD_RELEASE';
		
			// SUB States
			cSTA_SUB_INITIALIZED:
				getCmdState := 'cSTA_SUB_INITIALIZED';
			cSTA_SUB_HANGER_PASSING:
				getCmdState := 'cSTA_SUB_HANGER_PASSING';
			cSTA_SUB_HANGER_PASSED:
				getCmdState := 'cSTA_SUB_HANGER_PASSED';
			cSTA_SUB_FINISHED:
				getCmdState := 'cSTA_SUB_FINISHED';				
			cSTA_SUB_CHECK_FOR_RESERVATION:
				getCmdState := 'cSTA_SUB_CHECK_FOR_RESERVATION';			
			cSTA_SUB_RELEASE_BUSY:
				getCmdState := 'cSTA_SUB_RELEASE_BUSY';		
			cSTA_SUB_STOP:
				getCmdState := 'cSTA_SUB_STOP';	
													
		END_CASE;
	END_IF
END_IF
]]></ST>
      </Implementation>
      <ObjectProperties />
    </Method>
    <Method Name="sta_OFFBusy" Id="{306326e6-a0b7-46fa-b764-cc316669bf70}">
      <Declaration><![CDATA[METHOD PROTECTED sta_OFFBusy : BOOL
]]></Declaration>
      <Implementation>
        <ST><![CDATA[// state implemetation
//--------------------------------------------------------------------------------------
// Entry action
	IF (me.StateMachine.intState<>me.StateMachine.intStateLastCycle) THEN
		me.StateMachine.intStateLastCycle := me.StateMachine.intState;
			
	END_IF

//--------------------------------------------------------------------------------------
// Cyclic action
	IF (me.StateMachine.intState=me.StateMachine.intStateLastCycle) THEN
		
		// Switch valve off, cylinder back to extend position -> stop hanger
		SIf.Out.bolRetract.intern := FALSE;
		SIf.Out.bolRetract2.intern := TRUE;	
			
		// State Change Condition
		IF (FALSE) THEN
			;
		ELSIF (TRUE) THEN
			me.StateMachine.intStateNext := cSTA_OFF;
		END_IF
	END_IF


//--------------------------------------------------------------------------------------
// Exit action
	IF (me.StateMachine.intState<>me.StateMachine.intStateNext) THEN
		;
	END_IF]]></ST>
      </Implementation>
      <ObjectProperties />
    </Method>
    <Method Name="sta_RELEASEBusy" Id="{395698e3-6919-4c84-a482-a281905ef5ac}">
      <Declaration><![CDATA[METHOD PROTECTED sta_RELEASEBusy : BOOL
]]></Declaration>
      <Implementation>
        <ST><![CDATA[// state implemetation
//--------------------------------------------------------------------------------------
// Entry action
	IF (me.StateMachine.intState<>me.StateMachine.intStateLastCycle) THEN
		me.StateMachine.intStateLastCycle := me.StateMachine.intState;

		// Check if min. one hanger exist and save info tmp. Used for counting in state RELEASE.	
		IF (SIf.In.bolHangerDetected.intern = TRUE) THEN
			bolHangerDetected:= TRUE;
		ELSE
			bolHangerDetected:= FALSE;
		END_IF
	
	END_IF

//--------------------------------------------------------------------------------------
// Cyclic action
	IF (me.StateMachine.intState=me.StateMachine.intStateLastCycle) THEN
		
		// Switch valve on, cylinder to retract position -> release hanger
		SIf.Out.bolRetract.intern := TRUE;
		SIf.Out.bolRetract2.intern := FALSE;	
		
		// State Change Condition
		IF (me.StateMachine.udiTimeInState_ms > SIf.Par.udiPulseLengthValve_ms) THEN
			me.StateMachine.intStateNext := STB_CmdState.cSTA_RELEASE;
	
			// Update all counters. Only if a hanger was detected before.
			// If no hanger detection sensor exists, count unconditional with every cylinder stroke
			IF (bolHangerDetected = TRUE) OR (SIf.Cfg.bolHasHangerDetection = FALSE) THEN
				
				// Note: Only for separator the number of hangers per pulse corresponds exactly the real number of passed hangers.
				// For all other units like e.g. double stopper it's only an approximate number.
			
				IF (SIf.Cfg.bolHasDecrementSensor = FALSE) THEN // Else do it in Method Always
					IF (SIf.Cfg.bolHasBufferFullSensor = TRUE AND SIf.In.bolBufferFull.intern = FALSE) THEN
						// Calculate number of hangers in buffer dependent number of hangers per pulse
						SIf.Cur.dinNumOfHangersInBuffer:= SIf.Cur.dinNumOfHangersInBuffer - dinNumOfHangersToRelease;
					ELSIF SIf.Cfg.bolHasBufferFullSensor = FALSE THEN
						// Calculate number of hangers in buffer dependent number of hangers per pulse
						SIf.Cur.dinNumOfHangersInBuffer:= SIf.Cur.dinNumOfHangersInBuffer - dinNumOfHangersToRelease;						
					END_IF
				END_IF
					
				// Calculate total counter dependent number of hangers per pulse
				SIf.Cur.dinHangersPassedTotal:= SIf.Cur.dinHangersPassedTotal + dinNumOfHangersToRelease;
				
				bolHangerDetected:= FALSE;
			END_IF
				
		END_IF
		
	END_IF

//--------------------------------------------------------------------------------------
// Exit action
	IF (me.StateMachine.intState<>me.StateMachine.intStateNext) THEN
		;
	END_IF]]></ST>
      </Implementation>
      <ObjectProperties />
    </Method>
    <Method Name="sta_ERROR" Id="{5d0a2b8f-1244-4216-9fec-4f419e65b64a}">
      <Declaration><![CDATA[METHOD PROTECTED sta_ERROR : BOOL
]]></Declaration>
      <Implementation>
        <ST><![CDATA[// state implemetation
//--------------------------------------------------------------------------------------
// Entry action
	IF (me.StateMachine.intState<>me.StateMachine.intStateLastCycle) THEN
		me.StateMachine.intStateHistory := me.StateMachine.intStateLastCycle; // -> possibillity to go back to state before error
		me.StateMachine.intStateLastCycle := me.StateMachine.intState;
		
	END_IF

//--------------------------------------------------------------------------------------
// Cyclic action
	IF (me.StateMachine.intState=me.StateMachine.intStateLastCycle) THEN
		
		// Switch valve off, cylinder back to extend position -> stop hanger
		SIf.Out.bolRetract.intern := FALSE;
		SIf.Out.bolRetract2.intern := TRUE;	
		
		// State Change Condition
		IF (CIf.Job.bolAlmReset = TRUE) THEN
			me.StateMachine.intStateNext := cSTA_ERRORQuit;
		END_IF
	END_IF

//--------------------------------------------------------------------------------------
// Exit action
	IF (me.StateMachine.intState<>me.StateMachine.intStateNext) THEN
		;
	END_IF]]></ST>
      </Implementation>
      <ObjectProperties />
    </Method>
    <Method Name="StateMachine" Id="{6e79d84e-f7c9-45ea-9c1b-3ad4cd70559c}">
      <Declaration><![CDATA[METHOD PROTECTED StateMachine : BOOL
]]></Declaration>
      <Implementation>
        <ST><![CDATA[SUPER^.StateMachine();

// main statemachine of base controller
CASE me.StateMachine.intState OF
	cSTA_RUNBusy: 
        THIS^.sta_RUNBusy();
    cSTA_RUN: 
        THIS^.sta_RUN();
    cSTA_STOPBusy: 
        THIS^.sta_STOPBusy();
    cSTA_STOP: 
        THIS^.sta_STOP();
    STB_CmdState.cSTA_RELEASE_ALLBusy: 
        THIS^.sta_RELEASE_ALLBusy();
    STB_CmdState.cSTA_RELEASE_ALL: 
        THIS^.sta_RELEASE_ALL();
    STB_CmdState.cSTA_RELEASEBusy: 
        THIS^.sta_RELEASEBusy();
    STB_CmdState.cSTA_RELEASE: 
        THIS^.sta_RELEASE();
END_CASE;


]]></ST>
      </Implementation>
      <ObjectProperties />
    </Method>
    <Method Name="sta_RUN" Id="{744bfd93-ce22-4ca3-812f-c4f1ba7e6668}">
      <Declaration><![CDATA[METHOD PROTECTED sta_RUN : BOOL
]]></Declaration>
      <Implementation>
        <ST><![CDATA[// state implemetation
//--------------------------------------------------------------------------------------
// Entry action
	IF (me.StateMachine.intState<>me.StateMachine.intStateLastCycle) THEN
		me.StateMachine.intStateLastCycle := me.StateMachine.intState;
		
		// Init sub state machine	
		me.SubStateMachine.intState := cSTA_SUB_CHECK_FOR_RESERVATION; 
		me.SubStateMachine.intStateNext := cSTA_SUB_CHECK_FOR_RESERVATION; 
	END_IF

//--------------------------------------------------------------------------------------
// Cyclic action
	IF (me.StateMachine.intState=me.StateMachine.intStateLastCycle) THEN
		
		//----------------------------------------------------------------------
		// Calculate position for transport 
		//----------------------------------------------------------------------	
		// If this task is in faster cycle then the parent, calculate internal position more exactly during the taskcycle
		IF dinTransportPositionOld_um <> SIf.Cur.dinTransportPosition_um THEN
			SIf.Cur.dinTransportPositionCalc_um := SIf.Cur.dinTransportPosition_um;
			dinTransportPositionOld_um := SIf.Cur.dinTransportPosition_um;
			dinPositionCorrection_um := 0;
		ELSE
			dinPositionCorrection_um := dinPositionCorrection_um + LREAL_TO_DINT(DINT_TO_LREAL(SIf.Cur.dinTransportspeed_um_s) * UDINT_TO_LREAL(me.FUBInfo.udiSample_ms) / 1000.0 );
			SIf.Cur.dinTransportPositionCalc_um := dinTransportPositionOld_um + dinPositionCorrection_um;
		END_IF
				
		//--------------------------------------------------------------------------------------
		// sub state machine
		CASE me.SubStateMachine.intState OF
			//--------------------------------------------------------------------------------------
			cSTA_SUB_CHECK_FOR_RESERVATION:
			
				IF (me.SubStateMachine.intState<>me.SubStateMachine.intStateLastCycle) THEN
					me.SubStateMachine.intStateLastCycle := me.SubStateMachine.intState;
					;
				END_IF
			
				// Simulation
				IF (CIf.SwCfg.bolSimulation) THEN
					;
				END_IF
							
				// Calculate trigger "negative" position offset.
				// Note: The trigger offset must be calculated dependent the drive (transport) speed 
				// Formular: TrigNegPosOffset = DriveSpeed * TimeOnSlide	
				dinCalcTrigNegPosOffset_um:= REAL_TO_DINT (DINT_TO_REAL(SIf.Cur.dinTransportspeed_um_s) * (UINT_TO_REAL(SIf.Par.uinTimeOnSlide_ms) / 1000));
					
				// Check trigger window
				FOR intBufferIndex := 0 TO Const_MTR.cusiSectionBuffer_SIZE DO
					// Check if the current transport position is within the trigger window and if section is reserved for this instance to release the hanger
					IF ((SIf.Par.dinPositionOfSlide_um < (SIf.Cur.pSectionBuffer^[intBufferIndex].dinTrigStartPos - dinCalcTrigNegPosOffset_um))
						AND (SIf.Par.dinPositionOfSlide_um > (SIf.Cur.pSectionBuffer^[intBufferIndex].dinTrigEndPos - dinCalcTrigNegPosOffset_um))
						AND (SIf.Cur.pSectionBuffer^[intBufferIndex].enmState = E_Typ_MTR_SECTION_STATE.Reserved) AND (SIf.Cur.pSectionBuffer^[intBufferIndex].usiReservedForLine = SIf.Cfg.usiLineNumber)) THEN						
							// Section is free and reserved for this instance -> hanger can be released!
							// Update status for the section
							SIf.Cur.pSectionBuffer^[intBufferIndex].enmState := E_Typ_MTR_SECTION_STATE.HangerOnSlide;
							me.SubStateMachine.intStateNext := cSTA_SUB_RELEASE_BUSY;
							EXIT;
					END_IF
				END_FOR					
				
			//--------------------------------------------------------------------------------------
			cSTA_SUB_RELEASE_BUSY:
				IF (me.SubStateMachine.intState<>me.SubStateMachine.intStateLastCycle) THEN
					me.SubStateMachine.intStateLastCycle := me.SubStateMachine.intState;
					;
				END_IF
			
				// Switch valve on, cylinder to retract position -> release hanger
				SIf.Out.bolRetract.intern := TRUE;
				
				// State Change Condition
				IF (me.SubStateMachine.udiTimeInState_ms > SIf.Par.udiPulseLengthValve_ms) THEN
					// Next step
					me.SubStateMachine.intStateNext := cSTA_SUB_STOP;
			
					// Update all counters. Only if a hanger was detected before.
					// If no hanger detection sensor exists, count unconditional with every cylinder stroke
					IF (SIf.In.bolHangerDetected.intern = TRUE) OR (SIf.Cfg.bolHasHangerDetection = FALSE) THEN
						
						// Note: Only for separator the number of hangers per pulse corresponds exactly the real number of passed hangers.
						// For all other units like e.g. double stopper it's only an approximate number.
					
						IF (SIf.Cfg.bolHasDecrementSensor = FALSE) THEN // Else do it in Method Always
							IF (SIf.Cfg.bolHasBufferFullSensor = TRUE AND SIf.In.bolBufferFull.intern = FALSE) THEN
								// Calculate number of hangers in buffer dependent number of hangers per pulse
								SIf.Cur.dinNumOfHangersInBuffer:= SIf.Cur.dinNumOfHangersInBuffer - dinNumOfHangersToRelease;
							ELSIF SIf.Cfg.bolHasBufferFullSensor = FALSE THEN
								// Calculate number of hangers in buffer dependent number of hangers per pulse
								SIf.Cur.dinNumOfHangersInBuffer:= SIf.Cur.dinNumOfHangersInBuffer - dinNumOfHangersToRelease;						
							END_IF
						END_IF						
						// Calculate total counter dependent number of hangers per pulse
						SIf.Cur.dinHangersPassedTotal:= SIf.Cur.dinHangersPassedTotal + dinNumOfHangersToRelease;		
					END_IF
						
				END_IF
			
			//--------------------------------------------------------------------------------------
			cSTA_SUB_STOP:
				IF (me.SubStateMachine.intState<>me.SubStateMachine.intStateLastCycle) THEN
					me.SubStateMachine.intStateLastCycle := me.SubStateMachine.intState;
				END_IF
				
				// Update status for the section
				SIf.Cur.pSectionBuffer^[intBufferIndex].enmState := E_Typ_MTR_SECTION_STATE.HangerReleased;
				// Switch valve off, cylinder back to extend position -> stop hanger
				SIf.Out.bolRetract.intern := FALSE;
			
				// State Change Condition
				// Check error if retracted position not reached
				IF (TRUE) THEN
					me.SubStateMachine.intStateNext := cSTA_SUB_CHECK_FOR_RESERVATION;
				END_IF
		
			
		END_CASE
		
		// State Change Condition
		IF(me.intCmd=cCMD_STOP) THEN
			me.StateMachine.intStateNext := cSTA_STOPBusy;	
		END_IF
		
	END_IF

//--------------------------------------------------------------------------------------
// Exit action
	IF (me.StateMachine.intState<>me.StateMachine.intStateNext) THEN
	;
	END_IF]]></ST>
      </Implementation>
      <ObjectProperties />
    </Method>
    <Method Name="FB_init" Id="{767e6c56-3317-494a-8aba-d6cc72d16a31}">
      <Declaration><![CDATA[METHOD FB_init : BOOL
VAR_INPUT
	///if TRUE, the retain variables are initialized (warm start / cold start)
	bInitRetains: BOOL;
	///if TRUE, the instance afterwards gets moved into the copy code (online change)
	bInCopyCode: BOOL;
END_VAR
VAR
	ii: UINT;
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[//------------------------------------------------------------------------------------------------------------------------
// to manually change in new FUB implementation!!!
// define valid commands for this controller
FOR ii:= 0 TO (SIZEOF(CIf.Job.aCmdList)/SIZEOF(CIf.Job.aCmdList[0])-1) BY 1 DO
	IF (CIf.Job.aCmdList[ii].intCmd=cCMD_INITIALIZED) THEN
		// found first empty array element
		EXIT;
	END_IF
END_FOR

CIf.Job.aCmdList[ii].intCmd := cCMD_STOP;
CIf.Job.aCmdList[ii].strName := 'Stop'; 
CIf.Job.aCmdList[ii].bolAvailable := TRUE;
ii := ii +1;
CIf.Job.aCmdList[ii].intCmd := STB_CmdState.cCMD_RELEASE_ALL;
CIf.Job.aCmdList[ii].strName := 'Release All';
CIf.Job.aCmdList[ii].bolAvailable := TRUE;
ii := ii +1;
CIf.Job.aCmdList[ii].intCmd := STB_CmdState.cCMD_RELEASE;
CIf.Job.aCmdList[ii].strName := 'Release';
CIf.Job.aCmdList[ii].bolAvailable := TRUE;
ii := ii +1;
CIf.Job.aCmdList[ii].intCmd := cCMD_RUN;
CIf.Job.aCmdList[ii].strName := 'Run';
CIf.Job.aCmdList[ii].bolAvailable := TRUE;

// set name of class/typ
CIf.Info.strType := 'FB_STB'; 

// set alarm class
SIf.Alm[1].eAlmClass := E_AlmClass.STOP;
SIf.Alm[1].strText := 'Timeout buffer emptying';
SIf.Alm[2].eAlmClass := E_AlmClass.STOP;
SIf.Alm[2].strText := 'interlock retract - movement stopped';
SIf.Alm[3].eAlmClass := E_AlmClass.STOP;
SIf.Alm[3].strText := 'Cylinder position lost. Hangers slip through';
SIf.Alm[4].eAlmClass := E_AlmClass.OFF;
SIf.Alm[4].strText := 'RUN not possible, no access to section buffer';


//*******************************************************************************
// initial values
//*******************************************************************************

// software configuration
CIf.SwCfg.bolExist := TRUE;
CIf.SwCfg.bolSimulation := FALSE;

// parameter
SIf.Par.udiIntervalBufferEmptying_ms := 2000;
SIf.Par.udiPulseLengthValve_ms := 500;
SIf.Par.udiSensorTime_ms := 3000;
SIf.Par.udiTimeoutBufferEmptying_ms := 120000; // 2 min
SIf.Par.usiBuffermode := 1;
SIf.Par.udiReleaseAllTime_ms := 4000;
Sif.par.udiDebounceTime_ms:= 20;
SIf.Par.uinTimeOnSlide_ms:= 1000;

// configuration
SIf.Cfg.bolHasBufferFullSensor := FALSE;
SIf.Cfg.bolHasHangerDetection:= TRUE;
SIf.Cfg.bolHasDecrementSensor:= FALSE;
SIf.Cfg.bolDisableBufferDelete:= FALSE;
SIf.Cfg.dinMaxCapacity:= 20;
SIf.Cfg.dinMaxNumOfHangers_PosMonitoring := 2;
SIf.Cfg.uinNumOfHangersPerPulse:= 1;
SIF.Cfg.bolCylPosLostMonitoring:= FALSE;
SIF.Cfg.bolReleaseAllNonPulse:= FALSE;
SIf.Cfg.usiSimulationMode:= 0;]]></ST>
      </Implementation>
      <ObjectProperties />
    </Method>
    <Method Name="IoOutBridge" Id="{7c749205-b87e-436e-86c7-af8223dedf93}">
      <Declaration><![CDATA[METHOD PROTECTED IoOutBridge : BOOL
]]></Declaration>
      <Implementation>
        <ST><![CDATA[// digitale and analoge inputs read from hardware or forcing
IF (CIf.SwCfg.bolSimulation = FALSE) THEN
	setOutBol(CIf.Job.bolIoForce ,ADR(SIf.Out.bolRetract));
	
	// check interlocks to prevent damages
	IF (CIf.Job.bolIlkOverwrite=FALSE) THEN
		IF (SIf.Ilk.bolRetract=TRUE) THEN
			// switch off?
			IF (SIf.Out.bolRetract.map = TRUE) THEN
				// Set alarm: SIf.Alm[2].strText := 'interlock retract - movement stopped';				
				pfbAlarmCtrl^.setAlarm(CIf.Info.intCtrlId,2,0,ADR(SIf.Alm),E_AlmState.RST,CIf.Job.eMe_ActivAlmClass);				
			END_IF
			SIf.Out.bolRetract.map := FALSE;
		END_IF	
	END_IF
	THIS^.Out_bolRetract := SIf.Out.bolRetract.map;
	


	setOutBol(CIf.Job.bolIoForce ,ADR(SIf.Out.bolRetract2));
	
	// check interlocks to prevent damages
	IF (CIf.Job.bolIlkOverwrite=FALSE) THEN
		IF (SIf.Ilk.bolRetract=TRUE) THEN
			// switch off?
			IF (SIf.Out.bolRetract2.map = TRUE) THEN
				// Set alarm: SIf.Alm[2].strText := 'interlock retract - movement stopped';				
				pfbAlarmCtrl^.setAlarm(CIf.Info.intCtrlId,2,0,ADR(SIf.Alm),E_AlmState.RST,CIf.Job.eMe_ActivAlmClass);				
			END_IF
			SIf.Out.bolRetract2.map := FALSE;
		END_IF	
	END_IF
	THIS^.Out_bolRetract2 := SIf.Out.bolRetract2.map;
	
END_IF]]></ST>
      </Implementation>
      <ObjectProperties />
    </Method>
    <Method Name="sta_OFF" Id="{854c6654-f8b5-4ba2-8c05-830fc81503c6}">
      <Declaration><![CDATA[METHOD PROTECTED sta_OFF : BOOL
]]></Declaration>
      <Implementation>
        <ST><![CDATA[// state implemetation
//--------------------------------------------------------------------------------------
// Entry action
	IF (me.StateMachine.intState<>me.StateMachine.intStateLastCycle) THEN
		me.StateMachine.intStateLastCycle := me.StateMachine.intState;
		
		// Reset total counter
		SIf.Cur.dinHangersPassedTotal:= 0;
	END_IF


//--------------------------------------------------------------------------------------
// Cyclic action
	IF (me.StateMachine.intState=me.StateMachine.intStateLastCycle) THEN
		
	
		// State Change Condition
		IF (me.Alarm.eActivAlmClass<>E_AlmClass.EOFF) AND (me.Alarm.eActivAlmClass<>E_AlmClass.OFF) THEN
			IF (me.intCmd=cCMD_STOP) THEN
				me.StateMachine.intStateNext :=  cSTA_STOPBusy;
			ELSIF (me.intCmd=STB_CmdState.cCMD_RELEASE) THEN 
				me.StateMachine.intStateNext := STB_CmdState.cSTA_RELEASEBusy;
			ELSIF(me.intCmd=STB_CmdState.cCMD_RELEASE_ALL) THEN
				me.StateMachine.intStateNext := STB_CmdState.cSTA_RELEASE_ALLBusy;
			ELSIF(me.intCmd=cCMD_RUN) THEN
				me.StateMachine.intStateNext := cSTA_RUNBusy;
			END_IF
		END_IF
	END_IF


//--------------------------------------------------------------------------------------
// Exit action
	IF (me.StateMachine.intState<>me.StateMachine.intStateNext) THEN
		;
	END_IF]]></ST>
      </Implementation>
      <ObjectProperties />
    </Method>
    <Method Name="IoInBridge" Id="{ad64270e-51e2-4353-aac2-63b95e4be0b0}">
      <Declaration><![CDATA[METHOD PROTECTED IoInBridge : BOOL
]]></Declaration>
      <Implementation>
        <ST><![CDATA[// digitale and analoge inputs read from hardware or forcing

SIf.In.bolHangerDetected.map := THIS^.In_bolHangerDetected;
SIf.In.bolBufferFull.map := THIS^.In_bolBufferFull;
SIf.In.bolDecrementCounter.map := THIS^.In_bolDecrementCounter;

IF (CIf.SwCfg.bolSimulation = FALSE) THEN
	getInBolDebounced(CIf.Job.bolIoForce, me.FUBInfo.udiSample_ms, Sif.par.udiDebounceTime_ms, ADR(SIf.In.bolHangerDetected));
	getInBolDebounced(CIf.Job.bolIoForce, me.FUBInfo.udiSample_ms, Sif.par.udiDebounceTime_ms, ADR(SIf.In.bolBufferFull));
	getInBolDebounced(CIf.Job.bolIoForce, me.FUBInfo.udiSample_ms, Sif.par.udiDebounceTime_ms, ADR(SIf.In.bolDecrementCounter));
	//ctrl.In.bol_PosSwitchBasicDefTyp.intern := getInBol(ctrl.ifc.Job.bol_Force ,ADR(ctrl.In.bol_PosSwitchBasicDefTyp);
ELSE
	//simulation of global IO
END_IF
]]></ST>
      </Implementation>
      <ObjectProperties />
    </Method>
    <Property Name="NumOfHangers" Id="{b24fd635-1ab3-48c6-a9c5-bd58c8c8acc3}">
      <Declaration><![CDATA[PROPERTY NumOfHangers : DINT
]]></Declaration>
      <Get Name="Get" Id="{4bed2c26-83de-4352-b891-1fd833c50d9a}">
        <Declaration><![CDATA[]]></Declaration>
        <Implementation>
          <ST><![CDATA[NumOfHangers:= SIf.Cur.dinNumOfHangersInBuffer;]]></ST>
        </Implementation>
        <ObjectProperties />
      </Get>
      <ObjectProperties />
    </Property>
    <Method Name="sta_RELEASE_ALLBusy" Id="{bfdec8d2-2974-4967-afbb-45cfff255917}">
      <Declaration><![CDATA[METHOD PROTECTED sta_RELEASE_ALLBusy : BOOL
]]></Declaration>
      <Implementation>
        <ST><![CDATA[// state implemetation
//--------------------------------------------------------------------------------------
// Entry action
	IF (me.StateMachine.intState<>me.StateMachine.intStateLastCycle) THEN
		me.StateMachine.intStateLastCycle := me.StateMachine.intState;
				
		dinNumOfHangersToRelease:= 0;
		dinSetNumOfHangersToRelease:= 0;
		
		// Reset package counter
		SIf.Cur.dinHangersPassedPackage:= 0;
	
		// Initialize sub state machine
		me.SubStateMachine.intState:= cSTA_SUB_INITIALIZED; 
		me.SubStateMachine.intStateNext:= cSTA_SUB_INITIALIZED;
	
	END_IF

//--------------------------------------------------------------------------------------
// Cyclic action
	IF (me.StateMachine.intState=me.StateMachine.intStateLastCycle) THEN
			
		//--------------------------------------------------------------------------------------
		// sub state machine for release all sequence
		CASE me.SubStateMachine.intState OF
			//--------------------------------------------------------------------------------------
			cSTA_SUB_INITIALIZED:
				// Entry action
				IF (me.SubStateMachine.intState<>me.SubStateMachine.intStateLastCycle) THEN
					me.SubStateMachine.intStateLastCycle := me.SubStateMachine.intState;							
					
					//Used buffer mode?
					CASE SIf.Par.usiBuffermode OF
					0: // 0= Emptying buffer, use buffer capacity at cycle start
						dinSetNumOfHangersToRelease := SIf.Cfg.dinMaxCapacity;
					1: // 1= Emptying buffer, newly added hangers will be considered
						dinSetNumOfHangersToRelease := dinNumOfHangersToRelease;
					END_CASE
				
				END_IF
				
				// Simulation
				IF (CIf.SwCfg.bolSimulation) THEN
					;
				END_IF
	
				// State Change Condition
				IF(TRUE)THEN
					me.SubStateMachine.intStateNext := cSTA_SUB_HANGER_PASSING;
				END_IF
						
			//--------------------------------------------------------------------------------------
			cSTA_SUB_HANGER_PASSING:
				// Entry action
				IF (me.SubStateMachine.intState<>me.SubStateMachine.intStateLastCycle) THEN
					me.SubStateMachine.intStateLastCycle := me.SubStateMachine.intState;							
									
					// Check if min. one hanger exist and save info tmp. Used for counting.
					IF (SIf.In.bolHangerDetected.intern = TRUE) THEN
						bolHangerDetected:= TRUE;
					ELSE
						bolHangerDetected:= FALSE;
					END_IF
					
				END_IF
				
				// Simulation
				IF (CIf.SwCfg.bolSimulation) THEN
					;
				END_IF

				// Release all based on time and both pins go up or with pulses
				IF (SIf.Cfg.bolReleaseAllNonPulse = TRUE) THEN
					
					SIf.Out.bolRetract.intern := TRUE; // both pins move up
					SIf.Out.bolRetract2.intern := TRUE; // both pins move up
					
					// wait release all time
					IF (me.SubStateMachine.udiTimeInState_ms > SIf.Par.udiReleaseAllTime_ms) THEN
						me.SubStateMachine.intStateNext := cSTA_SUB_HANGER_PASSED;
					END_IF
					
					// Calculate number of hangers in buffer dependent number of hangers per pulse
					SIf.Cur.dinNumOfHangersInBuffer := 0;
					// Calculate total counter dependent number of hangers per pulse
					SIf.Cur.dinHangersPassedTotal:= SIf.Cur.dinHangersPassedTotal + dinNumOfHangersToRelease;
					// Calculate package counter dependent number of hangers per pulse				
					SIf.Cur.dinHangersPassedPackage:= SIf.Cur.dinHangersPassedPackage + dinNumOfHangersToRelease;
					// calculate hangers still to release
					dinSetNumOfHangersToRelease := 0;
					
				ELSE
					
					// Switch valve on, cylinder to retract position -> release hanger
					SIf.Out.bolRetract.intern := TRUE;  // pin move up
					SIf.Out.bolRetract2.intern := FALSE;  // pin move down
					
					// Pulse timer expired?
					IF (me.SubStateMachine.udiTimeInState_ms > SIf.Par.udiPulseLengthValve_ms) THEN
						me.SubStateMachine.intStateNext := cSTA_SUB_HANGER_PASSED;
						
						// Update all counters. Only if a hanger was detected before.
						// If no hanger detection sensor exists, count unconditional with every cylinder stroke
						IF (bolHangerDetected = TRUE) OR (Sif.Cfg.bolHasHangerDetection = FALSE) THEN
							
							// Note: Only for separator the number of hangers per pulse corresponds exactly the real number of passed hangers.
							// For all other units like e.g. double stopper it's only an approximate number.
						
							IF (SIf.Cfg.bolHasDecrementSensor = FALSE) THEN // Else do it in Method Always
								// Calculate number of hangers in buffer dependent number of hangers per pulse
								SIf.Cur.dinNumOfHangersInBuffer:= SIf.Cur.dinNumOfHangersInBuffer - dinNumOfHangersToRelease;
							END_IF
							// Calculate total counter dependent number of hangers per pulse
							SIf.Cur.dinHangersPassedTotal:= SIf.Cur.dinHangersPassedTotal + dinNumOfHangersToRelease;
							// Calculate package counter dependent number of hangers per pulse				
							SIf.Cur.dinHangersPassedPackage:= SIf.Cur.dinHangersPassedPackage + dinNumOfHangersToRelease;
							// calculate hangers still to release
							dinSetNumOfHangersToRelease := dinSetNumOfHangersToRelease - dinNumOfHangersToRelease;
							
							// Calculate NumOfHangersToRelease, Used for RELEASE_ALL end condition
							// Has buffer?
							// calculate max number of hangers could release per pulse
							IF (SIf.Cur.dinNumOfHangersInBuffer<=SIf.Cfg.uinNumOfHangersPerPulse) THEN
								dinNumOfHangersToRelease := SIf.Cur.dinNumOfHangersInBuffer;
							ELSE
								dinNumOfHangersToRelease := SIf.Cfg.uinNumOfHangersPerPulse;
							END_IF
							
							//Used buffer mode?
							CASE SIf.Par.usiBuffermode OF
								0:  
									IF  (dinNumOfHangersToRelease <= 0) THEN // All hangers should be released, do the hole capacity 
										dinSetNumOfHangersToRelease:= dinSetNumOfHangersToRelease - SIf.Cfg.uinNumOfHangersPerPulse;
									END_IF
								1:
									dinSetNumOfHangersToRelease:= dinNumOfHangersToRelease;
							END_CASE
													
							bolHangerDetected:= FALSE;
						END_IF
					END_IF
						
				END_IF
	
			//--------------------------------------------------------------------------------------
			cSTA_SUB_HANGER_PASSED:
				// Entry action
				IF (me.SubStateMachine.intState<>me.SubStateMachine.intStateLastCycle) THEN
					me.SubStateMachine.intStateLastCycle := me.SubStateMachine.intState;							
					;						
				END_IF
				
				// Switch valve off, cylinder back to extend position -> stop hanger
				SIf.Out.bolRetract.intern := FALSE;
				SIf.Out.bolRetract2.intern := TRUE;	
				
				// Simulation
				IF (CIf.SwCfg.bolSimulation) THEN
					;
				END_IF
					
				// State Change Condition
				IF ((dinSetNumOfHangersToRelease<=0) AND ((Sif.Cfg.bolHasHangerDetection = FALSE) OR (SIf.Par.usiBuffermode<>1))) THEN
					me.SubStateMachine.intStateNext := cSTA_SUB_FINISHED;
				ELSIF ((SIf.Par.usiBuffermode=1) AND (Sif.Cfg.bolHasHangerDetection = TRUE) AND (SIf.In.bolHangerDetected.intern = FALSE)) THEN
					me.SubStateMachine.intStateNext := cSTA_SUB_FINISHED;
				ELSIF (me.SubStateMachine.udiTimeInState_ms > SIf.Par.udiIntervalBufferEmptying_ms) THEN
					me.SubStateMachine.intStateNext := cSTA_SUB_HANGER_PASSING;
				END_IF
			
			//--------------------------------------------------------------------------------------
			cSTA_SUB_FINISHED:
					;	// Buffer emptied 
					
		END_CASE
			
		// State Change Condition
		// [ms] Timeout buffer emptying -> ERROR,(0 = disable monitoring)
		IF ((me.StateMachine.udiTimeInState_ms > (SIf.Par.udiTimeoutBufferEmptying_ms)) AND (SIf.Par.udiTimeoutBufferEmptying_ms <> 0)) THEN
			// SIf.Alm[1].strText := 'Timeout buffer emptying';
			pfbAlarmCtrl^.setAlarm(CIf.Info.intCtrlId,1,0,ADR(SIf.Alm),E_AlmState.RST,CIf.Job.eMe_ActivAlmClass);
			me.StateMachine.intStateNext := cSTA_ERROR;
		ELSIF (me.SubStateMachine.intState = cSTA_SUB_FINISHED) THEN				// Buffer emptied -> RELEASE_ALL
			me.StateMachine.intStateNext := STB_CmdState.cSTA_RELEASE_ALL;
		ELSIF(me.intCmd=cCMD_STOP) THEN
			me.StateMachine.intStateNext := cSTA_STOPBusy;		
		END_IF
	END_IF


//--------------------------------------------------------------------------------------
// Exit action
	IF (me.StateMachine.intState<>me.StateMachine.intStateNext) THEN
		;
	END_IF]]></ST>
      </Implementation>
      <ObjectProperties />
    </Method>
    <Method Name="sta_RUNBusy" Id="{dc9bc62e-8a9b-45ce-ab89-751cc170d7d6}">
      <Declaration><![CDATA[METHOD PROTECTED sta_RUNBusy : BOOL
]]></Declaration>
      <Implementation>
        <ST><![CDATA[// state implemetation
//--------------------------------------------------------------------------------------
// Entry action
	IF (me.StateMachine.intState<>me.StateMachine.intStateLastCycle) THEN
		me.StateMachine.intStateLastCycle := me.StateMachine.intState;
		;				
	END_IF

//--------------------------------------------------------------------------------------
// Cyclic action
	IF (me.StateMachine.intState=me.StateMachine.intStateLastCycle) THEN
			
		// State Change Condition
		
		// Check if access to section buffer exist. 
		// This controller will be set to RUN in case if STB work in combination with FUB MTR to merge hangers into a TLK.
		IF (SIf.Cur.pSectionBuffer = 0) THEN
			// SIf.Alm[4].strText := 'RUN not possible, no access to section buffer';
			pfbAlarmCtrl^.setAlarm(CIf.Info.intCtrlId,4,0,ADR(SIf.Alm),E_AlmState.RST,CIf.Job.eMe_ActivAlmClass);	
			me.StateMachine.intStateNext := cSTA_ERROR;
		ELSE
			me.StateMachine.intStateNext := cSTA_RUN;		
		END_IF
	END_IF

//--------------------------------------------------------------------------------------
// Exit action
	IF (me.StateMachine.intState<>me.StateMachine.intStateNext) THEN
		;
	END_IF]]></ST>
      </Implementation>
      <ObjectProperties />
    </Method>
    <Method Name="Always" Id="{f236f7a7-e231-44ab-8398-0cfca557cb09}">
      <Declaration><![CDATA[METHOD PROTECTED Always : BOOL
]]></Declaration>
      <Implementation>
        <ST><![CDATA[IF (me.bolChangeBackToAUTO=TRUE) THEN // switch mode to automatic switch off controller
	//me.StateMachine.intStateNext := cSTA_OFFBusy;
	me.bolChangeBackToAUTO := FALSE; // for cylinder no change to off when switch to automatic!!
END_IF

SUPER^.Always();

// ----------------------------------------------------------------------------------
// cyclic actions outside of statemachine
IF (me.StateMachine.intState<>cSTA_SINGLE_ANSWER) THEN
	
	//--------------------------------------------------------------------
 	// START SIMULATION
	//--------------------------------------------------------------------
	IF (CIf.SwCfg.bolSimulation) THEN
		fbSimulationTimer(); // set time/reset timer
		
		// Simulation mode
		CASE SIf.Cfg.usiSimulationMode OF
		// 0 = Normal simulation of STB function, e.g. STB in combination with SLB controller
		0:
			// Simulate Hanger is coming into the stopper
			IF (SIf.Cfg.bolHasBufferFullSensor = TRUE) AND (SIf.Cfg.bolHasHangerDetection = TRUE) THEN 
				IF (SIf.In.bolBufferFull.intern = TRUE) AND (bolRESimHangerIn = FALSE) THEN
					SIf.In.bolHangerDetected.intern := TRUE;
					bolRESimHangerIn := TRUE;
				ELSIF (SIf.In.bolBufferFull.intern = FALSE) AND (bolRESimHangerIn = TRUE) THEN
					bolRESimHangerIn := FALSE;				
				END_IF
			END_IF
			// Use number of hangers to generate buffer full signal
			IF (SIf.Cur.dinNumOfHangersInBuffer >= SIf.Cfg.dinMaxCapacity) THEN
				SIf.In.bolBufferFull.intern := TRUE;
			ELSIF ((SIf.In.bolBufferFull.intern = TRUE) AND (SIf.Cur.dinNumOfHangersInBuffer < SIf.Cfg.dinMaxCapacity)) THEN
				SIf.In.bolBufferFull.intern := FALSE;
			END_IF
			// Use number of hangers to generate hanger detection signal
			IF (SIf.Cur.dinNumOfHangersInBuffer <= 0) AND (SIf.Out.bolRetract.intern = TRUE) THEN
				SIf.In.bolHangerDetected.intern := FALSE;
			END_IF
		
		// 1 = Hanger detection signal can be overridden manually to test STB in combination with MTR controller	
		1:
			// nothing to do...
				
		END_CASE		
	END_IF 
	
	//--------------------------------------------------------------------
 	// END SIMULATION
	//--------------------------------------------------------------------
	
	//--------------------------------------------------------------------
	// Generate info "buffer full" dependent the existing sensors
	// Input signal validation
	//--------------------------------------------------------------------
	// Prio 1. Always use the buffer full sensor if exists
	IF (SIf.Cfg.bolHasBufferFullSensor = TRUE) THEN
		// Use buffer full sensor signal
		bolSensorBufferFull:= SIf.In.bolBufferFull.intern;
	ELSE
		//Prio 2. Check if hanger detection sensor exists 
		IF (SIf.Cfg.bolHasHangerDetection = TRUE) THEN
			// Use hanger detected sensor for buffer full signal (e.g. Separator with only hanger detection sensor)
			bolSensorBufferFull:= SIf.In.bolHangerDetected.intern;
		ELSE
			//No sensor exist.
			bolSensorBufferFull:= FALSE;
		END_IF
	END_IF
		
	// Check sensor signal. Valid if TRUE for X-time
	fbTimerBufferFullSignal.IN := bolSensorBufferFull; // start timer
	fbTimerBufferFullSignal.PT := UDINT_TO_TIME(SIf.Par.udiSensorTime_ms);
	fbTimerBufferFullSignal();
	
	// Signal valid. Set info buffer full.
	IF (fbTimerBufferFullSignal.Q = TRUE) THEN
		SIf.Cur.bolBufferFull:= TRUE;
	ELSE
		SIf.Cur.bolBufferFull:= FALSE;
	END_IF
	
	
	//--------------------------------------------------------------------
	// Generate info "hanger detected" dependent the existing sensors
	// Input signal validation
	//--------------------------------------------------------------------
	
	// Prio 1. Always use the hanger detection sensor if exists
	IF (SIf.Cfg.bolHasHangerDetection = TRUE) THEN
		// Use hanger detection sensor signal
		bolSensorHangerDetected:= SIf.In.bolHangerDetected.intern;
	ELSE
		//Prio 2. Check if buffer full sensor exists 
		IF (SIf.Cfg.bolHasBufferFullSensor = TRUE) THEN
			// Use number of hangers to generate hanger detection signal
			IF (SIf.Cur.dinNumOfHangersInBuffer > 0) THEN
				bolSensorHangerDetected:= TRUE;
			ELSE
				bolSensorHangerDetected:= FALSE;
			END_IF
		ELSE
			//No sensor exist.
			bolSensorHangerDetected:= FALSE;
		END_IF
	END_IF
		
	// Check sensor signal. Valid if TRUE for X-time
	fbTimerHangerDetecSignal.IN := bolSensorHangerDetected; // start timer
	fbTimerHangerDetecSignal.PT := UDINT_TO_TIME(SIf.Par.udiSensorTime_ms);
	fbTimerHangerDetecSignal();
	
	// Signal valid. Set info buffer full.
	IF (fbTimerHangerDetecSignal.Q = TRUE) THEN
		SIf.Cur.bolHangerDetected:= TRUE;
	ELSE
		SIf.Cur.bolHangerDetected:= FALSE;
	END_IF
	
	
	//--------------------------------------------------------------------
	// Counter handling buffer level (number of hangers in buffer)
	//--------------------------------------------------------------------

	// Inc. number of hangers in buffer with every edge of sensor
	// Has buffer sensor ?
	IF (SIf.Cfg.bolHasBufferFullSensor = TRUE) THEN
		
		// Inc. only if the buffer is not full
		IF (SIf.Cur.bolBufferFull = FALSE) THEN
			
			// Detection positive edge from buffer full sensor
			IF ((SIf.In.bolBufferFull.intern <> bolBufferFullSigCountOld) AND (SIf.In.bolBufferFull.intern = TRUE)) THEN			
				// Inc. number of hangers in buffer by one!
				// Note: With the given sensors it's not possible to count exactly one hanger per sensor pulse.
				// e.g. On a slide, normally they pass more than one hanger the sensor position at the same time.		
				SIf.Cur.dinNumOfHangersInBuffer:= SIf.Cur.dinNumOfHangersInBuffer + 1;
			END_IF
			bolBufferFullSigCountOld:= SIf.In.bolBufferFull.intern;
			
		END_IF
	END_IF

	// Dec. number of hangers in buffer with every edge of sensor
	// Has decrement sensor ?
	IF (SIf.Cfg.bolHasDecrementSensor = TRUE) THEN
		
		// Check if hangers passed the decrement sensor, else decrement NumOfHangersPerPulse
		IF ((SIf.Out.bolRetract.intern <>bolRetractOld) AND (SIf.Out.bolRetract.intern = TRUE)) THEN
			IF (bolWaitForDecrement = FALSE) THEN
				bolWaitForDecrement := TRUE; // Start waiting
			ELSE // Counter is still waiting from the last cycle -> Maybe STB was physically empty
				SIf.Cur.dinNumOfHangersInBuffer := SIf.Cur.dinNumOfHangersInBuffer - SIf.Cfg.uinNumOfHangersPerPulse;
			END_IF		
		END_IF 
		bolRetractOld := SIf.Out.bolRetract.intern;		
			
		// Detection positive edge from decrement sensor
		IF ((SIf.In.bolDecrementCounter.intern <> bolDecrementCountOld) AND (SIf.In.bolDecrementCounter.intern = TRUE)) THEN			
			// Dec. number of hangers in buffer by one!
			// Note: With the given sensors it's not possible to count exactly one hanger per sensor pulse.
			// e.g. On a slide, normally they pass more than one hanger the sensor position at the same time.		
			SIf.Cur.dinNumOfHangersInBuffer:= SIf.Cur.dinNumOfHangersInBuffer - 1;
			bolWaitForDecrement := FALSE;	// reset waiting
		END_IF
		bolDecrementCountOld:= SIf.In.bolDecrementCounter.intern;
			
	END_IF

	// Reset NumOfHangersInBuffer if no Hanger detected
	// If Hanger detected, minimum 1 Hanger in Buffer
	IF (SIf.Cfg.bolHasHangerDetection = TRUE) THEN
		// With Sensor Hanger delete hanger counter if no hanger is detected
		// Check sensor signal. Valid if TRUE for X-time
		fbTimerHangerDeleteNoDetected.IN := NOT SIf.In.bolHangerDetected.intern; // start timer
		fbTimerHangerDeleteNoDetected.PT := UDINT_TO_TIME(SIf.Par.udiSensorTime_ms);
		fbTimerHangerDeleteNoDetected();
		
		// Signal valid. Set info buffer empty, if not prevented.
		IF ((fbTimerHangerDeleteNoDetected.Q = TRUE) AND (SIf.Cfg.bolDisableBufferDelete = FALSE)) THEN
			SIf.Cur.dinNumOfHangersInBuffer := 0;
		END_IF
		
		// sensor has at least one hanger detected
		IF (SIf.Cur.dinNumOfHangersInBuffer <= 0)  AND (SIf.In.bolHangerDetected.intern) THEN
			SIf.Cur.dinNumOfHangersInBuffer := 1;
		END_IF
	END_IF
	
	// If buffer full detected, set number of hangers in buffer to max. capacity
	IF ((SIf.Cur.bolBufferFull = TRUE) AND (SIf.Cfg.bolHasBufferFullSensor = TRUE)) THEN	
		SIf.Cur.dinNumOfHangersInBuffer:= Sif.Cfg.dinMaxCapacity;
	END_IF
	
	// Limit Counter to max capacity
	IF (SIf.Cur.dinNumOfHangersInBuffer > SIf.Cfg.dinMaxCapacity) THEN
		SIf.Cur.dinNumOfHangersInBuffer:= SIf.Cfg.dinMaxCapacity;
	END_IF
	
	// Counter shows max. capacity, buffer full not detected (used for Bugzilla ID 55)
	IF ((SIf.Cur.dinNumOfHangersInBuffer >= SIf.Cfg.dinMaxCapacity) AND (SIf.In.bolBufferFull.intern =FALSE) AND
		(SIf.Cur.bolBufferFull = FALSE) AND (SIf.Cfg.bolHasBufferFullSensor = TRUE)) THEN	
		// Buffer is not full, decrement dinNumOfHangersInBuffer
		SIf.Cur.dinNumOfHangersInBuffer:= SIf.Cfg.dinMaxCapacity-1;
	END_IF
	
	
	// Limit Counter to min capacity
	IF SIf.Cur.dinNumOfHangersInBuffer < 0 THEN
		SIf.Cur.dinNumOfHangersInBuffer:= 0;
	END_IF
	
	// calculate max number of hangers could release per pulse
	IF (SIf.Cur.dinNumOfHangersInBuffer<=SIf.Cfg.uinNumOfHangersPerPulse) THEN
		dinNumOfHangersToRelease := SIf.Cur.dinNumOfHangersInBuffer;
	ELSE
		dinNumOfHangersToRelease := SIf.Cfg.uinNumOfHangersPerPulse;
	END_IF
END_IF


// ----------------------------------------------------------------------------------
// Always change actions in Base Library
// ----------------------------------------------------------------------------------
// overrule error always from base -> no EOFF State!! in EOFF go to OFF
IF (me.StateMachine.intStateNext = cSTA_EOFFBusy) THEN
	IF (me.StateMachine.intState=cSTA_OFF) THEN
		me.StateMachine.intStateNext := cSTA_OFF;
	ELSE // stay in OFF
		me.StateMachine.intStateNext := cSTA_OFFBusy;
	END_IF
END_IF

// Conditions Always
IF (((me.Alarm.eActivAlmClass=E_AlmClass.EOFF) OR (me.Alarm.eActivAlmClass=E_AlmClass.OFF) OR (me.intCmd=cCMD_OFF))
		 AND (me.StateMachine.intState<>cSTA_ERROR) AND (me.StateMachine.intState<>cSTA_ERRORQuit) AND
		(me.StateMachine.intState<>cSTA_OFF) AND (me.StateMachine.intState<>cSTA_OFFBusy)) THEN
	// alarm evt EOFF, OFF or cmd off
	me.StateMachine.intStateNext := cSTA_OFFBusy;
END_IF]]></ST>
      </Implementation>
      <ObjectProperties />
    </Method>
    <ObjectProperties />
  </POU>
</TcPlcObject>