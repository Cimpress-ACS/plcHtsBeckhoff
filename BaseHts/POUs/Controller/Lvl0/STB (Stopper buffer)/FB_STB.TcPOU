<TcPlcObject Version="1.1.0.1" ProductVersion="3.1.0.19">
  <POU Name="FB_STB" Id="{d3842983-9650-494b-94cf-4a4dc31a481b}">
    <Declaration><![CDATA[FUNCTION_BLOCK FB_STB EXTENDS FB_CtrlBase IMPLEMENTS IBuffer
VAR_INPUT
	/// Sensor hanger detected
	In_bolHangerDetected: BOOL;
	/// Buffer full sensor
	In_bolBufferFull: BOOL;
	/// DecrementCounter Sensor (option)
	In_bolDecrementCounter: BOOL;
END_VAR
VAR_OUTPUT
	/// if bolRetract2 is not used  = 1 -> second pin up first pin (inlet) down
	Out_bolRetract: BOOL;
	/// = 1 -> second pin down (outlet)
	Out_bolRetract2: BOOL;
END_VAR
VAR
	/// Specific interface struct for public access
	SIf: T_Ctrl_SIf_STB;
	/// Internal Variables
	bolHangerDetected: BOOL;
	dinNumOfHangersToRelease: DINT;
	dinSetNumOfHangersToRelease: DINT;
	bolSensorBufferFull: BOOL;
	bolSensorHangerDetected: BOOL;
	bolBufferFullOld: BOOL;
	bolBufferFullSigCountOld: BOOL;
	/// Shadow copy of SIf.In.bolDecrementCounter.intern
	bolDecrementCountOld: BOOL;
	bolSignalForPosLostMonitoring: BOOL;
	bolSignalForPosLostMonitoringOld: BOOL;
	uinPosEdgeCounter: UINT;
	bolErrorPosLost: BOOL;
	fbTimerBufferFullSignal: TON;
	fbTimerHangerDetecSignal: TON;
	fbTimerHangerDeleteNoDetected: TON;
	/// Var. used for simulation
	bolRESimHangerIn: BOOL;
	/// Rising Edge Hanger go out
	bolRESimHangerOut: BOOL;
	/// Var. used for decrementing with sensor
	bolWaitForDecrement: BOOL;
	/// Copy of Output
	bolRetractOld: BOOL;
END_VAR
VAR CONSTANT
	/// sub States for RELEASE_ALL Function
	cSTA_SUB_INITIALIZED: INT := 500;
	cSTA_SUB_HANGER_PASSING: INT := 502;
	cSTA_SUB_HANGER_PASSED: INT := 504;
	cSTA_SUB_FINISHED: INT := 506;
END_VAR
]]></Declaration>
    <Implementation>
      <ST><![CDATA[(*__________________________________________________________________________________________________
¦	
¦	Vistaprint Schweiz GmbH
¦	CH - 8401 Winterthur
¦
¦	www.vistaprint.ch - info@vistaprint.ch
¦___________________________________________________________________________________________________

Function desription:
The stopper buffer controller let pass hanger(s) with every pulse (retract/extend) of the pneumatic cylinder.
This controller can be used for the following units: Separator, Double stopper and Single stopper.

Note:  With the given sensors it's not possible to detect exactly one hanger per sensor pulse to inc. the number of hangers in buffer.
       Means that all calculated values ​​are only approximate.

History:
Version		Date			Author		Comment
---------------------------------------------------------------------------------------------------
0.00.1		22.08.2013		AVME/PRE	Start history
0.00.2		29.08.2013		AVME/DSC	Integration of all separator basic functionalities
0.00.3		30.08.2013		AVME/DSC	Integration monitoring cylinder position lost in state STOP.
0.00.4      09.09.2013      AVME/DSC    Generate signal "hanger detected". In case if only buffer full sensor exist, 
										use number of hangers to generate hanger detection signal.
										Renaming FUB "FB_SEP" to "FB_STB". Decided by Rolf and PRE.
0.00.5		19.09.2013		AVME/PRE	Limit Counter to max capacity if higher as max capacity
0.00.6		19.09.2013		AVME/PRE	Implement new Base Concept
0.00.7		26.09.2013		AVME/KVO	- Add new output for douplestopper with two valves
										- Add new config bolReleaseAllNonPulse -> to release all over time 
											-> new par udiReleaseAllTime_ms: UDINT;
										- calculation of hangers corrected
										- if hanger dtedction sensor detects a hanger and buffer is 0 -> set 1 always
										-  max number of hangers detected in STOP if bolCylPosLostMonitoring activated until an error occures
											uinMaxNumOfHangers_PosMonitoring
										- info buffer full and hanger detected removed - not necessary
0.00.8		27.09.2013		AVME/DSC	Modification for error condition of hanger position lost monitoring.										
0.00.9		02.10.2013		AVME/DSC	Modification set number of hangers in buffer to max. capacity if buffer full signal detected.
0.00.10		07.10.2013		AVME/DSC    Modification in always action. If buffer full detected, number of hangers in buffer must be always set to max. capacity.
0.00.11		09.10.2013		VP/RE		Only decrease dinNumOfHangersInBuffer when is NOT full (but only if full sensor is available)
0.00.12		07.11.2013		AVME/MRU	Add debounced inputs and configuration with bolHasDecrementSensor
0.00.13		03.12.2013		AVME/MRU	Add MaxCapacity / NumOfHangers properties
0.00.14		12.12.2013		AVME/MRU	Bug fixed with decrement sensor, Min. Limit of dinNumOfHangersInBuffer = 0;
										Add bolDisableBufferDelete for preventing deleting buffer count 
0.00.15		17.12.2013		AVME/MRU	sta_Release_AllBusy Buffermode=0, Bug fixed
										Code review, some comments changed
___________________________________________________________________________________________*)


IF (me.bolActivate) THEN // cyclic call enabled
	IF (CIf.Info.bolInitDone=FALSE) THEN // first cycle -> init
		CtrlInit();
		CIf.Info.bolInitDone := TRUE;
	ELSE
		CycleStartDuty();
	
		Always();
		
		StateMachine();
		
		CycleEndDuty();
	END_IF
END_IF;
]]></ST>
    </Implementation>
    <Method Name="sta_ERROR" Id="{5a0f2bd5-dd8c-4b33-9770-8a62ec48795b}">
      <Declaration><![CDATA[METHOD PROTECTED sta_ERROR : BOOL
]]></Declaration>
      <Implementation>
        <ST><![CDATA[// state implemetation
//--------------------------------------------------------------------------------------
// Entry action
	IF (me.StateMachine.intState<>me.StateMachine.intStateLastCycle) THEN
		me.StateMachine.intStateHistory := me.StateMachine.intStateLastCycle; // -> possibillity to go back to state before error
		me.StateMachine.intStateLastCycle := me.StateMachine.intState;
		
	END_IF

//--------------------------------------------------------------------------------------
// Cyclic action
	IF (me.StateMachine.intState=me.StateMachine.intStateLastCycle) THEN
		
		// Switch valve off, cylinder back to extend position -> stop hanger
		SIf.Out.bolRetract.intern := FALSE;
		SIf.Out.bolRetract2.intern := TRUE;	
		
		// State Change Condition
		IF (CIf.Job.bolAlmReset = TRUE) THEN
			me.StateMachine.intStateNext := cSTA_ERRORQuit;
		END_IF
	END_IF

//--------------------------------------------------------------------------------------
// Exit action
	IF (me.StateMachine.intState<>me.StateMachine.intStateNext) THEN
		;
	END_IF]]></ST>
      </Implementation>
      <ObjectProperties />
    </Method>
    <Method Name="getCmdState" Id="{f8081592-99ca-4243-9b6b-aa94ab5351fb}">
      <Declaration><![CDATA[METHOD PROTECTED getCmdState : STRING
VAR_INPUT
	intCmdState: INT;
	bolState: BOOL;
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[getCmdState := SUPER^.getCmdState(intCmdState:=intCmdState,bolState:=bolState); // get global/base defined cmds/states
IF (getCmdState='') THEN // global not defined get local
	// get string cmd/state string information in runtime
	IF (bolState=FALSE) THEN
		// cmd's
		CASE intCmdState OF
			STB_CmdState.cCMD_RELEASE_ALL: 
				getCmdState := 'cCMD_RELEASE_ALL';
			STB_CmdState.cCMD_RELEASE: 
				getCmdState := 'cCMD_RELEASE';
		END_CASE;
	ELSE
	
	// states
		CASE intCmdState OF
			STB_CmdState.cSTA_RELEASE_ALLBusy: 
				getCmdState := 'cSTA_RELEASE_ALLBusy';
			STB_CmdState.cSTA_RELEASE_ALL: 
				getCmdState := 'cSTA_RELEASE_ALL';
			STB_CmdState.cSTA_RELEASEBusy: 
				getCmdState := 'cSTA_RELEASEBusy';
			STB_CmdState.cCMD_RELEASE: 
				getCmdState := 'cCMD_RELEASE';
		
			// SUB States
			cSTA_SUB_INITIALIZED:
				getCmdState := 'cSTA_SUB_INITIALIZED';
			cSTA_SUB_HANGER_PASSING:
				getCmdState := 'cSTA_SUB_HANGER_PASSING';
			cSTA_SUB_HANGER_PASSED:
				getCmdState := 'cSTA_SUB_HANGER_PASSED';
											
		END_CASE;
	END_IF
END_IF
]]></ST>
      </Implementation>
      <ObjectProperties />
    </Method>
    <Method Name="sta_RELEASE_ALLBusy" Id="{96921b28-e05b-4405-961d-b144c8ee78a0}">
      <Declaration><![CDATA[METHOD PROTECTED sta_RELEASE_ALLBusy : BOOL
]]></Declaration>
      <Implementation>
        <ST><![CDATA[// state implemetation
//--------------------------------------------------------------------------------------
// Entry action
	IF (me.StateMachine.intState<>me.StateMachine.intStateLastCycle) THEN
		me.StateMachine.intStateLastCycle := me.StateMachine.intState;
				
		dinNumOfHangersToRelease:= 0;
		dinSetNumOfHangersToRelease:= 0;
		
		// Reset package counter
		SIf.Cur.dinHangersPassedPackage:= 0;
	
		// Initialize sub state machine
		me.SubStateMachine.intState:= cSTA_SUB_INITIALIZED; 
		me.SubStateMachine.intStateNext:= cSTA_SUB_INITIALIZED;
	
	END_IF

//--------------------------------------------------------------------------------------
// Cyclic action
	IF (me.StateMachine.intState=me.StateMachine.intStateLastCycle) THEN
			
		//--------------------------------------------------------------------------------------
		// sub state machine for release all sequence
		CASE me.SubStateMachine.intState OF
			//--------------------------------------------------------------------------------------
			cSTA_SUB_INITIALIZED:
				// Entry action
				IF (me.SubStateMachine.intState<>me.SubStateMachine.intStateLastCycle) THEN
					me.SubStateMachine.intStateLastCycle := me.SubStateMachine.intState;							
					
					//Used buffer mode?
					CASE SIf.Par.usiBuffermode OF
					0: // 0= Emptying buffer, use buffer capacity at cycle start
						dinSetNumOfHangersToRelease := SIf.Cfg.dinMaxCapacity;
					1: // 1= Emptying buffer, newly added hangers will be considered
						dinSetNumOfHangersToRelease := dinNumOfHangersToRelease;
					END_CASE
				
				END_IF
				
				// Simulation
				IF (CIf.SwCfg.bolSimulation) THEN
					;
				END_IF
	
				// State Change Condition
				IF(TRUE)THEN
					me.SubStateMachine.intStateNext := cSTA_SUB_HANGER_PASSING;
				END_IF
						
			//--------------------------------------------------------------------------------------
			cSTA_SUB_HANGER_PASSING:
				// Entry action
				IF (me.SubStateMachine.intState<>me.SubStateMachine.intStateLastCycle) THEN
					me.SubStateMachine.intStateLastCycle := me.SubStateMachine.intState;							
									
					// Check if min. one hanger exist and save info tmp. Used for counting.
					IF (SIf.In.bolHangerDetected.intern = TRUE) THEN
						bolHangerDetected:= TRUE;
					ELSE
						bolHangerDetected:= FALSE;
					END_IF
					
				END_IF
				
				// Simulation
				IF (CIf.SwCfg.bolSimulation) THEN
					;
				END_IF

				// Release all based on time and both pins go up or with pulses
				IF (SIf.Cfg.bolReleaseAllNonPulse = TRUE) THEN
					
					SIf.Out.bolRetract.intern := TRUE; // both pins move up
					SIf.Out.bolRetract2.intern := TRUE; // both pins move up
					
					// wait release all time
					IF (me.SubStateMachine.udiTimeInState_ms > SIf.Par.udiReleaseAllTime_ms) THEN
						me.SubStateMachine.intStateNext := cSTA_SUB_HANGER_PASSED;
					END_IF
					
					// Calculate number of hangers in buffer dependent number of hangers per pulse
					SIf.Cur.dinNumOfHangersInBuffer := 0;
					// Calculate total counter dependent number of hangers per pulse
					SIf.Cur.dinHangersPassedTotal:= SIf.Cur.dinHangersPassedTotal + dinNumOfHangersToRelease;
					// Calculate package counter dependent number of hangers per pulse				
					SIf.Cur.dinHangersPassedPackage:= SIf.Cur.dinHangersPassedPackage + dinNumOfHangersToRelease;
					// calculate hangers still to release
					dinSetNumOfHangersToRelease := 0;
					
				ELSE
					
					// Switch valve on, cylinder to retract position -> release hanger
					SIf.Out.bolRetract.intern := TRUE;  // pin move up
					SIf.Out.bolRetract2.intern := FALSE;  // pin move down
					
					// Pulse timer expired?
					IF (me.SubStateMachine.udiTimeInState_ms > SIf.Par.udiPulseLengthValve_ms) THEN
						me.SubStateMachine.intStateNext := cSTA_SUB_HANGER_PASSED;
						
						// Update all counters. Only if a hanger was detected before.
						// If no hanger detection sensor exists, count unconditional with every cylinder stroke
						IF (bolHangerDetected = TRUE) OR (Sif.Cfg.bolHasHangerDetection = FALSE) THEN
							
							// Note: Only for separator the number of hangers per pulse corresponds exactly the real number of passed hangers.
							// For all other units like e.g. double stopper it's only an approximate number.
						
							IF (SIf.Cfg.bolHasDecrementSensor = FALSE) THEN // Else do it in Method Always
								// Calculate number of hangers in buffer dependent number of hangers per pulse
								SIf.Cur.dinNumOfHangersInBuffer:= SIf.Cur.dinNumOfHangersInBuffer - dinNumOfHangersToRelease;
							END_IF
							// Calculate total counter dependent number of hangers per pulse
							SIf.Cur.dinHangersPassedTotal:= SIf.Cur.dinHangersPassedTotal + dinNumOfHangersToRelease;
							// Calculate package counter dependent number of hangers per pulse				
							SIf.Cur.dinHangersPassedPackage:= SIf.Cur.dinHangersPassedPackage + dinNumOfHangersToRelease;
							// calculate hangers still to release
							dinSetNumOfHangersToRelease := dinSetNumOfHangersToRelease - dinNumOfHangersToRelease;
							
							// Calculate NumOfHangersToRelease, Used for RELEASE_ALL end condition
							// Has buffer?
							// calculate max number of hangers could release per pulse
							IF (SIf.Cur.dinNumOfHangersInBuffer<=SIf.Cfg.uinNumOfHangersPerPulse) THEN
								dinNumOfHangersToRelease := SIf.Cur.dinNumOfHangersInBuffer;
							ELSE
								dinNumOfHangersToRelease := SIf.Cfg.uinNumOfHangersPerPulse;
							END_IF
							
							//Used buffer mode?
							CASE SIf.Par.usiBuffermode OF
								0:  
									IF  (dinNumOfHangersToRelease <= 0) THEN // All hangers should be released, do the hole capacity 
										dinSetNumOfHangersToRelease:= dinSetNumOfHangersToRelease - SIf.Cfg.uinNumOfHangersPerPulse;
									END_IF
								1:
									dinSetNumOfHangersToRelease:= dinNumOfHangersToRelease;
							END_CASE
													
							bolHangerDetected:= FALSE;
						END_IF
					END_IF
						
				END_IF
	
			//--------------------------------------------------------------------------------------
			cSTA_SUB_HANGER_PASSED:
				// Entry action
				IF (me.SubStateMachine.intState<>me.SubStateMachine.intStateLastCycle) THEN
					me.SubStateMachine.intStateLastCycle := me.SubStateMachine.intState;							
					;						
				END_IF
				
				// Switch valve off, cylinder back to extend position -> stop hanger
				SIf.Out.bolRetract.intern := FALSE;
				SIf.Out.bolRetract2.intern := TRUE;	
				
				// Simulation
				IF (CIf.SwCfg.bolSimulation) THEN
					;
				END_IF
					
				// State Change Condition
				IF ((dinSetNumOfHangersToRelease<=0) AND ((Sif.Cfg.bolHasHangerDetection = FALSE) OR (SIf.Par.usiBuffermode<>1))) THEN
					me.SubStateMachine.intStateNext := cSTA_SUB_FINISHED;
				ELSIF ((SIf.Par.usiBuffermode=1) AND (Sif.Cfg.bolHasHangerDetection = TRUE) AND (SIf.In.bolHangerDetected.intern = FALSE)) THEN
					me.SubStateMachine.intStateNext := cSTA_SUB_FINISHED;
				ELSIF (me.SubStateMachine.udiTimeInState_ms > SIf.Par.udiIntervalBufferEmptying_ms) THEN
					me.SubStateMachine.intStateNext := cSTA_SUB_HANGER_PASSING;
				END_IF
			
			//--------------------------------------------------------------------------------------
			cSTA_SUB_FINISHED:
					;	// Buffer emptied 
					
		END_CASE
			
		// State Change Condition
		// [ms] Timeout buffer emptying -> ERROR,(0 = disable monitoring)
		IF ((me.StateMachine.udiTimeInState_ms > (SIf.Par.udiTimeoutBufferEmptying_ms)) AND (SIf.Par.udiTimeoutBufferEmptying_ms <> 0)) THEN
			// SIf.Alm[1].strText := 'Timeout buffer emptying';
			pfbAlarmCtrl^.setAlarm(CIf.Info.intCtrlId,1,0,ADR(SIf.Alm),E_AlmState.RST,CIf.Job.eMe_ActivAlmClass);
			me.StateMachine.intStateNext := cSTA_ERROR;
		ELSIF (me.SubStateMachine.intState = cSTA_SUB_FINISHED) THEN				// Buffer emptied -> RELEASE_ALL
			me.StateMachine.intStateNext := STB_CmdState.cSTA_RELEASE_ALL;
		ELSIF(me.intCmd=cCMD_STOP) THEN
			me.StateMachine.intStateNext := cSTA_STOPBusy;		
		END_IF
	END_IF


//--------------------------------------------------------------------------------------
// Exit action
	IF (me.StateMachine.intState<>me.StateMachine.intStateNext) THEN
		;
	END_IF]]></ST>
      </Implementation>
      <ObjectProperties />
    </Method>
    <Method Name="Always" Id="{f37b83df-eacd-4a07-aa78-8d8dc7df76fb}">
      <Declaration><![CDATA[METHOD PROTECTED Always : BOOL
]]></Declaration>
      <Implementation>
        <ST><![CDATA[IF (me.bolChangeBackToAUTO=TRUE) THEN // switch mode to automatic switch off controller
	//me.StateMachine.intStateNext := cSTA_OFFBusy;
	me.bolChangeBackToAUTO := FALSE; // for cylinder no change to off when switch to automatic!!
END_IF

SUPER^.Always();

// ----------------------------------------------------------------------------------
// cyclic actions outside of statemachine
IF (me.StateMachine.intState<>cSTA_SINGLE_ANSWER) THEN
	//////////////////
	// Simulation
	IF (CIf.SwCfg.bolSimulation) THEN
		fbSimulationTimer(); // set time/reset timer
		
		// Simulate Hanger is coming into the stopper
		IF (SIf.Cfg.bolHasBufferFullSensor = TRUE) AND (SIf.Cfg.bolHasHangerDetection = TRUE) THEN 
			IF (SIf.In.bolBufferFull.intern = TRUE) AND (bolRESimHangerIn = FALSE) THEN
				SIf.In.bolHangerDetected.intern := TRUE;
				bolRESimHangerIn := TRUE;
			ELSIF (SIf.In.bolBufferFull.intern = FALSE) AND (bolRESimHangerIn = TRUE) THEN
				bolRESimHangerIn := FALSE;				
			END_IF
		END_IF
		// Use number of hangers to generate hanger detection signal
		IF (SIf.Cur.dinNumOfHangersInBuffer >= SIf.Cfg.dinMaxCapacity) THEN
			SIf.In.bolBufferFull.intern := TRUE;
		END_IF
		// Use number of hangers to generate hanger detection signal
		IF (SIf.Cur.dinNumOfHangersInBuffer <= 0) AND (SIf.Out.bolRetract.intern = TRUE) THEN
			SIf.In.bolHangerDetected.intern := FALSE;
		END_IF

	END_IF  // END SIMULATION
	
	//--------------------------------------------------------------------
	// Generate info "buffer full" dependent the existing sensors
	// Input signal validation
	//--------------------------------------------------------------------
	// Prio 1. Always use the buffer full sensor if exists
	IF (SIf.Cfg.bolHasBufferFullSensor = TRUE) THEN
		// Use buffer full sensor signal
		bolSensorBufferFull:= SIf.In.bolBufferFull.intern;
	ELSE
		//Prio 2. Check if hanger detection sensor exists 
		IF (SIf.Cfg.bolHasHangerDetection = TRUE) THEN
			// Use hanger detected sensor for buffer full signal (e.g. Separator with only hanger detection sensor)
			bolSensorBufferFull:= SIf.In.bolHangerDetected.intern;
		ELSE
			//No sensor exist.
			bolSensorBufferFull:= FALSE;
		END_IF
	END_IF
		
	// Check sensor signal. Valid if TRUE for X-time
	fbTimerBufferFullSignal.IN := bolSensorBufferFull; // start timer
	fbTimerBufferFullSignal.PT := UDINT_TO_TIME(SIf.Par.udiSensorTime_ms);
	fbTimerBufferFullSignal();
	
	// Signal valid. Set info buffer full.
	IF (fbTimerBufferFullSignal.Q = TRUE) THEN
		SIf.Cur.bolBufferFull:= TRUE;
	ELSE
		SIf.Cur.bolBufferFull:= FALSE;
	END_IF
	
	
	//--------------------------------------------------------------------
	// Generate info "hanger detected" dependent the existing sensors
	// Input signal validation
	//--------------------------------------------------------------------
	
	// Prio 1. Always use the hanger detection sensor if exists
	IF (SIf.Cfg.bolHasHangerDetection = TRUE) THEN
		// Use hanger detection sensor signal
		bolSensorHangerDetected:= SIf.In.bolHangerDetected.intern;
	ELSE
		//Prio 2. Check if buffer full sensor exists 
		IF (SIf.Cfg.bolHasBufferFullSensor = TRUE) THEN
			// Use number of hangers to generate hanger detection signal
			IF (SIf.Cur.dinNumOfHangersInBuffer > 0) THEN
				bolSensorHangerDetected:= TRUE;
			ELSE
				bolSensorHangerDetected:= FALSE;
			END_IF
		ELSE
			//No sensor exist.
			bolSensorHangerDetected:= FALSE;
		END_IF
	END_IF
		
	// Check sensor signal. Valid if TRUE for X-time
	fbTimerHangerDetecSignal.IN := bolSensorHangerDetected; // start timer
	fbTimerHangerDetecSignal.PT := UDINT_TO_TIME(SIf.Par.udiSensorTime_ms);
	fbTimerHangerDetecSignal();
	
	// Signal valid. Set info buffer full.
	IF (fbTimerHangerDetecSignal.Q = TRUE) THEN
		SIf.Cur.bolHangerDetected:= TRUE;
	ELSE
		SIf.Cur.bolHangerDetected:= FALSE;
	END_IF
	
	
	//--------------------------------------------------------------------
	// Counter handling buffer level (number of hangers in buffer)
	//--------------------------------------------------------------------

	// Inc. number of hangers in buffer with every edge of sensor
	// Has buffer sensor ?
	IF (SIf.Cfg.bolHasBufferFullSensor = TRUE) THEN
		
		// Inc. only if the buffer is not full
		IF (SIf.Cur.bolBufferFull = FALSE) THEN
			
			// Detection positive edge from buffer full sensor
			IF ((SIf.In.bolBufferFull.intern <> bolBufferFullSigCountOld) AND (SIf.In.bolBufferFull.intern = TRUE)) THEN			
				// Inc. number of hangers in buffer by one!
				// Note: With the given sensors it's not possible to count exactly one hanger per sensor pulse.
				// e.g. On a slide, normally they pass more than one hanger the sensor position at the same time.		
				SIf.Cur.dinNumOfHangersInBuffer:= SIf.Cur.dinNumOfHangersInBuffer + 1;
			END_IF
			bolBufferFullSigCountOld:= SIf.In.bolBufferFull.intern;
			
		END_IF
	END_IF

	// Dec. number of hangers in buffer with every edge of sensor
	// Has decrement sensor ?
	IF (SIf.Cfg.bolHasDecrementSensor = TRUE) THEN
		
		// Check if hangers passed the decrement sensor, else decrement NumOfHangersPerPulse
		IF ((SIf.Out.bolRetract.intern <>bolRetractOld) AND (SIf.Out.bolRetract.intern = TRUE)) THEN
			IF (bolWaitForDecrement = FALSE) THEN
				bolWaitForDecrement := TRUE; // Start waiting
			ELSE // Counter is still waiting from the last cycle -> Maybe STB was physically empty
				SIf.Cur.dinNumOfHangersInBuffer := SIf.Cur.dinNumOfHangersInBuffer - SIf.Cfg.uinNumOfHangersPerPulse;
			END_IF		
		END_IF 
		bolRetractOld := SIf.Out.bolRetract.intern;		
			
		// Detection positive edge from decrement sensor
		IF ((SIf.In.bolDecrementCounter.intern <> bolDecrementCountOld) AND (SIf.In.bolDecrementCounter.intern = TRUE)) THEN			
			// Dec. number of hangers in buffer by one!
			// Note: With the given sensors it's not possible to count exactly one hanger per sensor pulse.
			// e.g. On a slide, normally they pass more than one hanger the sensor position at the same time.		
			SIf.Cur.dinNumOfHangersInBuffer:= SIf.Cur.dinNumOfHangersInBuffer - 1;
			bolWaitForDecrement := FALSE;	// reset waiting
		END_IF
		bolDecrementCountOld:= SIf.In.bolDecrementCounter.intern;
			
	END_IF

	// Reset NumOfHangersInBuffer if no Hanger detected
	// If Hanger detected, minimum 1 Hanger in Buffer
	IF (SIf.Cfg.bolHasHangerDetection = TRUE) THEN
		// With Sensor Hanger delete hanger counter if no hanger is detected
		// Check sensor signal. Valid if TRUE for X-time
		fbTimerHangerDeleteNoDetected.IN := NOT SIf.In.bolHangerDetected.intern; // start timer
		fbTimerHangerDeleteNoDetected.PT := UDINT_TO_TIME(SIf.Par.udiSensorTime_ms);
		fbTimerHangerDeleteNoDetected();
		
		// Signal valid. Set info buffer empty, if not prevented.
		IF ((fbTimerHangerDeleteNoDetected.Q = TRUE) AND (SIf.Cfg.bolDisableBufferDelete = FALSE)) THEN
			SIf.Cur.dinNumOfHangersInBuffer := 0;
		END_IF
		
		// sensor has at least one hanger detected
		IF (SIf.Cur.dinNumOfHangersInBuffer <= 0)  AND (SIf.In.bolHangerDetected.intern) THEN
			SIf.Cur.dinNumOfHangersInBuffer := 1;
		END_IF
	END_IF
	
	//If buffer full detected, set number of hangers in buffer to max. capacity
	IF ((SIf.Cur.bolBufferFull = TRUE) AND (SIf.Cfg.bolHasBufferFullSensor = TRUE)) THEN	
		SIf.Cur.dinNumOfHangersInBuffer:= Sif.Cfg.dinMaxCapacity;
	END_IF
	
	// Limit Counter to max capacity
	IF SIf.Cur.dinNumOfHangersInBuffer > SIf.Cfg.dinMaxCapacity THEN
		SIf.Cur.dinNumOfHangersInBuffer:= SIf.Cfg.dinMaxCapacity;
	END_IF
	
	// Limit Counter to min capacity
	IF SIf.Cur.dinNumOfHangersInBuffer < 0 THEN
		SIf.Cur.dinNumOfHangersInBuffer:= 0;
	END_IF
	
	// calculate max number of hangers could release per pulse
	IF (SIf.Cur.dinNumOfHangersInBuffer<=SIf.Cfg.uinNumOfHangersPerPulse) THEN
		dinNumOfHangersToRelease := SIf.Cur.dinNumOfHangersInBuffer;
	ELSE
		dinNumOfHangersToRelease := SIf.Cfg.uinNumOfHangersPerPulse;
	END_IF
END_IF


// ----------------------------------------------------------------------------------
// Always change actions in Base Library
// ----------------------------------------------------------------------------------
// overrule error always from base -> no EOFF State!! in EOFF go to OFF
IF (me.StateMachine.intStateNext = cSTA_EOFFBusy) THEN
	IF (me.StateMachine.intState=cSTA_OFF) THEN
		me.StateMachine.intStateNext := cSTA_OFF;
	ELSE // stay in OFF
		me.StateMachine.intStateNext := cSTA_OFFBusy;
	END_IF
END_IF

// Conditions Always
IF (((me.Alarm.eActivAlmClass=E_AlmClass.EOFF) OR (me.Alarm.eActivAlmClass=E_AlmClass.OFF) OR (me.intCmd=cCMD_OFF))
		 AND (me.StateMachine.intState<>cSTA_ERROR) AND (me.StateMachine.intState<>cSTA_ERRORQuit) AND
		(me.StateMachine.intState<>cSTA_OFF) AND (me.StateMachine.intState<>cSTA_OFFBusy)) THEN
	// alarm evt EOFF, OFF or cmd off
	me.StateMachine.intStateNext := cSTA_OFFBusy;
END_IF]]></ST>
      </Implementation>
      <ObjectProperties />
    </Method>
    <Method Name="sta_RELEASE" Id="{632ac101-26b3-4df8-93c4-c1c54c4c55bc}">
      <Declaration><![CDATA[METHOD PROTECTED sta_RELEASE : BOOL
]]></Declaration>
      <Implementation>
        <ST><![CDATA[// state implemetation
//--------------------------------------------------------------------------------------
// Entry action
	IF (me.StateMachine.intState<>me.StateMachine.intStateLastCycle) THEN
		me.StateMachine.intStateLastCycle := me.StateMachine.intState;
			
		;
	END_IF

//--------------------------------------------------------------------------------------
// Cyclic action
	IF (me.StateMachine.intState=me.StateMachine.intStateLastCycle) THEN
		
		// Switch valve off, cylinder back to extend position -> stop hanger
		SIf.Out.bolRetract.intern := FALSE;
		SIf.Out.bolRetract2.intern := TRUE;	
		
		// State Change Condition
		IF (me.intCmd=cCMD_STOP) THEN
			me.StateMachine.intStateNext := cSTA_STOPBusy;
		ELSIF(me.intCmd=STB_CmdState.cCMD_RELEASE_ALL) THEN
			me.StateMachine.intStateNext := STB_CmdState.cSTA_RELEASE_ALLBusy;
		END_IF
		
	END_IF

//--------------------------------------------------------------------------------------
// Exit action
	IF (me.StateMachine.intState<>me.StateMachine.intStateNext) THEN
		;
	END_IF]]></ST>
      </Implementation>
      <ObjectProperties />
    </Method>
    <Method Name="sta_OFFBusy" Id="{b19a9664-e214-4c42-b4a8-fc9e0c839d71}">
      <Declaration><![CDATA[METHOD PROTECTED sta_OFFBusy : BOOL
]]></Declaration>
      <Implementation>
        <ST><![CDATA[// state implemetation
//--------------------------------------------------------------------------------------
// Entry action
	IF (me.StateMachine.intState<>me.StateMachine.intStateLastCycle) THEN
		me.StateMachine.intStateLastCycle := me.StateMachine.intState;
			
	END_IF

//--------------------------------------------------------------------------------------
// Cyclic action
	IF (me.StateMachine.intState=me.StateMachine.intStateLastCycle) THEN
		
		// Switch valve off, cylinder back to extend position -> stop hanger
		SIf.Out.bolRetract.intern := FALSE;
		SIf.Out.bolRetract2.intern := TRUE;	
			
		// State Change Condition
		IF (FALSE) THEN
			;
		ELSIF (TRUE) THEN
			me.StateMachine.intStateNext := cSTA_OFF;
		END_IF
	END_IF


//--------------------------------------------------------------------------------------
// Exit action
	IF (me.StateMachine.intState<>me.StateMachine.intStateNext) THEN
		;
	END_IF]]></ST>
      </Implementation>
      <ObjectProperties />
    </Method>
    <Method Name="IoOutBridge" Id="{0f03536d-f025-4705-ae1a-ea848a9ae9d3}">
      <Declaration><![CDATA[METHOD PROTECTED IoOutBridge : BOOL
]]></Declaration>
      <Implementation>
        <ST><![CDATA[// digitale and analoge inputs read from hardware or forcing
IF (CIf.SwCfg.bolSimulation = FALSE) THEN
	setOutBol(CIf.Job.bolIoForce ,ADR(SIf.Out.bolRetract));
	
	// check interlocks to prevent damages
	IF (CIf.Job.bolIlkOverwrite=FALSE) THEN
		IF (SIf.Ilk.bolRetract=TRUE) THEN
			// switch off?
			IF (SIf.Out.bolRetract.map = TRUE) THEN
				// Set alarm: SIf.Alm[2].strText := 'interlock retract - movement stopped';				
				pfbAlarmCtrl^.setAlarm(CIf.Info.intCtrlId,2,0,ADR(SIf.Alm),E_AlmState.RST,CIf.Job.eMe_ActivAlmClass);				
			END_IF
			SIf.Out.bolRetract.map := FALSE;
		END_IF	
	END_IF
	THIS^.Out_bolRetract := SIf.Out.bolRetract.map;
	


	setOutBol(CIf.Job.bolIoForce ,ADR(SIf.Out.bolRetract2));
	
	// check interlocks to prevent damages
	IF (CIf.Job.bolIlkOverwrite=FALSE) THEN
		IF (SIf.Ilk.bolRetract=TRUE) THEN
			// switch off?
			IF (SIf.Out.bolRetract2.map = TRUE) THEN
				// Set alarm: SIf.Alm[2].strText := 'interlock retract - movement stopped';				
				pfbAlarmCtrl^.setAlarm(CIf.Info.intCtrlId,2,0,ADR(SIf.Alm),E_AlmState.RST,CIf.Job.eMe_ActivAlmClass);				
			END_IF
			SIf.Out.bolRetract2.map := FALSE;
		END_IF	
	END_IF
	THIS^.Out_bolRetract2 := SIf.Out.bolRetract2.map;
	
END_IF]]></ST>
      </Implementation>
      <ObjectProperties />
    </Method>
    <Method Name="sta_RELEASE_ALL" Id="{c270598d-9370-48c3-a25d-857fdb3c4555}">
      <Declaration><![CDATA[METHOD PROTECTED sta_RELEASE_ALL : BOOL
]]></Declaration>
      <Implementation>
        <ST><![CDATA[// state implemetation
//--------------------------------------------------------------------------------------
// Entry action
	IF (me.StateMachine.intState<>me.StateMachine.intStateLastCycle) THEN
		me.StateMachine.intStateLastCycle := me.StateMachine.intState;	
		;
	END_IF

//--------------------------------------------------------------------------------------
// Cyclic action
	IF (me.StateMachine.intState=me.StateMachine.intStateLastCycle) THEN
		

		// State Change Condition
		IF ((me.intCmd=cCMD_STOP) OR (me.intCmd=STB_CmdState.cCMD_RELEASE)) THEN
			me.StateMachine.intStateNext := cSTA_STOPBusy;
		END_IF
	END_IF

//--------------------------------------------------------------------------------------
// Exit action
	IF (me.StateMachine.intState<>me.StateMachine.intStateNext) THEN
		;
	END_IF]]></ST>
      </Implementation>
      <ObjectProperties />
    </Method>
    <Method Name="sta_STOPBusy" Id="{fa71967a-09ac-4c86-8f4f-c89b8ab9a30e}">
      <Declaration><![CDATA[METHOD PROTECTED sta_STOPBusy : BOOL
]]></Declaration>
      <Implementation>
        <ST><![CDATA[// state implemetation
//--------------------------------------------------------------------------------------
// Entry action
	IF (me.StateMachine.intState<>me.StateMachine.intStateLastCycle) THEN
		me.StateMachine.intStateLastCycle := me.StateMachine.intState;

	END_IF


//--------------------------------------------------------------------------------------
// Cyclic action
	IF (me.StateMachine.intState=me.StateMachine.intStateLastCycle) THEN
			
		// Switch valve off, cylinder back to extend position -> stop hanger
		SIf.Out.bolRetract.intern := FALSE;
		SIf.Out.bolRetract2.intern := TRUE;	
				
		// State Change Condition
		IF (me.StateMachine.udiTimeInState_ms > SIf.Par.udiPulseLengthValve_ms) THEN
			me.StateMachine.intStateNext := cSTA_STOP;
		END_IF
	END_IF


//--------------------------------------------------------------------------------------
// Exit action
	IF (me.StateMachine.intState<>me.StateMachine.intStateNext) THEN
		;
	END_IF]]></ST>
      </Implementation>
      <ObjectProperties />
    </Method>
    <Method Name="sta_STOP" Id="{3c0c90f2-7045-48fe-9051-251cd0301b10}">
      <Declaration><![CDATA[METHOD PROTECTED sta_STOP : BOOL
]]></Declaration>
      <Implementation>
        <ST><![CDATA[// state implemetation
//--------------------------------------------------------------------------------------
// Entry action
	IF (me.StateMachine.intState<>me.StateMachine.intStateLastCycle) THEN
		me.StateMachine.intStateLastCycle := me.StateMachine.intState;
		
		bolErrorPosLost:= FALSE;
		uinPosEdgeCounter:= 0;
	END_IF


//--------------------------------------------------------------------------------------
// Cyclic action
	IF (me.StateMachine.intState=me.StateMachine.intStateLastCycle) THEN
	
		//--------------------------------------------------------------------
		// Monitoring for cylinder position lost
		//--------------------------------------------------------------------
		IF (Sif.cfg.bolCylPosLostMonitoring=TRUE) THEN
			
			// -> Checked indirectly via sensor "buffer full" or "hanger detected" if exist.
			
			// Decision, which sensor should be used for monitoring
			// Prio 1. Always use the hanger detection sensor if exists
			IF (SIf.Cfg.bolHasHangerDetection = TRUE) THEN
				// Use hanger detection sensor signal
				bolSignalForPosLostMonitoring:= SIf.In.bolHangerDetected.intern;
			ELSE
				// Prio 2. Check if buffer full sensor exists 
				IF (SIf.Cfg.bolHasBufferFullSensor = TRUE) THEN
					// Use buffer full sensor signal
					bolSignalForPosLostMonitoring:= SIf.In.bolBufferFull.intern;
				ELSE
					// No sensor exist. Not possible to monitor cylinder position lost! 
					bolSignalForPosLostMonitoring:= FALSE;
				END_IF
			END_IF
				
			// Count sensor pos. edges
			IF ((bolSignalForPosLostMonitoring <> bolSignalForPosLostMonitoringOld) AND (bolSignalForPosLostMonitoring = TRUE))THEN	
				uinPosEdgeCounter:= uinPosEdgeCounter + 1;
			END_IF
			bolSignalForPosLostMonitoringOld:= bolSignalForPosLostMonitoring;
						
			// Check condition for set error
			// Wait until the counter is > than dinMaxNumOfHangers_PosMonitoring
			IF (uinPosEdgeCounter > SIf.Cfg.dinMaxNumOfHangers_PosMonitoring) THEN
				bolErrorPosLost:= TRUE;
			END_IF
			
		END_IF
		
		//--------------------------------------------------------------------
		//--------------------------------------------------------------------
		
		// State Change Condition	
		// Error cylinder position lost
		IF ((bolErrorPosLost=TRUE) AND (Sif.cfg.bolCylPosLostMonitoring=TRUE))THEN
			// SIf.Alm[3].strText := 'Cylinder position lost. Hangers slip through';
			pfbAlarmCtrl^.setAlarm(CIf.Info.intCtrlId,3,0,ADR(SIf.Alm),E_AlmState.RST,CIf.Job.eMe_ActivAlmClass);
			bolErrorPosLost:= FALSE;
			uinPosEdgeCounter:= 0;
			me.StateMachine.intStateNext := cSTA_ERROR;
		ELSIF (me.intCmd=STB_CmdState.cCMD_RELEASE) THEN 
			me.StateMachine.intStateNext := STB_CmdState.cSTA_RELEASEBusy;
		ELSIF(me.intCmd=STB_CmdState.cCMD_RELEASE_ALL) THEN
			me.StateMachine.intStateNext := STB_CmdState.cSTA_RELEASE_ALLBusy;
		END_IF
	END_IF

//-------------------------------------------------------------------------------------
// Exit action
	IF (me.StateMachine.intState<>me.StateMachine.intStateNext) THEN
		;
	END_IF]]></ST>
      </Implementation>
      <ObjectProperties />
    </Method>
    <Method Name="sta_RELEASEBusy" Id="{f328c702-0720-4a71-8360-94db243f4c87}">
      <Declaration><![CDATA[METHOD PROTECTED sta_RELEASEBusy : BOOL
]]></Declaration>
      <Implementation>
        <ST><![CDATA[// state implemetation
//--------------------------------------------------------------------------------------
// Entry action
	IF (me.StateMachine.intState<>me.StateMachine.intStateLastCycle) THEN
		me.StateMachine.intStateLastCycle := me.StateMachine.intState;

		// Check if min. one hanger exist and save info tmp. Used for counting in state RELEASE.	
		IF (SIf.In.bolHangerDetected.intern = TRUE) THEN
			bolHangerDetected:= TRUE;
		ELSE
			bolHangerDetected:= FALSE;
		END_IF
	
	END_IF

//--------------------------------------------------------------------------------------
// Cyclic action
	IF (me.StateMachine.intState=me.StateMachine.intStateLastCycle) THEN
		
		// Switch valve on, cylinder to retract position -> release hanger
		SIf.Out.bolRetract.intern := TRUE;
		SIf.Out.bolRetract2.intern := FALSE;	
		
		// State Change Condition
		IF (me.StateMachine.udiTimeInState_ms > SIf.Par.udiPulseLengthValve_ms) THEN
			me.StateMachine.intStateNext := STB_CmdState.cSTA_RELEASE;
	
			// Update all counters. Only if a hanger was detected before.
			// If no hanger detection sensor exists, count unconditional with every cylinder stroke
			IF (bolHangerDetected = TRUE) OR (SIf.Cfg.bolHasHangerDetection = FALSE) THEN
				
				// Note: Only for separator the number of hangers per pulse corresponds exactly the real number of passed hangers.
				// For all other units like e.g. double stopper it's only an approximate number.
			
				IF (SIf.Cfg.bolHasDecrementSensor = FALSE) THEN // Else do it in Method Always
					IF (SIf.Cfg.bolHasBufferFullSensor = TRUE AND SIf.In.bolBufferFull.intern = FALSE) THEN
						// Calculate number of hangers in buffer dependent number of hangers per pulse
						SIf.Cur.dinNumOfHangersInBuffer:= SIf.Cur.dinNumOfHangersInBuffer - dinNumOfHangersToRelease;
					ELSIF SIf.Cfg.bolHasBufferFullSensor = FALSE THEN
						// Calculate number of hangers in buffer dependent number of hangers per pulse
						SIf.Cur.dinNumOfHangersInBuffer:= SIf.Cur.dinNumOfHangersInBuffer - dinNumOfHangersToRelease;						
					END_IF
				END_IF
					
				// Calculate total counter dependent number of hangers per pulse
				SIf.Cur.dinHangersPassedTotal:= SIf.Cur.dinHangersPassedTotal + dinNumOfHangersToRelease;
				
				bolHangerDetected:= FALSE;
			END_IF
				
		END_IF
		
	END_IF

//--------------------------------------------------------------------------------------
// Exit action
	IF (me.StateMachine.intState<>me.StateMachine.intStateNext) THEN
		;
	END_IF]]></ST>
      </Implementation>
      <ObjectProperties />
    </Method>
    <Method Name="getCtrlSIf" Id="{99555eec-c051-410d-91b9-b5883a5dedd6}">
      <Declaration><![CDATA[METHOD getCtrlSIf : POINTER TO T_Ctrl_SIf_STB
]]></Declaration>
      <Implementation>
        <ST><![CDATA[getCtrlSIf := ADR(SIf);]]></ST>
      </Implementation>
      <ObjectProperties />
    </Method>
    <Method Name="StateMachine" Id="{60edfbe2-6778-4705-a02d-64a3ed232fe1}">
      <Declaration><![CDATA[METHOD PROTECTED StateMachine : BOOL
]]></Declaration>
      <Implementation>
        <ST><![CDATA[SUPER^.StateMachine();

// main statemachine of base controller
CASE me.StateMachine.intState OF
    cSTA_STOPBusy: 
        THIS^.sta_STOPBusy();
    cSTA_STOP: 
        THIS^.sta_STOP();
    STB_CmdState.cSTA_RELEASE_ALLBusy: 
        THIS^.sta_RELEASE_ALLBusy();
    STB_CmdState.cSTA_RELEASE_ALL: 
        THIS^.sta_RELEASE_ALL();
    STB_CmdState.cSTA_RELEASEBusy: 
        THIS^.sta_RELEASEBusy();
    STB_CmdState.cSTA_RELEASE: 
        THIS^.sta_RELEASE();
END_CASE;


]]></ST>
      </Implementation>
      <ObjectProperties />
    </Method>
    <Method Name="IoInBridge" Id="{1224cd93-39ea-497c-a70b-3f687cc7f11c}">
      <Declaration><![CDATA[METHOD PROTECTED IoInBridge : BOOL
]]></Declaration>
      <Implementation>
        <ST><![CDATA[// digitale and analoge inputs read from hardware or forcing

SIf.In.bolHangerDetected.map := THIS^.In_bolHangerDetected;
SIf.In.bolBufferFull.map := THIS^.In_bolBufferFull;
SIf.In.bolDecrementCounter.map := THIS^.In_bolDecrementCounter;

IF (CIf.SwCfg.bolSimulation = FALSE) THEN
	getInBolDebounced(CIf.Job.bolIoForce, me.FUBInfo.udiSample_ms, Sif.par.udiDebounceTime_ms, ADR(SIf.In.bolHangerDetected));
	getInBolDebounced(CIf.Job.bolIoForce, me.FUBInfo.udiSample_ms, Sif.par.udiDebounceTime_ms, ADR(SIf.In.bolBufferFull));
	getInBolDebounced(CIf.Job.bolIoForce, me.FUBInfo.udiSample_ms, Sif.par.udiDebounceTime_ms, ADR(SIf.In.bolDecrementCounter));
	//ctrl.In.bol_PosSwitchBasicDefTyp.intern := getInBol(ctrl.ifc.Job.bol_Force ,ADR(ctrl.In.bol_PosSwitchBasicDefTyp);
ELSE
	//simulation of global IO
END_IF
]]></ST>
      </Implementation>
      <ObjectProperties />
    </Method>
    <Method Name="sta_OFF" Id="{8243a118-f2f7-4983-a7f3-41508662bd93}">
      <Declaration><![CDATA[METHOD PROTECTED sta_OFF : BOOL
]]></Declaration>
      <Implementation>
        <ST><![CDATA[// state implemetation
//--------------------------------------------------------------------------------------
// Entry action
	IF (me.StateMachine.intState<>me.StateMachine.intStateLastCycle) THEN
		me.StateMachine.intStateLastCycle := me.StateMachine.intState;
		
		// Reset total counter
		SIf.Cur.dinHangersPassedTotal:= 0;
	END_IF


//--------------------------------------------------------------------------------------
// Cyclic action
	IF (me.StateMachine.intState=me.StateMachine.intStateLastCycle) THEN
		
	
		// State Change Condition
		IF (me.Alarm.eActivAlmClass<>E_AlmClass.EOFF) AND (me.Alarm.eActivAlmClass<>E_AlmClass.OFF) THEN
			IF (me.intCmd=cCMD_STOP) THEN
				me.StateMachine.intStateNext :=  cSTA_STOPBusy;
			ELSIF (me.intCmd=STB_CmdState.cCMD_RELEASE) THEN 
				me.StateMachine.intStateNext := STB_CmdState.cSTA_RELEASEBusy;
			ELSIF(me.intCmd=STB_CmdState.cCMD_RELEASE_ALL) THEN
				me.StateMachine.intStateNext := STB_CmdState.cSTA_RELEASE_ALLBusy;
			END_IF
		END_IF
	END_IF


//--------------------------------------------------------------------------------------
// Exit action
	IF (me.StateMachine.intState<>me.StateMachine.intStateNext) THEN
		;
	END_IF]]></ST>
      </Implementation>
      <ObjectProperties />
    </Method>
    <Method Name="FB_init" Id="{e23b9092-ed4a-4478-b59f-4d0b1a5a781e}">
      <Declaration><![CDATA[METHOD FB_init : BOOL
VAR_INPUT
	///if TRUE, the retain variables are initialized (warm start / cold start)
	bInitRetains: BOOL;
	///if TRUE, the instance afterwards gets moved into the copy code (online change)
	bInCopyCode: BOOL;
END_VAR
VAR
	ii: UINT;
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[//------------------------------------------------------------------------------------------------------------------------
// to manually change in new FUB implementation!!!
// define valid commands for this controller
FOR ii:= 0 TO (SIZEOF(CIf.Job.aCmdList)/SIZEOF(CIf.Job.aCmdList[0])-1) BY 1 DO
	IF (CIf.Job.aCmdList[ii].intCmd=cCMD_INITIALIZED) THEN
		// found first empty array element
		EXIT;
	END_IF
END_FOR

CIf.Job.aCmdList[ii].intCmd := cCMD_STOP;
CIf.Job.aCmdList[ii].strName := 'Stop'; 
CIf.Job.aCmdList[ii].bolAvailable := TRUE;
ii := ii +1;
CIf.Job.aCmdList[ii].intCmd := STB_CmdState.cCMD_RELEASE_ALL;
CIf.Job.aCmdList[ii].strName := 'Release All';
CIf.Job.aCmdList[ii].bolAvailable := TRUE;
ii := ii +1;
CIf.Job.aCmdList[ii].intCmd := STB_CmdState.cCMD_RELEASE;
CIf.Job.aCmdList[ii].strName := 'Release';
CIf.Job.aCmdList[ii].bolAvailable := TRUE;

// set name of class/typ
CIf.Info.strType := 'FB_STB'; 

// set alarm class
SIf.Alm[1].eAlmClass := E_AlmClass.STOP;
SIf.Alm[1].strText := 'Timeout buffer emptying';
SIf.Alm[2].eAlmClass := E_AlmClass.STOP;
SIf.Alm[2].strText := 'interlock retract - movement stopped';
SIf.Alm[3].eAlmClass := E_AlmClass.STOP;
SIf.Alm[3].strText := 'Cylinder position lost. Hangers slip through';

//*******************************************************************************
// initial values
//*******************************************************************************

// software configuration
CIf.SwCfg.bolExist := TRUE;
CIf.SwCfg.bolSimulation := FALSE;

// parameter
SIf.Par.udiIntervalBufferEmptying_ms := 2000;
SIf.Par.udiPulseLengthValve_ms := 500;
SIf.Par.udiSensorTime_ms := 3000;
SIf.Par.udiTimeoutBufferEmptying_ms := 120000; // 2 min
SIf.Par.usiBuffermode := 1;
SIf.Par.udiReleaseAllTime_ms := 4000;
Sif.par.udiDebounceTime_ms:= 20;

// configuration
SIf.Cfg.bolHasBufferFullSensor := FALSE;
SIf.Cfg.bolHasHangerDetection:= TRUE;
SIf.Cfg.bolHasDecrementSensor:= FALSE;
SIf.Cfg.bolDisableBufferDelete:= FALSE;
SIf.Cfg.dinMaxCapacity:= 20;
SIf.Cfg.dinMaxNumOfHangers_PosMonitoring := 2;
SIf.Cfg.uinNumOfHangersPerPulse:= 1;
SIF.Cfg.bolCylPosLostMonitoring:= FALSE;
SIF.Cfg.bolReleaseAllNonPulse:= FALSE;]]></ST>
      </Implementation>
      <ObjectProperties />
    </Method>
    <Property Name="MaxCapacity" Id="{256d9eb0-306a-401c-85d7-7a9719e136a2}">
      <Declaration><![CDATA[PROPERTY MaxCapacity : DINT
]]></Declaration>
      <Get Name="Get" Id="{d30829d5-0fc1-4ff9-892f-6d83783b8622}">
        <Declaration><![CDATA[]]></Declaration>
        <Implementation>
          <ST><![CDATA[MaxCapacity:= SIf.Cfg.dinMaxCapacity;]]></ST>
        </Implementation>
        <ObjectProperties />
      </Get>
      <ObjectProperties />
    </Property>
    <Property Name="NumOfHangers" Id="{822b849a-4311-453d-bb33-2d88fe6ce437}">
      <Declaration><![CDATA[PROPERTY NumOfHangers : DINT
]]></Declaration>
      <Get Name="Get" Id="{e2246cfd-4605-4527-999d-ad7531b10351}">
        <Declaration><![CDATA[]]></Declaration>
        <Implementation>
          <ST><![CDATA[NumOfHangers:= SIf.Cur.dinNumOfHangersInBuffer;]]></ST>
        </Implementation>
        <ObjectProperties />
      </Get>
      <ObjectProperties />
    </Property>
    <ObjectProperties />
  </POU>
</TcPlcObject>