<?xml version="1.0" encoding="utf-8"?>
<TcPlcObject Version="1.1.0.1" ProductVersion="3.1.4019.2">
  <POU Name="FB_ICL" Id="{02a250b4-4676-41ca-9fdd-76c07d8e8914}" SpecialFunc="None">
    <Declaration><![CDATA[FUNCTION_BLOCK FB_ICL EXTENDS FB_CtrlModule
VAR
	/// Specific interface struct for public access
	SIf: T_Ctrl_SIf_ICL;
	/// List of childs specific interface for additional parameters or cur	
	pDPJ_4_SIF: POINTER TO T_Ctrl_SIf_DPJ;
	pDPJ_9_SIF: POINTER TO T_Ctrl_SIf_DPJ;
	pMER_8_SIF: POINTER TO T_Ctrl_SIf_MTR;
	pCHD_4_SIF: POINTER TO T_Ctrl_SIf_CHD;
	pTLP_4_SIF: POINTER TO T_Ctrl_SIf_DRV;
	pTLK_9_SIF: POINTER TO T_Ctrl_SIf_DRV;
	/// List of child interface	
	pTLP_10_CIf: POINTER TO T_Ctrl_CIf;
END_VAR
VAR_INPUT
	///pointer to function block Junctions Decision Point
	p_fbDPJ_4: POINTER TO FB_DPJ;
	p_fbDPJ_9: POINTER TO FB_DPJ;
	///pointer to function block Merger
	p_fbMER_8: POINTER TO FB_MER;
	///pointer to function block Cross Hanger Detection
	p_fbCHD_4: POINTER TO FB_CHD;
	///pointer to function block Drive
	p_fbTLP_4: POINTER TO FB_DRV;
	p_fbTLP_10: POINTER TO FB_DRV;
	p_fbTLK_9: POINTER TO FB_DRV;
END_VAR
]]></Declaration>
    <Implementation>
      <ST><![CDATA[(* Copyright 2017 Cimpress

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License. *)

(*__________________________________________________________________________________________________
¦	
¦	Vistaprint Schweiz GmbH
¦	CH - 8401 Winterthur
¦
¦	www.vistaprint.ch - info@vistaprint.ch
¦___________________________________________________________________________________________________

Function desription:
In Cell Binning Module Controller
The whole module from In Cell binning is controlled, commandos over Common Interface from Line Controller
controll and check childs


History:
Version		Date			Author		Comment
---------------------------------------------------------------------------------------------------
0.00.1		30.08.2013		AVM/PRE		Start history
0.00.2		19.09.2013		AVME/PRE	Implement new Base Concept
0.00.3		28.09.2013		VP/RE		Removed temperature, fuse and airPressure handling, its handled by SFT now
0.00.4		03.10.2013		AVME/PRE	Give speed and position from TLK9 to MER8
0.00.5		24.10.2013		AVME/MRU	CHD added
0.00.6		21.11.2013		AVME/MRU	New BaseHts added
0.00.7		06.12.2013		AVME/DSC	New BaseHts V0.0.0.8 added.
0.00.8		09.12.2013		AVME/DSC	New BaseHts V0.0.0.9 added. Change in state STOP. Clear pending command to prevent automatic recovery!
0.00.9		11.12.2013		AVME/MRU	New BaseHts V0.0.0.10 added. Change in state OFF and STOPBusy. 
										Clear pending command to prevent automatic recovery!

___________________________________________________________________________________________________*)

SUPER^();]]></ST>
    </Implementation>
    <Method Name="CtrlInit" Id="{3492776b-3f49-40a6-ac0f-02e7683c14ba}">
      <Declaration><![CDATA[METHOD PUBLIC CtrlInit : BOOL
]]></Declaration>
      <Implementation>
        <ST><![CDATA[SUPER^.CtrlInit();

//initialize DRV
pTLP_4_SIF := p_fbTLP_4^.getCtrlSIf();
pTLK_9_SIF := p_fbTLK_9^.getCtrlSIf();
pTLP_10_CIf := p_fbTLP_10^.CtrlCIf;
//initialize all other Child controller.
pDPJ_4_SIF := p_fbDPJ_4^.getCtrlSIf();
pDPJ_9_SIF := p_fbDPJ_9^.getCtrlSIf();
pMER_8_SIF := p_fbMER_8^.getCtrlSIf();
pCHD_4_SIF := p_fbCHD_4^.getCtrlSIf();]]></ST>
      </Implementation>
    </Method>
    <Method Name="IoOutBridge" Id="{4dab2c97-99b0-4c22-a400-9afddc21a41a}">
      <Declaration><![CDATA[METHOD PROTECTED IoOutBridge : BOOL
]]></Declaration>
      <Implementation>
        <ST><![CDATA[SUPER^.IoOutBridge();
// digitale and analoge inputs read from hardware or forcing
IF (CIf.SwCfg.bolSimulation = FALSE) THEN
	// check interlocks to prevent damages
	IF (CIf.Job.bolIlkOverwrite=FALSE) THEN
	
		;
	END_IF
END_IF]]></ST>
      </Implementation>
    </Method>
    <Method Name="getCmdState" Id="{56732ee2-bf16-496a-ba6f-e89bdde02a52}">
      <Declaration><![CDATA[METHOD PROTECTED getCmdState : STRING
VAR_INPUT
	intCmdState: INT;
	bolState: BOOL;
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[getCmdState := SUPER^.getCmdState(intCmdState:=intCmdState,bolState:=bolState); // get global/base defined cmds/states
IF (getCmdState='') THEN // global not defined get local
	// get string cmd/state string information in runtime
	IF (bolState=FALSE) THEN
		// cmd's
	ELSE
	
	// cmd's
		CASE intCmdState OF
				
		END_CASE;
	END_IF
END_IF
]]></ST>
      </Implementation>
    </Method>
    <Method Name="IoInBridge" Id="{6f37f59f-c9ef-42df-8c69-af6978e78f8f}">
      <Declaration><![CDATA[METHOD PROTECTED IoInBridge : BOOL
]]></Declaration>
      <Implementation>
        <ST><![CDATA[SUPER^.IoInBridge();
// digitale and analoge inputs read from hardware or forcing

IF (CIf.SwCfg.bolSimulation = FALSE) THEN
	;
ELSE
	//simulation of global IO
END_IF
]]></ST>
      </Implementation>
    </Method>
    <Method Name="FB_init" Id="{77eeca91-af8b-4a92-b2db-b61c47d7b920}">
      <Declaration><![CDATA[METHOD FB_init : BOOL
VAR_INPUT
	///if TRUE, the retain variables are initialized (warm start / cold start)
	bInitRetains: BOOL;
	///if TRUE, the instance afterwards gets moved into the copy code (online change)
	bInCopyCode: BOOL;
END_VAR
VAR
	ii: UINT;
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[
//------------------------------------------------------------------------------------------------------------------------
// to manually change in new FUB implementation!!!
// define valid commands for this controller
FOR ii:= 0 TO (SIZEOF(CIf.Job.aCmdList)/SIZEOF(CIf.Job.aCmdList[0])-1) BY 1 DO
	IF (CIf.Job.aCmdList[ii].intCmd=cCMD_INITIALIZED) THEN
		// found first empty array element
		EXIT;
	END_IF
END_FOR


// set name of class/typ
CIf.Info.strType := 'FB_ICL'; 


//*******************************************************************************
// Handling for SIf between this and base module  
//*******************************************************************************
// initialize pointer access 
SUPER^.SIf_Cfg:= ADR(SIf.Cfg.Module);
SUPER^.SIf_Par:= ADR(SIf.Par.Module);
SUPER^.SIf_Cur:= ADR(SIf.Cur.Module);
SUPER^.SIf_In:= ADR(SIf.In.Module);

//*******************************************************************************
// initial values
//*******************************************************************************
// software configuration
CIf.SwCfg.bolExist := TRUE;
CIf.SwCfg.bolSimulation := FALSE;

// parmeter
SIf.Par.udiTimeDriveStart_ms := 4000;
SIf.Par.udiTimeDriveStop_ms := 2000;

//*******************************************************************************
// initial values for base module
//*******************************************************************************
// Configuration
SIf.Cfg.Module.bolComToLineControlEnabled:= FALSE;
// Parameter
SIf.Par.Module.udiComTimeOutLineCtrl_ms:= 10000;
SIf.Par.Module.udiTimeoutStopping_ms:= 30000;
FOR ii:= 0 TO Base_Const.cMaxNrOfChilds DO
	SIf.Par.Module.aListOfRunGrpWaitTime_ms[ii] := 999;
	SIf.Par.Module.aListOfStopGrpWaitTime_ms[ii] := 999;
END_FOR
]]></ST>
      </Implementation>
    </Method>
    <Method Name="sta_RUN" Id="{808e6c7f-401c-4798-81e9-d749bc0c2149}">
      <Declaration><![CDATA[METHOD PROTECTED sta_RUN : BOOL
]]></Declaration>
      <Implementation>
        <ST><![CDATA[// state implemetation
//--------------------------------------------------------------------------------------
// Entry action
	IF (me.StateMachine.intState<>me.StateMachine.intStateLastCycle) THEN
		me.StateMachine.intStateLastCycle := me.StateMachine.intState;
		;
	END_IF

//--------------------------------------------------------------------------------------
// Cyclic action
	IF (me.StateMachine.intState=me.StateMachine.intStateLastCycle) THEN

		// Simulation
		IF (CIf.SwCfg.bolSimulation) THEN
			;
		END_IF

		// State Change Condition	
		IF (me.intCmd=cCMD_STOP) THEN
			me.StateMachine.intStateNext :=  cSTA_STOPBusy;	
		END_IF

	END_IF

//--------------------------------------------------------------------------------------
// Exit action
	IF (me.StateMachine.intState<>me.StateMachine.intStateNext) THEN
		;
	END_IF

]]></ST>
      </Implementation>
    </Method>
    <Method Name="sta_OFF" Id="{8e5d69b0-1f3d-4ab3-a409-1f81bdacc77c}">
      <Declaration><![CDATA[METHOD PROTECTED sta_OFF : BOOL
]]></Declaration>
      <Implementation>
        <ST><![CDATA[// state implemetation
//--------------------------------------------------------------------------------------
// Entry action
	IF (me.StateMachine.intState<>me.StateMachine.intStateLastCycle) THEN
		me.StateMachine.intStateLastCycle := me.StateMachine.intState;
		;		
	END_IF

//--------------------------------------------------------------------------------------
// Cyclic action
	IF (me.StateMachine.intState=me.StateMachine.intStateLastCycle) THEN
				
		// State Change Condition
		IF (me.Alarm.eActivAlmClass<>E_AlmClass.EOFF) AND (me.Alarm.eActivAlmClass<>E_AlmClass.OFF) THEN
			IF (me.intCmd=cCMD_RUN) THEN 
				me.StateMachine.intStateNext := cSTA_RUNBusy;
			END_IF
		ELSE
			// Clear pending command to prevent automatic recovery!
			CIf.Job.intACmd:=cSTA_DONE;
		END_IF
	END_IF

//--------------------------------------------------------------------------------------
// Exit action
	IF (me.StateMachine.intState<>me.StateMachine.intStateNext) THEN
		;
	END_IF]]></ST>
      </Implementation>
    </Method>
    <Method Name="StateMachine" Id="{b3a5b6f1-4248-4779-8017-4c41a94f29a4}">
      <Declaration><![CDATA[METHOD PROTECTED StateMachine : BOOL
]]></Declaration>
      <Implementation>
        <ST><![CDATA[SUPER^.StateMachine();

// main statemachine of base controller
CASE me.StateMachine.intState OF
    cSTA_RUN: 
        THIS^.sta_RUN();
    cSTA_STOP: 
        THIS^.sta_STOP();	
END_CASE;
]]></ST>
      </Implementation>
    </Method>
    <Method Name="getCtrlSIf" Id="{e0645c96-129d-4e27-bee9-56f0e4f35ff0}">
      <Declaration><![CDATA[METHOD getCtrlSIf : POINTER TO T_Ctrl_SIf_ICL
]]></Declaration>
      <Implementation>
        <ST><![CDATA[getCtrlSIf := ADR(SIf);]]></ST>
      </Implementation>
    </Method>
    <Method Name="sta_STOP" Id="{e0fcc967-bb3c-4fb6-b767-1df9d0caa10a}">
      <Declaration><![CDATA[METHOD PROTECTED sta_STOP : BOOL
]]></Declaration>
      <Implementation>
        <ST><![CDATA[// state implemetation
//--------------------------------------------------------------------------------------
// Entry action
	IF (me.StateMachine.intState<>me.StateMachine.intStateLastCycle) THEN
		me.StateMachine.intStateLastCycle := me.StateMachine.intState;
		
	END_IF


//--------------------------------------------------------------------------------------
// Cyclic action
	IF (me.StateMachine.intState=me.StateMachine.intStateLastCycle) THEN
		
		;
		
		
		// State Change Condition
		IF (me.Alarm.eActivAlmClass<>E_AlmClass.STOP ) THEN
			IF (me.intCmd=cCMD_RUN) THEN
				me.StateMachine.intStateNext :=  cSTA_RUNBusy;
			END_IF
		ELSE
			// Clear pending command to prevent automatic recovery!
			CIf.Job.intACmd:=cSTA_DONE;
		END_IF
	END_IF

//--------------------------------------------------------------------------------------
// Exit action
	IF (me.StateMachine.intState<>me.StateMachine.intStateNext) THEN
		;
	END_IF]]></ST>
      </Implementation>
    </Method>
    <Method Name="Always" Id="{f383c623-6310-4d82-b373-93c3dbe56a8f}">
      <Declaration><![CDATA[METHOD PROTECTED Always : BOOL
]]></Declaration>
      <Implementation>
        <ST><![CDATA[IF (me.bolChangeBackToAUTO=TRUE) THEN // switch mode to automatic switch off controller
	//me.StateMachine.intStateNext := cSTA_OFFBusy;
	//me.bolChangeBackToAUTO := FALSE; // for cylinder no change to off when switch to automatic!!
END_IF

SUPER^.Always();

// ---------------------------------------------------------------------------------
// Simulation
IF (CIf.SwCfg.bolSimulation) THEN
	;
END_IF
	
// ----------------------------------------------------------------------------------
// cyclic actions outside of statemachine
IF (me.StateMachine.intState<>cSTA_SINGLE_ANSWER) THEN
	;
END_IF

// Variable mapping for Childs
pDPJ_4_SIF^.Cur.dinTransportPosition_um := pTLP_4_SIF^.Cur.dinPos_um;
pDPJ_4_SIF^.Cur.dinTransportspeed_um_s := pTLP_4_SIF^.Cur.dinSpeed_um_s;
pDPJ_4_SIF^.Cur.a_bolJunctionOutputOK[0] := TRUE;
pDPJ_4_SIF^.Cur.a_bolJunctionOutputOK[1] := TRUE;

pDPJ_9_SIF^.Cur.dinTransportPosition_um := pTLK_9_SIF^.Cur.dinPos_um;
pDPJ_9_SIF^.Cur.dinTransportspeed_um_s := pTLK_9_SIF^.Cur.dinSpeed_um_s;
pDPJ_9_SIF^.Cur.a_bolJunctionOutputOK[0] := pTLP_10_CIf^.Job.intState = cSTA_RUN;
pDPJ_9_SIF^.Cur.a_bolJunctionOutputOK[1] := TRUE;

// Speed to merger 8
pMER_8_SIF^.Cur.dinTransportPosition_um := pTLK_9_SIF^.Cur.dinPos_um;
pMER_8_SIF^.Cur.dinTransportspeed_um_s := pTLK_9_SIF^.Cur.dinSpeed_um_s;

// Variable mapping for CHD
pCHD_4_SIF^.Cur.dinTransportPosition_um := pTLP_4_SIF^.Cur.dinPos_um;
pCHD_4_SIF^.Cur.dinTransportspeed_um_s := pTLP_4_SIF^.Cur.dinSpeed_um_s;

// ----------------------------------------------------------------------------------
// Conditions Always
// EOFF exist in FB_CtrlModule. Not overrule.
(*
// overrule error always from base -> no EOFF State!! in EOFF go to OFF
IF (me.StateMachine.intStateNext = cSTA_EOFFBusy) THEN
	IF (me.StateMachine.intState=cSTA_OFF) THEN
		me.StateMachine.intStateNext := cSTA_OFF;
	ELSE // stay in OFF
		me.StateMachine.intStateNext := cSTA_OFFBusy;
	END_IF
*)

IF (me.Alarm.eActivAlmClass=E_AlmClass.STOP) AND (me.StateMachine.intStateNext<>cSTA_Error)
		AND ((me.StateMachine.intState = cSTA_RUN) OR (me.StateMachine.intState = cSTA_RUNBusy))THEN
	// alarm evt STOP
	me.StateMachine.intStateNext := cSTA_STOPBusy;	
END_IF
]]></ST>
      </Implementation>
    </Method>
  </POU>
</TcPlcObject>