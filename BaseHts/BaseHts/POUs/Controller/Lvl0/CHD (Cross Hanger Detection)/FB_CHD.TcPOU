<?xml version="1.0" encoding="utf-8"?>
<TcPlcObject Version="1.1.0.1" ProductVersion="3.1.4019.2">
  <POU Name="FB_CHD" Id="{83204994-a22f-49ea-a6fa-4001bfaa8fc8}" SpecialFunc="None">
    <Declaration><![CDATA[FUNCTION_BLOCK FB_CHD EXTENDS FB_CtrlBase
VAR_INPUT
	/// Sensor Slide full
	In_bolPassed: BOOL;
	/// Sensor double hanger
	In_bolDoubleHanger: BOOL;
	/// Sensor inconsistent hanger (as option)
	In_bolInconsistentHanger: BOOL;
	/// Sensor empty hanger (as option)
	In_bolEmptyHanger: BOOL;
	/// Button (as option)
	In_bolRestartTLP: BOOL;
END_VAR
VAR_OUTPUT
	/// switch valve junction
	Out_bolOpen: BOOL;
	/// Blow light sensor
	Out_bolBlow: BOOL;
	/// Info light (as option)
	Out_bolLightTLPStopedByCHD: BOOL;
END_VAR
VAR
	/// Specific interface struct for public access
	SIf: T_Ctrl_SIf_CHD;
	/// standard Loop variable
	uinI: UINT;
	/// Index to next job in Hashtable
	uintNextHastableIdx: UINT;
	/// Index to actual job in Hashtable
	uintActHastableIdx: UINT;
	///Last new position value from parent
	dinTransportPositionOld_um: DINT;
	///Position correction in faster Task cycletime
	dinPositionCorrection_um: DINT;
	///Difference from actual Tag Position to junction
	dinPositionDifference_um: DINT;
	/// Rising edge of passed sensor
	bolFpPassed: BOOL;
	/// Table Index
	uinWriteTblIndex: UINT;
	/// Hashtable
	aTblDecision: ARRAY[0..cuintMaxIndex] OF T_CheckElement;
	/// Transportposition from last cycle
	dinTransportPositionCalc_old_um: DINT;
	/// Driven Way from last to actual cycle
	dinTransportDifferenz_um: DINT;
	/// Check sensor input cross hanger positv edge
	bolWriteInTableOnce: BOOL;
	/// Blow valve timer
	udiBlowPassingTime_ms: UDINT;
	/// Look for empty hanger position
	dinWaitForEmptyHangerPos_um: DINT;
	/// Look for empty hanger activ
	bolWaitForEmptyHanger: BOOL;
	/// Single, empty hanger generates no signal
	dinPositionWithoutSensorSignal: DINT;
	/// Wait time until jam at slide detected
	udinTimeUntilJamDetected: UDINT;
	/// Star tie for jam at slide
	bolTimeForJamOnce: BOOL;
	/// Open or Close at SUB_WAY1
	bolWay1: BOOL;
	/// Open or Close at SUB_WAY2
	bolWay2: BOOL;
	/// Data ready for writing in table
	bolWriteInTable: BOOL;
	/// Some Vars for Simulation
	bolSetSimuPassedOnce: BOOL;
	/// Positve edge double hanger sensor
	bolDoubleHangerOnce: BOOL;
	/// A Hanger in the table has to be cleared
	bolClearHangerOnce: BOOL;
	/// Positve edge of clearing
	bolClearHanger: BOOL;
	/// Save old position
	dinPositionWithoutSensorSignal_OLD: DINT;
	/// Save postion for detection window
	dinPostionShirtDetected: DINT;
END_VAR
VAR CONSTANT
	///sub States for RELEASE Function
	cSTA_SUB_INITIALIZED: INT := 500;
	cSTA_SUB_WAIT_FOR_JOB: INT := 501;
	///cSTA_SUB_OPEN: INT := 502;
	///cSTA_SUB_CLOSE: INT := 506;
	cSTA_SUB_WAY1: INT := 502;
	cSTA_SUB_WAY2: INT := 506;
	cSTA_SUB_ERROR: INT := 598;
	cSTA_SUB_FINISHED: INT := 600;
END_VAR
]]></Declaration>
    <Implementation>
      <ST><![CDATA[(* Copyright 2017 Cimpress

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License. *)

(*__________________________________________________________________________________________________
¦	
¦	Vistaprint Schweiz GmbH
¦	CH - 8401 Winterthur
¦
¦	www.vistaprint.ch - info@vistaprint.ch
¦___________________________________________________________________________________________________

Function desription:
Check the hangers and remove the desired 


History:
Version		Date			Author		Comment
---------------------------------------------------------------------------------------------------
0.00.1 		11.10.2013		AVME/MRU	Copied from JUN / DPJ
0.00.2		24.10.2013		AVME/MRU	Some bugs fixed at commissioning
0.00.3		28.10.2013		AVME/MRU	Some changes for different configurations
0.00.4		29.10.2013		AVME/MRU	Some bugs fixed at commissining
0.00.5		30.10.2013		AVME/MRU	Eliminating of compiler warnings
0.00.6		04.11.2013		AVME/MRU	New behavior on error
0.00.7		26.11.2013		VP/RE		Introduced debounce time for double hanger input. Prevents jitter. Btw: Measured signal duration is ~150ms.
0.00.8		16.12.2013		AVME/MRU	in sta_RUN max. pos. reached, neg. pos starts - Bug fixed

___________________________________________________________________________________________________*)

SUPER^();]]></ST>
    </Implementation>
    <Method Name="FB_init" Id="{1979fe4e-e75f-4e60-8094-41baa764e45c}">
      <Declaration><![CDATA[METHOD FB_init : BOOL
VAR_INPUT
	///if TRUE, the retain variables are initialized (warm start / cold start)
	bInitRetains: BOOL;
	///if TRUE, the instance afterwards gets moved into the copy code (online change)
	bInCopyCode: BOOL;
END_VAR
VAR
	ii: UINT;
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[//------------------------------------------------------------------------------------------------------------------------
// to manually change in new FUB implementation!!!
// define valid commands for this controller
FOR ii:= 0 TO (SIZEOF(CIf.Job.aCmdList)/SIZEOF(CIf.Job.aCmdList[0])-1) BY 1 DO
	IF (CIf.Job.aCmdList[ii].intCmd=cCMD_INITIALIZED) THEN
		// found first empty array element
		EXIT;
	END_IF
END_FOR
CIf.Job.aCmdList[ii].intCmd := cCMD_STOP;
CIf.Job.aCmdList[ii].strName := 'Stop'; 
CIf.Job.aCmdList[ii].bolAvailable := TRUE;
ii := ii +1;
CIf.Job.aCmdList[ii].intCmd := cCMD_RUN;
CIf.Job.aCmdList[ii].strName := 'Run'; 
CIf.Job.aCmdList[ii].bolAvailable := TRUE;
ii := ii +1;
CIf.Job.aCmdList[ii].intCmd := cCMD_STOP;
CIf.Job.aCmdList[ii].strName := 'Stop'; 
CIf.Job.aCmdList[ii].bolAvailable := TRUE;
ii := ii +1;

// set name of class/typ
CIf.Info.strType := 'FB_CHD'; 

// set alarm class
SIf.Alm[1].eAlmClass := E_AlmClass.STOP;
SIf.Alm[1].strText := 'timeout passed sensor does not detect the hanger'; 
SIf.Alm[2].eAlmClass := E_AlmClass.INFO;
SIf.Alm[2].strText := 'Cross hanger detection has an hanger rejected';
SIf.Alm[3].eAlmClass := E_AlmClass.STOP;
SIf.Alm[3].strText := 'Open not possible, destination is full';
SIf.Alm[4].eAlmClass := E_AlmClass.TSTOP;
SIf.Alm[4].strText := 'TLP stopped by CHD';


//*******************************************************************************
// initial values
//*******************************************************************************

// software configuration
CIf.SwCfg.bolExist := TRUE;
CIf.SwCfg.bolSimulation := FALSE;

// parmeter
SIf.Par.udiOpenTime_ms := 20;
SIf.Par.udiCloseTime_ms := 10;
SIf.Par.udiPassTime_ms := 10000;
SIf.Par.udiSimPassTime_ms := 500; // SIf.Par.udiPassTime_ms/2;
SIf.Par.dinPosition_um := 10000000;
SIf.Par.dinOpenWay_um := 300000;
SIf.Par.dinDistanceBetweenSensors_DoubleHangerFirst_um := 100000;
SIf.Par.dinDistanceBetweenSensors_EmptyHangerFirst_um := 100000;
SIf.Par.dinPinDistance_um := 305000;
SIf.Par.udinTimeUntilJam_ms := 1000;
SIf.Par.udiPulseLengthBlowValve_ms := 500;
SIf.Par.udiIntervalLengthBlowValve_ms := 10000;
SIf.Par.udiDebounceTimeDoubleHanger_ms := 80;
//*******************************************************************************
// initial values childes
//*******************************************************************************

]]></ST>
      </Implementation>
    </Method>
    <Method Name="sta_STOPBusy" Id="{27bdf212-39c9-49e4-bb9d-ed4822e2a0c2}">
      <Declaration><![CDATA[METHOD PROTECTED sta_STOPBusy : BOOL
]]></Declaration>
      <Implementation>
        <ST><![CDATA[// state implemetation
//--------------------------------------------------------------------------------------
// Entry action
	IF (me.StateMachine.intState<>me.StateMachine.intStateLastCycle) THEN
		me.StateMachine.intStateLastCycle := me.StateMachine.intState;

	END_IF


//--------------------------------------------------------------------------------------
// Cyclic action
	IF (me.StateMachine.intState=me.StateMachine.intStateLastCycle) THEN

		// Simulation
		
		//no change action
		SIf.Out.bolOpen.intern := FALSE;
		SIf.Out.bolBlow.intern := FALSE;
		
		// State Change Condition
		IF (me.StateMachine.udiTimeInState_ms > SIf.Par.udiCloseTime_ms) THEN
			me.StateMachine.intStateNext := cSTA_STOP;
		END_IF
	END_IF




//--------------------------------------------------------------------------------------
// Exit action
	IF (me.StateMachine.intState<>me.StateMachine.intStateNext) THEN
		;
	END_IF]]></ST>
      </Implementation>
    </Method>
    <Method Name="sta_ERRORQuit" Id="{49bf8e92-d102-45ad-86ec-6bc16293dba7}">
      <Declaration><![CDATA[METHOD PROTECTED sta_ERRORQuit : BOOL
]]></Declaration>
      <Implementation>
        <ST><![CDATA[// state implemetation
//--------------------------------------------------------------------------------------
// Entry action
	IF (me.StateMachine.intState<>me.StateMachine.intStateLastCycle) THEN
		me.StateMachine.intStateLastCycle := me.StateMachine.intState;
	END_IF


//--------------------------------------------------------------------------------------
// Cyclic action
	IF (me.StateMachine.intState=me.StateMachine.intStateLastCycle) THEN
		
		;
		// evtl. wait time if reset of device is necessary and then decide to go to states or ERROR state
		IF ((CIf.Job.bolAlmReset = TRUE) OR 																// Standart Error Reset
			((Cif.Job.eMe_ActivAlmClass = E_AlmClass.TSTOP) AND SIf.In.bolButtonRestartTLP.intern)) THEN	// Reset CHD with own button
			CIf.Job.eMe_ActivAlmClass := E_AlmClass.NONE; // reset feedback channel for parent
			CIf.Job.bolAlmReset := FALSE;
			SIf.Out.bolOpen.intern := FALSE;	// Reset junction after error
			SIf.Out.bolLightTLPStopedByCHD.intern := FALSE;
		END_IF
		
		// State Change Condition
		IF (CIf.Job.bolAlmReset = FALSE) THEN
			IF (me.StateMachine.intStateHistory<=cSTA_PON) THEN
				me.StateMachine.intStateNext := cSTA_PONBusy;
			ELSIF(me.intCmd=cCMD_OFF) THEN
				me.StateMachine.intStateNext := cSTA_OFFBusy;
			ELSIF(me.intCmd=cCMD_RUN) OR (me.StateMachine.intStateHistory=cSTA_RUN) THEN
				me.StateMachine.intStateNext := cSTA_RUNBusy;
			ELSIF(me.intCmd=cCMD_STOP) THEN
				me.StateMachine.intStateNext := cSTA_STOPBusy;
			END_IF
		END_IF
	END_IF




//--------------------------------------------------------------------------------------
// Exit action
	IF (me.StateMachine.intState<>me.StateMachine.intStateNext) THEN
		;
	END_IF]]></ST>
      </Implementation>
    </Method>
    <Method Name="IoOutBridge" Id="{4e916f38-031c-4d9b-b29e-595b166c8d2d}">
      <Declaration><![CDATA[METHOD PROTECTED IoOutBridge : BOOL
]]></Declaration>
      <Implementation>
        <ST><![CDATA[// digitale and analoge inputs read from hardware or forcing
IF (CIf.SwCfg.bolSimulation = FALSE) THEN
	setOutBol(CIf.Job.bolIoForce ,ADR(SIf.Out.bolOpen));
	setOutBol(CIf.Job.bolIoForce ,ADR(SIf.Out.bolBlow));
	setOutBol(CIf.Job.bolIoForce ,ADR(SIf.Out.bolLightTLPStopedByCHD));
	
	THIS^.Out_bolLightTLPStopedByCHD := SIf.Out.bolLightTLPStopedByCHD.map;
	THIS^.Out_bolOpen := SIf.Out.bolOpen.map;
	THIS^.Out_bolBlow := SIf.Out.bolBlow.map;
END_IF]]></ST>
      </Implementation>
    </Method>
    <Method Name="sta_ERROR" Id="{69102711-d580-4b64-af9f-2caf94392ee2}">
      <Declaration><![CDATA[METHOD PROTECTED sta_ERROR : BOOL
]]></Declaration>
      <Implementation>
        <ST><![CDATA[// state implemetation
//--------------------------------------------------------------------------------------
// Entry action
	IF (me.StateMachine.intState<>me.StateMachine.intStateLastCycle) THEN
		me.StateMachine.intStateHistory := me.StateMachine.intStateLastCycle; // -> possibillity to go back to state before error
		me.StateMachine.intStateLastCycle := me.StateMachine.intState;
		
	END_IF


//--------------------------------------------------------------------------------------
// Cyclic action
	IF (me.StateMachine.intState=me.StateMachine.intStateLastCycle) THEN
		
		IF (SIf.Cfg.bolStopAtRejact) THEN
			;	// Let Junction open
		ELSE
			SIf.Out.bolOpen.intern := 0;
		END_IF
		SIf.Out.bolBlow.intern := 0;
		
		// State Change Condition
		IF 	((CIf.Job.bolAlmReset = TRUE) OR 																// Standart Error Reset
			((Cif.Job.eMe_ActivAlmClass = E_AlmClass.TSTOP) AND SIf.In.bolButtonRestartTLP.intern)) THEN	// Reset CHD with own button
			me.StateMachine.intStateNext := cSTA_ERRORQuit;
		END_IF
	END_IF




//--------------------------------------------------------------------------------------
// Exit action
	IF (me.StateMachine.intState<>me.StateMachine.intStateNext) THEN
		;
	END_IF]]></ST>
      </Implementation>
    </Method>
    <Method Name="StateMachine" Id="{6a30e26e-1b2c-487a-8b58-f3acadb0fa2d}">
      <Declaration><![CDATA[METHOD PROTECTED StateMachine : BOOL
]]></Declaration>
      <Implementation>
        <ST><![CDATA[SUPER^.StateMachine();

// main statemachine of base controller
CASE me.StateMachine.intState OF
    cSTA_RUNBusy: 
        THIS^.sta_RUNBusy();
    cSTA_RUN: 
        THIS^.sta_RUN();
     cSTA_STOPBusy: 
        THIS^.sta_STOPBusy();
    cSTA_STOP: 
        THIS^.sta_STOP();
END_CASE;]]></ST>
      </Implementation>
    </Method>
    <Method Name="getCtrlSIf" Id="{79357708-fc39-4cad-a072-92c3efb145fa}">
      <Declaration><![CDATA[METHOD getCtrlSIf : POINTER TO T_Ctrl_SIf_CHD
]]></Declaration>
      <Implementation>
        <ST><![CDATA[getCtrlSIf := ADR(SIf);]]></ST>
      </Implementation>
    </Method>
    <Method Name="sta_RUN" Id="{87bf89d8-1e77-4184-8cc1-a65117c38875}">
      <Declaration><![CDATA[METHOD PROTECTED sta_RUN : BOOL
]]></Declaration>
      <Implementation>
        <ST><![CDATA[// state implemetation
//--------------------------------------------------------------------------------------
// Entry action
	IF (me.StateMachine.intState<>me.StateMachine.intStateLastCycle) THEN
		me.StateMachine.intStateLastCycle := me.StateMachine.intState;
			
		me.SubStateMachine.intState := cSTA_SUB_WAIT_FOR_JOB; // init sub state machine
		me.SubStateMachine.intStateNext := cSTA_SUB_WAIT_FOR_JOB; // init sub state machine
		fbSimulationTimer.PT := UDINT_TO_TIME(SIf.Par.udiSimPassTime_ms);
		fbSimulationTimer(); // set time/reset timer

	END_IF


//--------------------------------------------------------------------------------------
// Cyclic action
	IF (me.StateMachine.intState=me.StateMachine.intStateLastCycle) THEN
		// Simulation
		IF (CIf.SwCfg.bolSimulation) THEN
			fbSimulationTimer(); // set time/reset timer
			IF (SIf.Out.bolOpen.intern = TRUE) THEN 
				fbSimulationTimer.IN := TRUE;
			ELSIF (SIf.Out.bolOpen.intern = FALSE) AND (fbSimulationTimer.Q = TRUE) THEN
				fbSimulationTimer.IN := FALSE;			
			END_IF
			IF (fbSimulationTimer.Q = TRUE) AND (bolSetSimuPassedOnce = FALSE) THEN
				SIf.In.bolPassed.intern := TRUE;
				bolSetSimuPassedOnce := TRUE;
			ELSE
				SIf.In.bolPassed.intern := FALSE;
			END_IF
			IF (fbSimulationTimer.Q = FALSE) THEN
				bolSetSimuPassedOnce := FALSE;	
			END_IF
		END_IF
		
		//--------------------------------------------------------------------------------------
		// Always RUN actions
		
		// If this task is in faster cycle then the parent, calculate internal position more exactly during the taskcycle
		IF dinTransportPositionOld_um <> SIf.Cur.dinTransportPosition_um THEN
			SIf.Cur.dinTransportPositionCalc_um := SIf.Cur.dinTransportPosition_um;
			dinTransportPositionOld_um := SIf.Cur.dinTransportPosition_um;
			dinPositionCorrection_um := 0;
		ELSE
			dinPositionCorrection_um := dinPositionCorrection_um + LREAL_TO_DINT(DINT_TO_LREAL(SIf.Cur.dinTransportspeed_um_s) * UDINT_TO_LREAL(me.FUBInfo.udiSample_ms) / 1000.0 );
			SIf.Cur.dinTransportPositionCalc_um := dinTransportPositionOld_um + dinPositionCorrection_um;
		END_IF
		
		// Check for double hanger (Sensors: just double hanger, if nothing seen -> junction closed)
		// -> Write bad hangers to table
		IF (SIf.Cfg.bolHasEmptyHangerSensor = FALSE) THEN
			IF (SIf.In.bolSensorDoubleHanger.intern = TRUE) THEN
				bolWriteInTable := TRUE;
			ELSE
				bolWriteInTable := FALSE;
				bolWriteInTableOnce := FALSE;
			END_IF
			bolWay1 := TRUE;	// WAY1 = OPEN
			bolWay2 := FALSE;	// WAY2 = CLOSE
		// Check for double hanger (Sensors: Double hanger, empty hanger, if nothing seen -> junction open)
		// -> Write good hangers to table
		ELSE
			IF ((SIf.In.bolSensorDoubleHanger.intern = TRUE) AND (bolWaitForEmptyHanger = FALSE)) THEN
				dinWaitForEmptyHangerPos_um := SIf.Cur.dinTransportPositionCalc_um + SIf.Par.dinDistanceBetweenSensors_DoubleHangerFirst_um;
				bolWaitForEmptyHanger := TRUE;
				// DoubleHanger comes to late, Hanger already in table -> clear is needed
				IF (bolWriteInTable AND (bolClearHanger= FALSE)) THEN
					bolClearHanger := TRUE;
				END_IF	
			ELSE
				bolClearHanger := FALSE;
				bolClearHangerOnce := FALSE;
			END_IF
			
			IF (bolWaitForEmptyHanger = TRUE) THEN	// DoubleHanger detected -> doesn't care with or without shirt
				IF (dinWaitForEmptyHangerPos_um < SIf.Cur.dinTransportPositionCalc_um) THEN // Empty Hanger, write in Table
					bolWaitForEmptyHanger := FALSE;
				END_IF
			ELSE // No DoubleHanger detected -> if Not EmptyHanger then it is a valid Hanger
				IF ((SIf.In.bolSensorEmptyHanger.intern = TRUE) AND (bolWriteInTableOnce = FALSE)) THEN	
					bolWriteInTable := TRUE;
					dinPostionShirtDetected := SIf.Cur.dinTransportPositionCalc_um;
//				ELSIF (SIf.In.bolSensorEmptyHanger.intern = FALSE) THEN
				ELSIF ((SIf.In.bolSensorEmptyHanger.intern = FALSE) AND (SIf.Cur.dinTransportPositionCalc_um > (dinPostionShirtDetected+SIf.Par.dinDistanceBetweenSensors_EmptyHangerFirst_um))) THEN
					bolWriteInTableOnce := FALSE;
					bolWriteInTable := FALSE;
				// Max dint value reached, position starts with max negativ position
				ELSIF ((dinPostionShirtDetected >0 ) AND (SIf.Cur.dinTransportPositionCalc_um < 0) AND (SIf.In.bolSensorEmptyHanger.intern = FALSE)) THEN
					bolWriteInTableOnce := FALSE;
					bolWriteInTable := FALSE;
				END_IF
			END_IF
			bolWay1 := FALSE;	// WAY1 = OPEN
			bolWay2 := TRUE;	// WAY2 = CLOSE
		END_IF
		
		// Write in table
		IF	((bolWriteInTable = TRUE) AND (bolWriteInTableOnce = FALSE)) THEN
			uinWriteTblIndex := uinWriteTblIndex + 1;
			IF uinWriteTblIndex > cuintMaxIndex THEN
				uinWriteTblIndex := 0;
			END_IF
			dinPositionWithoutSensorSignal_OLD:= dinPositionWithoutSensorSignal;	// Save Old Position
			bolWriteInTableOnce:= TRUE;
			aTblDecision[uinWriteTblIndex].eState := E_DecisionState.WayToJunction;
			aTblDecision[uinWriteTblIndex].dinActPos_um := 1;	
		END_IF
		IF (bolClearHanger AND NOT bolClearHangerOnce) THEN // Clear HangerHasShirt if a DoubleHanger is detected
			bolClearHangerOnce:= TRUE;						// Do it Once
			aTblDecision[uinWriteTblIndex].eState := E_DecisionState.Processed;	// Nothing to Do
			aTblDecision[uinWriteTblIndex].dinActPos_um := -1;					// No Position needed
			dinPositionWithoutSensorSignal:= dinPositionWithoutSensorSignal_OLD;// Restore old Position
		END_IF
		
		// Increase the position of every Hanger in the table, if it is on the way to junction
		dinTransportDifferenz_um := SIf.Cur.dinTransportPositionCalc_um - dinTransportPositionCalc_old_um;
		FOR uinI := 0 TO cuintMaxIndex DO
			IF ((aTblDecision[uinI].eState = E_DecisionState.WayToJunction) OR (aTblDecision[uinI].eState = E_DecisionState.OnJunction)) THEN
				aTblDecision[uinI].dinActPos_um := aTblDecision[uinI].dinActPos_um + dinTransportDifferenz_um;
			END_IF
		END_FOR	
		dinTransportPositionCalc_old_um := SIf.Cur.dinTransportPositionCalc_um;
		
		// Check table if there is a job
		dinPositionDifference_um := SIf.Par.dinPosition_um; // Set maximal value to search the smalles one
		// Loop through the table
		FOR uinI := 0 TO cuintMaxIndex DO
			// Check if this job is on the way to the junction
			IF aTblDecision[uinI].eState = E_DecisionState.WayToJunction THEN
				// Chech if it is the nearest tag
				IF 	dinPositionDifference_um > SIf.Par.dinPosition_um - aTblDecision[uinI].dinActPos_um THEN
					dinPositionDifference_um := SIf.Par.dinPosition_um - aTblDecision[uinI].dinActPos_um;
					uintNextHastableIdx := uinI;
				END_IF
			END_IF
		END_FOR
		IF ((dinPositionDifference_um = SIf.Par.dinPosition_um) OR 			// No Hanger found
			(dinPositionDifference_um > SIf.Par.dinPinDistance_um)) THEN 	// Pin without information is nearest
			dinPositionWithoutSensorSignal:= dinPositionWithoutSensorSignal + dinTransportDifferenz_um;
		ELSE
			dinPositionWithoutSensorSignal:= 0;								// Good hanger on way to junction
		END_IF
		
		// A hanger is on slide message
		IF ((SIf.In.bolPassed.intern = TRUE) AND (bolFpPassed = FALSE)) THEN
			bolFpPassed := TRUE;
			udinTimeUntilJamDetected:= 0;
				
			IF SIf.cfg.bolStopAtRejact THEN
				IF (SIf.Cfg.bolHasEmptyHangerSensor = TRUE) THEN // Just if Emty Hanger Exist
					// Set Alarm: SIf.Alm[4].strText := 'TLP stopped by CHD';
					pfbAlarmCtrl^.setAlarm(CIf.Info.intCtrlId,4,0,ADR(SIf.Alm),E_AlmState.RST,CIf.Job.eMe_ActivAlmClass);
					me.SubStateMachine.intStateNext := cSTA_SUB_ERROR;
					SIf.Out.bolLightTLPStopedByCHD.intern := TRUE;
				END_IF
				; //Else No message needed
			ELSE	
				// Set Alarm: SIf.Alm[2].strText := 'Cross hanger detection has an hanger rejected';
				pfbAlarmCtrl^.setAlarm(CIf.Info.intCtrlId,2,0,ADR(SIf.Alm),E_AlmState.RST,CIf.Job.eMe_ActivAlmClass);	
			END_IF
		ELSIF (SIf.In.bolPassed.intern = FALSE) THEN
			bolFpPassed := FALSE;
		END_IF
		// Jam on slide message
		IF (bolFpPassed = TRUE) THEN
			udinTimeUntilJamDetected:= udinTimeUntilJamDetected + me.FUBInfo.udiSample_ms;
			IF (udinTimeUntilJamDetected > SIf.Par.udinTimeUntilJam_ms) THEN
				// SIf.Alm[3].strText := 'Open not possible, destination is full';
				pfbAlarmCtrl^.setAlarm(CIf.Info.intCtrlId,3,0,ADR(SIf.Alm),E_AlmState.RST,CIf.Job.eMe_ActivAlmClass);
			END_IF
		END_IF

		
		// Count double hanger
		IF (SIf.In.bolSensorDoubleHanger.intern AND NOT bolDoubleHangerOnce) THEN
			SIf.Cur.udintCounterDoubleHanger := SIf.Cur.udintCounterDoubleHanger + 1;
			bolDoubleHangerOnce := TRUE;
		ELSIF (SIf.In.bolSensorDoubleHanger.intern = FALSE) THEN
			bolDoubleHangerOnce := FALSE;
		END_IF
		
		//--------------------------------------------------------------------------------------
		// sub state machine for sequence
		CASE me.SubStateMachine.intState OF
			//--------------------------------------------------------------------------------------
			cSTA_SUB_WAIT_FOR_JOB:
				IF (me.SubStateMachine.intState<>me.SubStateMachine.intStateLastCycle) THEN
					me.SubStateMachine.intStateLastCycle := me.SubStateMachine.intState;
				END_IF
				// State Change Condition
				// Simulation
				IF (CIf.SwCfg.bolSimulation) THEN
					;// SIf.In.bolPassed.intern := FALSE;
				END_IF
				
				
				// If reaction way (time*speed) is bigger then the rest of the way to the junction, close
				IF dinPositionDifference_um <= LREAL_TO_DINT( UDINT_TO_LREAL(SIf.Par.udiCloseTime_ms) * DINT_TO_LREAL(SIf.Cur.dinTransportspeed_um_s) ) / 1000.0 THEN
					me.SubStateMachine.intStateNext := cSTA_SUB_WAY1;	// cSTA_SUB_CLOSE;
				// Empty hanger or crossed hanger at (junction - reaction way)
				ELSIF (dinPositionWithoutSensorSignal >= (SIf.Par.dinPinDistance_um - LREAL_TO_DINT( UDINT_TO_LREAL(SIf.Par.udiOpenTime_ms) * DINT_TO_LREAL(SIf.Cur.dinTransportspeed_um_s))/1000.0)) THEN
//					IF (SIf.In.bolPassed.intern = FALSE) THEN
						me.SubStateMachine.intStateNext := cSTA_SUB_WAY2;	// cSTA_SUB_OPEN;
//						bolTimeForJamOnce := FALSE;	
//					ELSE
(*						IF (bolTimeForJamOnce = FALSE) THEN
							udinTimeUntilJamDetected:= me.StateMachine.udiTimeInState_ms + SIf.Par.udinTimeUntilJam_ms;
							bolTimeForJamOnce := TRUE;	
						END_IF
						IF (bolTimeForJamOnce AND (udinTimeUntilJamDetected < me.StateMachine.udiTimeInState_ms)) THEN
*)							// SIf.Alm[3].strText := 'Open not possible, destination is full';
//							pfbAlarmCtrl^.setAlarm(CIf.Info.intCtrlId,3,0,ADR(SIf.Alm),E_AlmState.RST,CIf.Job.eMe_ActivAlmClass);
//							me.SubStateMachine.intStateNext := cSTA_SUB_WAY2;
(*							me.SubStateMachine.intStateNext := cSTA_sub_ERROR;
							bolTimeForJamOnce := FALSE;
						END_IF
*)//				END_IF
				END_IF

			//--------------------------------------------------------------------------------------
			cSTA_SUB_WAY1: //CLOSE
				IF (me.SubStateMachine.intState<>me.SubStateMachine.intStateLastCycle) THEN
					me.SubStateMachine.intStateLastCycle := me.SubStateMachine.intState;

					uintActHastableIdx := uintNextHastableIdx;
					aTblDecision[uintNextHastableIdx].eState := E_DecisionState.OnJunction;
					
				END_IF
					
				SIf.Out.bolOpen.intern := bolWay1;	// FALSE
					
				// Simulation
				IF (CIf.SwCfg.bolSimulation) THEN
					;
				END_IF
					
				// Check position
				IF (SIf.Par.dinPosition_um + SIf.Par.dinOpenWay_um <= aTblDecision[uintActHastableIdx].dinActPos_um + dinPositionCorrection_um) THEN
					IF aTblDecision[uintActHastableIdx].eState < E_DecisionState.Processed THEN
						// Only set to processe if not allready driven out
						aTblDecision[uintActHastableIdx].eState := E_DecisionState.Processed;
					END_IF					
					aTblDecision[uintActHastableIdx].dinActPos_um := -2;
				END_IF
					
				// State Change Condition
				// Check error if tray never reach the output
				IF (me.SubStateMachine.udiTimeInState_ms > SIf.Par.udiPassTime_ms) THEN
					// Set Alarm: SIf.Alm[1].strText := 'timeout passed sensor does not detect the hanger'; 
					pfbAlarmCtrl^.setAlarm(CIf.Info.intCtrlId,1,0,ADR(SIf.Alm),E_AlmState.RST,CIf.Job.eMe_ActivAlmClass);
					me.SubStateMachine.intStateNext := cSTA_SUB_ERROR;
				// Check if tray allready passed
			//	ELSIF (aTblDecision[intActHastableIdx].eState > E_DecisionState.OnJunction) AND (dinPositionDifference_um < LREAL_TO_DINT ( UDINT_TO_LREAL(SIf.Par.udiCloseTime_ms) * DINT_TO_LREAL(SIf.Cur.dinTransportspeed_um_s) / 1000.0 ) ) THEN
			//		me.SubStateMachine.intStateNext := cSTA_SUB_WAY1;	// cSTA_SUB_CLOSE;
				ELSIF (aTblDecision[uintActHastableIdx].eState > E_DecisionState.OnJunction) THEN	
					IF (SIf.cfg.bolStopAtRejact AND (SIf.Cfg.bolHasEmptyHangerSensor = FALSE)) THEN // Just if no Emty Hanger Exist
						// Set Alarm: SIf.Alm[4].strText := 'TLP stopped by CHD';
						pfbAlarmCtrl^.setAlarm(CIf.Info.intCtrlId,4,0,ADR(SIf.Alm),E_AlmState.RST,CIf.Job.eMe_ActivAlmClass);
						me.SubStateMachine.intStateNext := cSTA_SUB_ERROR;
						SIf.Out.bolLightTLPStopedByCHD.intern := TRUE;
					ELSE
						me.SubStateMachine.intStateNext := cSTA_SUB_WAIT_FOR_JOB;
					END_IF
				END_IF

			//--------------------------------------------------------------------------------------
			cSTA_SUB_WAY2:	// OPEN:
				IF (me.SubStateMachine.intState<>me.SubStateMachine.intStateLastCycle) THEN
					me.SubStateMachine.intStateLastCycle := me.SubStateMachine.intState;
				END_IF
				
				SIf.Out.bolOpen.intern := bolWay2;	// TRUE;
					
				// Simulation
					
					
				// State Change Condition
				me.SubStateMachine.intStateNext := cSTA_SUB_WAIT_FOR_JOB;
				dinPositionWithoutSensorSignal := 0;

				// Simulation
				IF (CIf.SwCfg.bolSimulation) THEN
					;// SIf.In.bolPassed.intern := FALSE;
				END_IF
				
			//--------------------------------------------------------------------------------------
			cSTA_SUB_ERROR:
				IF (me.SubStateMachine.intState<>me.SubStateMachine.intStateLastCycle) THEN
					me.SubStateMachine.intStateLastCycle := me.SubStateMachine.intState;
				END_IF
				
				IF (SIf.cfg.bolStopAtRejact) THEN 
					;	// Let Junction open
				ELSE
					SIf.Out.bolOpen.intern := FALSE;
				END_IF
				
				// State Change Condition
				// No change, going over an other main state
					
		END_CASE
		
		// ------------------------------------------------------
		// Blow valve
		IF (udiBlowPassingTime_ms > Sif.par.udiIntervalLengthBlowValve_ms) THEN
			IF (udiBlowPassingTime_ms > (SIf.Par.udiIntervalLengthBlowValve_ms + SIf.Par.udiPulseLengthBlowValve_ms)) THEN
				SIf.Out.bolBlow.intern := FALSE;
				udiBlowPassingTime_ms := 0;
			ELSE
				SIf.Out.bolBlow.intern := TRUE;
			END_IF
		END_IF
				
		udiBlowPassingTime_ms := udiBlowPassingTime_ms + me.FUBInfo.udiSample_ms;
		// ------------------------------------------------------
		
		// State Change Condition
		// Check error if retracted position not reached
		IF me.SubStateMachine.intState = cSTA_SUB_ERROR THEN
			me.StateMachine.intStateNext :=  cSTA_ERROR;
		ELSIF(me.intCmd=cCMD_STOP) THEN
			me.StateMachine.intStateNext := cSTA_STOPBusy;
		END_IF
	END_IF




//--------------------------------------------------------------------------------------
// Exit action
	IF (me.StateMachine.intState<>me.StateMachine.intStateNext) THEN
		;
	END_IF]]></ST>
      </Implementation>
    </Method>
    <Method Name="sta_STOP" Id="{92c6535e-db49-4a78-9b60-96ad0283958a}">
      <Declaration><![CDATA[METHOD PROTECTED sta_STOP : BOOL
]]></Declaration>
      <Implementation>
        <ST><![CDATA[// state implemetation
//--------------------------------------------------------------------------------------
// Entry action
	IF (me.StateMachine.intState<>me.StateMachine.intStateLastCycle) THEN
		me.StateMachine.intStateLastCycle := me.StateMachine.intState;
		
	END_IF


//--------------------------------------------------------------------------------------
// Cyclic action
	IF (me.StateMachine.intState=me.StateMachine.intStateLastCycle) THEN
	
		
		// State Change Condition
		IF (me.intCmd=cCMD_RUN) THEN
			me.StateMachine.intStateNext := cSTA_RUNBusy;
		END_IF
	END_IF




//--------------------------------------------------------------------------------------
// Exit action
	IF (me.StateMachine.intState<>me.StateMachine.intStateNext) THEN
		;
	END_IF]]></ST>
      </Implementation>
    </Method>
    <Method Name="sta_OFFBusy" Id="{95f78192-cb69-4087-8a49-9761f163a24c}">
      <Declaration><![CDATA[METHOD PROTECTED sta_OFFBusy : BOOL
]]></Declaration>
      <Implementation>
        <ST><![CDATA[// state implemetation
//--------------------------------------------------------------------------------------
// Entry action
	IF (me.StateMachine.intState<>me.StateMachine.intStateLastCycle) THEN
		me.StateMachine.intStateLastCycle := me.StateMachine.intState;
		
	END_IF


//--------------------------------------------------------------------------------------
// Cyclic action
	IF (me.StateMachine.intState=me.StateMachine.intStateLastCycle) THEN
		
		// switch VALVE off
		SIf.Out.bolOpen.intern := FALSE;
		SIf.Out.bolBlow.intern := FALSE;
		
		
		
		// State Change Condition
		IF (FALSE) THEN
			;
		ELSIF (TRUE) THEN
			me.StateMachine.intStateNext := cSTA_OFF;
		END_IF
	END_IF




//--------------------------------------------------------------------------------------
// Exit action
	IF (me.StateMachine.intState<>me.StateMachine.intStateNext) THEN
		;
	END_IF]]></ST>
      </Implementation>
    </Method>
    <Method Name="Always" Id="{9634e3f3-406e-4479-84d8-8b9191d279be}">
      <Declaration><![CDATA[METHOD PROTECTED Always : BOOL
]]></Declaration>
      <Implementation>
        <ST><![CDATA[SUPER^.Always();

// ----------------------------------------------------------------------------------
// cyclic actions outside of statemachine
IF (me.StateMachine.intState<>cSTA_SINGLE_ANSWER) THEN
	SIf.Cur.bolPassed := SIf.In.bolPassed.intern;
	SIf.Cur.bolOpen := SIf.Out.bolOpen.intern;

	; // always error supervision
	
END_IF

// Always change actions in Base Library
// ----------------------------------------------------------------------------------
// overrule error always from base -> no EOFF State!! in EOFF go to OFF
IF (me.StateMachine.intStateNext = cSTA_EOFFBusy) THEN
	IF (me.StateMachine.intState=cSTA_OFF) THEN
		me.StateMachine.intStateNext := cSTA_OFF;
	ELSE // stay in OFF
		me.StateMachine.intStateNext := cSTA_OFFBusy;
	END_IF
END_IF]]></ST>
      </Implementation>
    </Method>
    <Method Name="sta_RUNBusy" Id="{b2165949-7acb-42ee-a47b-0eff82f9abbf}">
      <Declaration><![CDATA[METHOD PROTECTED sta_RUNBusy : BOOL
]]></Declaration>
      <Implementation>
        <ST><![CDATA[// state implemetation
//--------------------------------------------------------------------------------------
// Entry action
	IF (me.StateMachine.intState<>me.StateMachine.intStateLastCycle) THEN
		me.StateMachine.intStateLastCycle := me.StateMachine.intState;
					
	END_IF


//--------------------------------------------------------------------------------------
// Cyclic action
	IF (me.StateMachine.intState=me.StateMachine.intStateLastCycle) THEN
	
	
		FOR uinWriteTblIndex := 0 TO cuintMaxIndex DO	// Clear table before RUN
			aTblDecision[uinWriteTblIndex].eState := E_DecisionState.none;
			aTblDecision[uinWriteTblIndex].dinActPos_um := 0;
		END_FOR	
		uinWriteTblIndex := 0;
				
		
		// State Change Condition
		me.StateMachine.intStateNext := cSTA_RUN;		
	END_IF
	



//--------------------------------------------------------------------------------------
// Exit action
	IF (me.StateMachine.intState<>me.StateMachine.intStateNext) THEN
		;
	END_IF]]></ST>
      </Implementation>
    </Method>
    <Method Name="sta_PON" Id="{d06469ec-34ca-4e94-ad0c-3019233a88e6}">
      <Declaration><![CDATA[METHOD PROTECTED sta_PON : BOOL
]]></Declaration>
      <Implementation>
        <ST><![CDATA[// state implemetation
//--------------------------------------------------------------------------------------
// Entry action
	IF (me.StateMachine.intState<>me.StateMachine.intStateLastCycle) THEN
		me.StateMachine.intStateLastCycle := me.StateMachine.intState;
		
	END_IF


//--------------------------------------------------------------------------------------
// Cyclic action
	IF (me.StateMachine.intState=me.StateMachine.intStateLastCycle) THEN
		
		;
		
		
		// State Change Condition
		IF(me.intCmd=cCMD_OFF) THEN
			me.StateMachine.intStateNext := cSTA_OFFBusy;
		ELSIF(me.intCmd=cCMD_RUN) THEN
			me.StateMachine.intStateNext := cSTA_OFFBusy;
		ELSIF(me.intCmd=cCMD_STOP) THEN
			me.StateMachine.intStateNext := cSTA_STOPBusy;
		END_IF
	END_IF




//--------------------------------------------------------------------------------------
// Exit action
	IF (me.StateMachine.intState<>me.StateMachine.intStateNext) THEN
		;
	END_IF]]></ST>
      </Implementation>
    </Method>
    <Method Name="IoInBridge" Id="{d7482b43-6d11-4dc5-818b-abdfbba8ef8e}">
      <Declaration><![CDATA[METHOD PROTECTED IoInBridge : BOOL
]]></Declaration>
      <Implementation>
        <ST><![CDATA[// digitale and analoge inputs read from hardware or forcing

SIf.In.bolPassed.map := THIS^.In_bolPassed;	// Slide full
SIf.In.bolSensorDoubleHanger.map := THIS^.In_bolDoubleHanger;
SIf.In.bolSensorEmptyHanger.map := THIS^.In_bolEmptyHanger;
SIf.In.bolSensorInconsistentHanger.map := THIS^.In_bolInconsistentHanger;
SIf.In.bolButtonRestartTLP.map := THIS^.In_bolRestartTLP;

IF (CIf.SwCfg.bolSimulation = FALSE) THEN
	
	getInBol(CIf.Job.bolIoForce,ADR(SIf.In.bolPassed));	// Slide full
	
	//getInBol(CIf.Job.bolIoForce,ADR(SIf.In.bolSensorDoubleHanger));
	getInBolDebounced(CIf.Job.bolIoForce, me.FUBInfo.udiSample_ms, Sif.Par.udiDebounceTimeDoubleHanger_ms, ADR(SIf.In.bolSensorDoubleHanger));

	getInBol(CIf.Job.bolIoForce,ADR(SIf.In.bolSensorEmptyHanger));
	getInBol(CIf.Job.bolIoForce,ADR(SIf.In.bolSensorInconsistentHanger));
	getInBol(CIf.Job.bolIoForce,ADR(SIf.In.bolButtonRestartTLP));
ELSE
	//simulation of global IO
END_IF
]]></ST>
      </Implementation>
    </Method>
    <Method Name="sta_OFF" Id="{e64e0b12-a087-4392-aca1-34b7a8662703}">
      <Declaration><![CDATA[METHOD PROTECTED sta_OFF : BOOL
]]></Declaration>
      <Implementation>
        <ST><![CDATA[// state implemetation
//--------------------------------------------------------------------------------------
// Entry action
	IF (me.StateMachine.intState<>me.StateMachine.intStateLastCycle) THEN
		me.StateMachine.intStateLastCycle := me.StateMachine.intState;
		
	END_IF


//--------------------------------------------------------------------------------------
// Cyclic action
	IF (me.StateMachine.intState=me.StateMachine.intStateLastCycle) THEN
		
		;
		
		
		// State Change Condition
		IF (me.Alarm.eActivAlmClass<>E_AlmClass.EOFF) AND (me.Alarm.eActivAlmClass<>E_AlmClass.OFF) THEN
			IF (me.intCmd=cCMD_STOP) THEN
				// sensor retract always on cylinder
				me.StateMachine.intStateNext :=  cSTA_STOPBusy;
			ELSIF(me.intCmd=cCMD_RUN) THEN
				me.StateMachine.intStateNext := cSTA_RUNBusy;
			END_IF
		END_IF
	END_IF




//--------------------------------------------------------------------------------------
// Exit action
	IF (me.StateMachine.intState<>me.StateMachine.intStateNext) THEN
		;
	END_IF]]></ST>
      </Implementation>
    </Method>
    <Method Name="getCmdState" Id="{e6a4370c-dba6-4345-a672-cac1d9e501dd}">
      <Declaration><![CDATA[METHOD PROTECTED getCmdState : STRING
VAR_INPUT
	intCmdState: INT;
	bolState: BOOL;
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[getCmdState := SUPER^.getCmdState(intCmdState:=intCmdState,bolState:=bolState); // get global/base defined cmds/states
IF (getCmdState='') THEN // global not defined get local
	// get string cmd/state string information in runtime
	IF (bolState=FALSE) THEN
		// cmd's
(*		CASE intCmdState OF
			; // nothing
		END_CASE;
*)	ELSE
	
	// cmd's
		CASE intCmdState OF
			cSTA_RUNBusy: 
				THIS^.sta_RUNBusy();
			cSTA_RUN: 
				THIS^.sta_RUN();
			cSTA_STOPBusy: 
				THIS^.sta_STOPBusy();
			cSTA_STOP: 
				THIS^.sta_STOP();
				
			// SUB States
			cSTA_SUB_INITIALIZED:
				getCmdState := 'cSTA_SUB_INITIALIZED';
			cSTA_SUB_WAIT_FOR_JOB:
				getCmdState := 'cSTA_SUB_WAIT_FOR_JOB';
(*			cSTA_SUB_OPEN:
				getCmdState := 'cSTA_SUB_OPEN';
			cSTA_SUB_CLOSE:
				getCmdState := 'cSTA_SUB_CLOSE';
*)			cSTA_SUB_WAY1:
				getCmdState := 'cSTA_SUB_WAY1';
			cSTA_SUB_WAY2:
				getCmdState := 'cSTA_SUB_WAY2';
			cSTA_SUB_ERROR:
				getCmdState := 'cSTA_SUB_ERROR';
			cSTA_SUB_FINISHED:
				getCmdState := 'cSTA_SUB_FINISHED';
		END_CASE;
	END_IF
END_IF
]]></ST>
      </Implementation>
    </Method>
  </POU>
</TcPlcObject>